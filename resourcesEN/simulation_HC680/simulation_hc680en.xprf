' Simulation Microprocessor HC680 -fictive- 8 bit
'----------------------------------------------------
'{--> Overview: registers, address types, fixed RAM addresses
          '          *** translated comments of the original german version ***
          ' Register:
          ' No Name  xx Bin  Type    
          ' 0  D0    00      Data register
          ' 1  D1    01      Data register
          ' 2  A0    10      Address base register
          ' 3  A1    11      Address index register
          ' SD0/SD1 Shadow register to D0/D1
          ' SA0/SA1 Shadow register to A0/A1
          '    IR Instruction Register 
          '    IC Instruction Counter
          '    SR Status Register 
          '    SP Stack Pointer
          '    ST Start address
          ' ------------------------------
          '  A1 is as an offset +A, IA 
          '  signed
          ' ------------------------------               
          '
          ' Status Register SR
          '     IOXYNZVC
          ' In/ IO=00 char
          ' Out   =01 decimal
          '       =10 hexadecimal
          '       =11 binary
          ' freely available XY
          ' Flags N Negative
          '       Z Zero
          '       V oVerflow
          '       C Carry
          '
          ' -----------------------------------
          ' -->  addressing modes	      in
          '                            assembler
          '                            _________
          ' * adr./register fix
          '
          ' value in/into register:
          ' * register direct      
          '   Reg xx, Reg yy             .Rg.
          ' Value in/into RAM (Adr.in Reg.)          
          ' * register indirect           
          '   Adr.(Reg xx)               [Rg]
          '            yy
          '
          ' Adr. with offset
          ' * IC relative		                
          '   Adr.: IC + A1              .+A.
          '
          ' * IndexAddress             
          '   Adr.: A0 + A1  + ST        .IA.
          '
          ' * at LOD/STO/RCL
          '   Adr.: h80 + A1 + ST
          ' ---
          '   A1 as an index with sign
          '
          ' -------------------------------------          
          ' fixed RAM addresses:
          '
          ' h00 standard start address
          ' h80 basis adr. data (down)
          ' hF5 basis adr. stack (up)
          ' hF6 address keyboard input
          ' hF7 address display pixel
          ' hF8 - hFF  MGA-display 8x8 ("Maxipixel")
'}
'{--> Overview: mnemonics assembler & machine commands of the  HC680 
'             
'                       operation code - Systematics of grouping:
'                         g group
'                         b bit addressing type/command variants
'                         yy,xx 2 register or type/command variants   
'
'       assembler     machine command	    effect/meaning	
'                     Opcode/binary code    Addressing type
'
'       mnem.            g  b yy xx       -----------------------------------------	
'            operands 
'        NOP 	          000 0 00 00	      No Operation	
'        CMP 	          000 0 00 01	      CoMPare D0, D1	
'        SWD            000 0 00 10	      SWap D0, D1
'        SWM 	          000 0 00 11	      SWap Memory Adr(D0), Adr(D1)
'               arithmetic/stack commands --------------------------------------
'        MUL	          000 0 01 00	      MULtiplication D0 <- D0*D1	
'        DIV	          000 0 01 01	      DIVision D0 <- D0\D1	rest SD0	
'        PSA	          000 0 01 10	      PuSh All Stack <- A,D,SR Reg.
'        POA	          000 0 01 11	      POp All SR,D,A reg. <- Stack	
'               jump commands	 ----------------------------------------------------		
'        JSR	          000 0 10 00	      Jump SubRoutine Stack<-IC+1, A0=0: IC<-IC+A1 else IC<-A0+A1+ST
'        JIN +A	        000 0 10 01       N=1: IC <- IC +A1     Jump If Negative
'        JIZ +A	        000 0 10 10  	    Z=1: IC <- IC +A1	    Jump If Zero
'        JMP +A	        000 0 10 11	           IC <- IC +A1	    Jump
'                       ...........
'        RET	          000 0 11 00  	    RETturn subroutine IC <-Stack
'        JIN IA	        000 0 11 01  	    N=1: IC <- A0 +A1 +ST Jump If Negative	
'        JIZ IA	        000 0 11 10  	    Z=1: IC <- A0 +A1 +ST	Jump If Zero
'        JMP IA 	      000 0 11 11	           IC <- A0 +A1 +ST JuMP
'               load constant ----------------------------------------------------  
'        LDC Rg         000 1 00 xx       LoaD Constant Register    Reg xx <- next byte ##
'        ##  CCCC CCCC                    ## Constant byte
'                             .. register ..
'        JIN RG 	      000 1 01 xx 	    N=1: IC <- Reg xx	    Jump If Negative
'        JIZ RG	        000 1 10 xx  	    Z=1: IC <- Reg xx	    Jump If Zero
'        JMP RG 	      000 1 11 xx            IC <- Reg xx	    JuMP
'              input/output/stack commands -----------------------------------
'        INP RG (IO)    001 0 00 xx   	  Reg xx        <- INPut
'        OUT RG	(IO)    001 0 01 xx   	  OUTput        <- reg xx
'        PSH RG	        001 0 10 xx   	  PuSH  Stack   <- reg xx
'        POP RG	        001 0 11 xx   	  POP  Reg xx   <- stack
'               shadow register /Nibble ----------------------------------------
'        SSR Rg         001 1 00 xx   	  Set Shadow Register   reg xx -> Sxx (SDx, SAx)
'        GSR RG         001 1 01 xx       Get Shadow Register   reg xx <- Sxx (SDx, SAx)
'        BTS RG         001 1 10 xx       BitTest with Shadow register
'        SWN RG         001 1 11 xx       SWap Nibble reg xx
'               arithmetic/ logical commands/ SR/ SP  --------------------------
'        SHL RG	        010 0 00 xx   	  SHift Left   reg xx
'        SHR RG	        010 0 01 xx   	  SHift Right  reg xx
'        ROL RG	        010 0 10 xx   	  ROtate Left  reg xx
'        ROR RG	        010 0 11 xx   	  ROtate Right reg xx
'                       ...........
'        CLR RG	        010 1 00 xx   	  CLear Register reg xx <- 0	
'        INC RG	        010 1 01 xx   	  INCrement reg xx  
'        DEC RG	        010 1 10 xx       DECrement reg xx
'        NOT RG	        010 1 11 xx   	  reg xx <- NOT reg xx (bitwise)
'                       ----- Reg Reg/ *) transport commands SR/ SP -----------------
'        MOV RG  SR     011 0 yy yy       MOVe      reg yy <-  SR     *1) xx=yy
'        AND RG  RG	    011 0 yy xx   	  Reg yy <- reg yy AND reg xx,   xx<>yy  
'        MOV RG  SP     011 1 yy yy       MOVe      reg yy <-  SP     *2) xx=yy
'        OR  RG  RG	    011 1 yy xx   	  Reg yy <- reg yy OR  reg xx,   xx<>yy
'                       -----------------------------------------------------------
'        MOV SR  RG 	  100 0 xx xx	      MOVe          SR <- reg xx  *3) xx=yy
'        ADD RG  RG	    100 0 yy xx   	  Reg yy <- Reg yy +  reg xx,    xx<>yy
'        ADD RG  [RG]   100 1 yy xx   	  Reg yy <- Reg yy +  Adr(Reg xx)
'                       -----------------------------------------------------------
'        MOV SP  RG 		101 0 xx xx     	MOVe          SP <- reg xx  *4) xx=yy
'        SUB RG  RG	    101 0 yy xx   	  reg yy <- reg yy -  reg xx,    xx<>yy
'        SUB RG  [RG]   101 1 yy xx   	  reg yy <- reg yy -  Adr(reg xx)
'              transport commands ---------------------------------------------------
'        MOV [RG] RG	  110 0 yy xx  	    MOVe Adr(reg yy) <- reg xx 
'        MOV RG  [RG]	  110 1 yy xx   	  MOVe reg yy      <- Adr(reg xx)
'                       ----- Const. ----                         
'        MOV SR  CC		  111 0 CC CC	      MOVe          SR <- CC..    *5) xx=yy 2Bit IO
'                       ..... Reg Reg .. 
'        MOV RG  RG   	111 0 yy xx   	  MOVe Reg yy      <- reg xx,    xx<>yy 
'                             .. Reg ..
'        MOV RG  IA     111 1 00 xx   	  MOVe reg xx      <- Adr(A0+A1+ST)
'        MOV IA  RG     111 1 01 xx   	  Adr(A0+A1+ST)  <- reg xx
'        LOD RG	        111 1 10 xx   	  Load Data   Reg xx <- Adr(h80+A1+ST)
'             save commands /copy command /stop ---------------------------------
'        STO (IO)	      111 1 11 00   	  STOre   file <- Adr(h80+A1+ST) D0 Byte, via D1 (type: IO) 
'        RCL (IO)       111 1 11 01       ReCalL  Adr(h80+A1+ST) <- file; via D1 (type: IO)  /D0 byte read
'        CPY		        111 1 11 10	      CoPY Adr(A1)<-Adr(A0); D0 Byte via D1
'        STP		        111 1 11 11	      StoP   Stop program, flags from pre-command    
'        --------------------------------------------------------------------------
'   If the IC runs under h00/over hFF it is cyclically set into the valid range, as well as the operand Adr(h80/A0 +A1+ST).
'   No specification for FLAG: Flag is set to 0.  Data IO: 00 character, 01 decimal, 10 hexadecimal, 11 binary (one value per line).
'      
'}
main
proc main   ' {
'{--- windows / colors / font  ------------------------------------
windowtitle "Simulation               Processor HC680 -fictional-             8 Bit Data/Addresses          V 1.0.8"
windowstyle 31
window 8,8 - 1024,748
useicon "KNOPF1" ' solid gray icon
'
set("Decimals",0)
var black%     = RGB(0,0,0)
var white%     = RGB(255,255,255)
var grey%      = RGB(192,192,192)    ' button, grid lines gray
'
var red%       = RGB(240,0,0)        ' button red
var yellow%    = RGB(255,255,0)      ' button yellow
var richgreen% = RGB(0,200,0)        ' button rich green 
'
var darkgreen% = RGB(0,160,0)        ' dark green font
var darkred%   = RGB(225,0,0),       ' dark red font
'
'Show default window color and help tooltips (if INI.TXT not in folder)
var b_red%     = 238                 ' background red part
var b_green%   = 238                 ' background green part
var b_blue%    = 211                 ' background blue part
var htt%       = 1                   ' show help tooltips 1, hide 0  
var ini$ = ""
if fileexists("INI.TXT")             ' overwrite from file if available
  assign #1, "INI.TXT"
  reset #1
  whilenot EOF(#1)
    input #1,ini$
    case left$(ini$,2) ="R=" : b_red%   = val(mid$(ini$,3,3))
    case left$(ini$,2) ="G=" : b_green% = val(mid$(ini$,3,3))
    case left$(ini$,2) ="B=" : b_blue%  = val(mid$(ini$,3,3))
    case left$(ini$,2) ="H=" : htt%     = val(mid$(ini$,3,1))
  endwhile
  close #1
endif
var backgrdc%  = RGB(b_red%, b_green%, b_blue%)           ' background color
var chipc%     = RGB(b_red%+15, b_green%+15, b_blue%+15)  ' chip color: IO and CPU     
'
cls backgrdc%                     
textcolor black%, backgrdc%     
usefont "Arial", 16,6,0,0,0          ' default font for the window
' --- fonts for the controls ---                                        
var sfont%       = create("font","Lucida Console" , 12, 7,0,0,0)         
var font%        = create("font","Lucida Console" , 14, 8,0,0,0) 
var spfont%      = create("font","Lucida Console" , 12, 8,0,0,0)
var xfont%       = create("font","Arial", 17,9,1,0,0)
var afont%       = create("font","Arial", 15,7,0,0,0)
var symbolfont%  = create("font","Symbol",19,10,0,0,0)
  '}
'{--- global variables for the simulation ---------------------------
declare inp$                   ' user input into edit decimal/ char/ hexadecimal hxx Hxx $xx
declare hinp$                  ' input hexadecimal
declare binp$                  ' input binary
declare inpval%                ' value input
declare ansi%                  ' ANSI-Code char or of the first char in the string
declare boutp$                 ' output binary
declare oc$                    ' opcode of the command (binary, parsed: xxx x xx xx)
declare mn$, op1$, op2$        ' mnemonic,  operand 1, operand 2
declare ocg$                   ' opcode grop 3 bit
declare ocb$                   ' opcode bit (place 4)
declare ocyy$                  ' opcode 2bit (partly target register)
declare ocxx$                  ' opcode 2bit (partly source register)
declare rx%                    ' opcode decimal (partly index of register field)
declare ry%                    ' opcode dezimal (partly index of register field)
declare ocyyxx$                ' yy xx combine (with space)
declare coninp$                ' constant - input from edit
declare conbin$                ' constant binary representation
declare conval%                ' decimal value of constant
declare opcomm$                ' comment on command
declare concomm$               ' comment on constant
declare IO_SR$                 ' left two bits of the Status Register, type input/output character, dec, hex, bin
declare XY_SR$                 ' bits 3,4 of the status register, freely usable
declare fl$                    ' flags that can be set by the command
declare N$                     ' N-flag (negativ)            0/1 --> Status Register SR
declare Z$                     ' Z-flag (zero)               0/1 --> Status Register SR
declare V$                     ' V-flag (overflow )          0/1 --> Status Register SR 
declare C$                     ' C-flag (carry)              0/1 --> Status Register SR
declare N_$                    ' N-flag as char N  after command execution
declare Z_$                    ' Z-flag as char Z  after command execution       
declare V_$                    ' V-flag as char V  after command execution
declare C_$                    ' C-flag as char C  after command execution
      'V-flag, oVerflow flag: If the overflow flag is set, then an overflow occurred during the last arithmetic operation
         ' if signed operands are assumed. (< -128  oder  > 127) 
      ' C flag, Carry flag: If this flag is set, then a carry occurred during the last arithmetic operation, 
         ' assuming unsigned operands. (>255) 
         ' If the last executed instruction was a shift/rotate operation, the carry flag indicates 
         ' whether a bit was shifted out or around.
declare C8$, R8$               ' carryover and result  8 bit 
declare C9$, R9$               ' carryover and result  9 bit (ALU)
declare bit%                   ' bit counter
//declare bit$                 ' bit "0" or "1"
declare b1$, b2$, b3$          ' individual bits of the operands, the carry, the shift counter
declare bc$, r$                ' bit carryover, bit result
declare x%, y%, mk%, mk$       ' mouse coordinates x%, y% and one mouse button pressed: mk% 1 --> mk$ "1". 
declare ip%, jp%               ' row and column index of the maxipixels of the MGA display (Micro-Graphic-Adapter) 
declare pix$                   ' MGA pixel (0 or 1)
declare mgapix$                ' MGA address pixel/status (7 bit from RAM line 247 = hF7)
declare b_res$                 ' byte with result/ intermediate result of an operation
declare temp%                  ' global temporary integer for intermediate storage
declare btemp1$, btemp2$       ' global temporary byte, intermediate storage
declare iofile$                ' channel file (internal), I/O file to be saved with STO command/ to be loaded with RCL
declare asmfile$               ' HC 680 assembler file
declare asm$                   ' assebler lines in file
declare l_asm%                 ' length of the assembler line
declare takt!                  ' variable processor clock
declare ms%                    ' clock delay in milliseconds
declare t0%                    ' CPU time base value
declare t%                     ' CPU time
declare debugfile$             ' debug file
declare debug$                 ' debug to IC state
declare breakp$                ' breakpoint    hexadecimal comparison value
declare break1$                ' breakpoint 1, hexadecimal 
declare break2$                ' breakpoint 2, hexadecimal 
declare break3$                ' breakpoint 3, hexadecimal
declare ramr$                  ' RAM row, content
declare row%                   ' calculated number of the RAM row, helper variable
declare mgarow$                ' row content in the MGA display
declare pv$                    ' program from - hexadecimal address for storage
declare pb$                    ' program to   - hexadecimal address for storage
declare dv$                    ' data    from - hexadecimal address for storage
declare db$                    ' data    to   - hexadecimal address for storage
declare bin8$                  ' binary number 8-bit 
declare hex2$                  ' hexadecimal number, 2 digits 
declare hex1$                  ' Hexadecimal digit
declare sp_h$                  ' variable space before h for hexadecimal value in RAM
declare msg%                   ' message result
declare taste%                 ' key code in event loop, end with key 27 (ESC)
declare key$                   ' key during program run (binary code --> RAM line 246 = hF6)
declare mn$[]                  ' array for mnemonics of the assembler
declare op$[]                  ' array for operands 1 and 2 for assember commands
declare R%[3]                  ' register array:         R%[0]= DO, R%[1]= D1, R%[2]= AO, R%[3]= A1
declare S%[3]                  ' shadow register array:  S%[0]=SDO, S%[1]=SD1, S%[2]=SAO, S%[3]=SA1
declare comment$[]             ' comment array for commands and constants
declare mga$[]                 ' RAM rows MGA display, content 
declare hlp$[]                 ' array, contents of the structure help assembler commands
var ramrow%    = 0             ' row number in RAM
var sta%       = 0             ' standard start address decimal
var sta$       = "00"          ' standard start address hexadecimal
var coderow%   = 0             ' number Command line (from h00 is default)
var ic_dez%    = 0             ' decimal value Instruction Counter IC
var ic_dez_fl% = 0             ' decimal IC - remember to insert the flags set by the command
var conrow%    = 128           ' number constant row
var starow%    = 245           ' default, stack row (base address)
var shiftass%  = 0             ' shift assembler in RAM
var halt%      = 0             ' halt program by operator: 1
var stop%      = 0             ' after STP command or error: 1
var break%     = 0             ' operator abort with X STOP: 1
var break123%  = 0             ' after one of the three breakpoints: 1
var timeover%  = 0             ' timer expired
var onestep%   = 0             ' for single step, clicked on next: 1 
var nospeed%   = 0             ' program execution in single step: 1
var afterstep% = 0             ' after program execution in single step: 1 (to restore status start button)
var fullspeed% = 0             ' from > 255Hz fullspeed = 1 (remember, no stop, reduce clock if necessary)
'}
'{--- surface RAM and CACHE ---------------------------------------
drawtext 18,1, "  Random Access Memory     -        256 Byte RAM"
roundrect 2,16,385,684,20,20
var ramkopf$ = "Address;0;75;hex;2;36;Content;2;83;Command/Value;0;116;FLAG;0;44;"  
var RAM%     = create("Gridbox", %hwnd, ramkopf$, 0, 4, 18, 379, 664)              'RAM - gridbox
setfont RAM%, font% 
'
if htt%   ' always hidden during program run - annoying! (therefore variable toolRAM$ to fade in)    
  var toolRAM$ = "RAM     8 bit addresses / 256 byte RAM, column for assembler and set flags" \
                + "\n" \
                + "\nmachine instruction each 1 byte including operands (with LDC constant in the following byte)" \
                + "\ndata/number range: decimal -128 ... 127 "\
                + "\n" \
                + "\nClick on a row in RAM to enter an assembly instruction " \
                + "\nor constant data (from hexadecimal 80) in the assembly area." \
                + "\n" \
                + "\nfixed addresses: " \
                + "\nF5 base address Stack Pointer" \ 
                + "\nF6 Keyboard byte" \
                + "\nF7 Status MGA display (pixel byte, see quick reference guide) " \ 
                + "\nF8 to" \
                + "\nFF    Rows MGA display" \
                + "\n" \
                + "\nCurrently set flags are displayed during program run." \
                + "\n " 
  var toolRAM% = create("Tooltip",%hWnd,RAM%,toolRAM$)
endif  
'
whileloop 0,255                                 ' generate RAM addresses, content zero
  bin8$ = d255_to_bin8(&loop)
  hex2$ = dez_to_hex2(&loop)
  ramr$ = bin8$ + "|" + hex2$ + "|" + "00000000" +"|"
  case &loop < 128 : ramr$ = ramr$ + "NOP"
  case &loop > 127 : ramr$ = ramr$ + "0    h00"
  addstring(RAM%, ramr$)
endwhile
settext RAM%, 245,4,"<-SP"                      ' base address STACKPOINTER
settext RAM%, 246,4,"->Ta"                      ' buffer byte for keyboard
settext RAM%, 247,4,">Pix"                      ' MGA Display Pixel
whileloop 248,255  
   settext RAM%,  &loop,4,"row"+str$(&loop-247) ' MGA Display row (1 bis 8)
endwhile 
'
var xram%    = create("Button" , %hWnd, "X", 170,  684,  17,  17)
setfont xram%, xfont%  
if htt% 
  create("Tooltip",%hWnd,xram%,"CAUTION! \nDelete the entire RAM, the flag column and the comments after confirmation prompt.\n ")
endif
drawtext 50, 684,"delete RAM/Flags"
'
var xflag%    = create("Button" , %hWnd, "X", 323, 684,  17,  17)
setfont xflag%, xfont%  
if htt% 
  create("Tooltip",%hWnd,xflag%,"CAUTION! \nDelete the column of the last set flags without confirmation prompt.\n ")
endif
drawtext 235, 684," delete Flags"
'
var CACHE% = create("gridbox", %hwnd," ;2;16;CACHE;2;80", 0, 388, 330, 105, 352)  'Cache - Gridbox
setfont CACHE%, font% 
if htt% 
 create("Tooltip",%hWnd,CACHE%,"When the program runs, machine instructions surrounding the current instruction are loaded.")
endif
whileloop 0,15
  addstring(CACHE%,space$(1)+"|"+space$(8)) ' initialize cache with spaces for settext
endwhile
hide(CACHE%)
var shcache%  = create("checkbox", %hWnd,"",450, 684, 17, 17) '  CACHE show / hide
case  htt% : create("Tooltip",%hWnd,shcache%,"Visibility of the CACHE. ")  
drawtext 400, 684,"CACHE"

'}--------------------------------------------------------------------------------------------
'{--- surface I/O system ------------------------------------------
drawtext 500, 1, " I/O-System      Input       MGA-Display      Output " 
drawtext 890, 1, "I/O-Protocol"                    ' related controls see below
usebrush 1, chipc%                        
roundrect 500, 16,877,104,20,20
fill 800,50, black%
textcolor black%, chipc% 
' --- Input ---
drawtext 525,  18,"Input:        ANSI"
drawtext 730,  18,"Output:       ANSI"
var inp%   = create("Edit", %hWnd, "", 525, 38, 38, 20) ' Input: decimal/ char
setfont inp% , font% 
if htt% 
  create("Tooltip",%hWnd,inp%,"Continuous input of a keyboard character. Input possible with Alt xxxx." \
                              + "\nThe input takes place to each clock also without clicking into the input field!"  \
                              + "\nThe binary ANSI code is stored at address hF6." \
                              + "\n" \
                              + "\nWith the command INP alternatively also input of a decimal number in the range -128 ... 127 " \
                              + "\nor enter a hexadecimal number in the form hxx or Hxx or $xx." \
                              + "\nHexadecimal digits 0..9, A..F or a..f - invalid digits are converted to 0." \
                              + "\nFor INP, the input must be acknowledged with OK." \
                              + "\nThe input is then stored in the register and at address hF6 " \
                              + "\nand displayed in the input/output log. The display there is according to the content " \
                              + "\nof the IO bits in the status register: 00 character, 01 decimal, 10 hexadecimal, 11 binary." \
                              + "\n " )
endif
hide(inp%)                                              ' show only if needed
var altinp%= create("Text", %hWnd, "", 570, 38, 35, 16) ' alternatively: number/code | code/number
setfont altinp% , font% 
var inp_ok%=create("Button",%hWnd,"OK",620, 56, 38, 20) ' Input OK
setfont inp_ok%, xfont% 
case htt% : create("Tooltip",%hWnd,inp_ok%,"Confirm the input by clicking OK.")
hide(inp_ok%)                                           ' show only if needed
var ans%   = create("Text", %hWnd, "", 612, 38, 27, 16) ' ANSI code at character input
setfont ans% , font% 
var binp%  = create("Text", %hWnd, "", 510, 59, 66, 16) ' Input binary
setfont binp% , font% 
var hinp%  = create("Text", %hWnd, "", 585, 59, 32, 16) ' Input hexadecimal
setfont hinp% , font% 
drawtext 506, 82,"  file" 
var i_ch%  = create("Edit", %hWnd, "input.hcx", 538, 80,118, 18) ' Input channel (default file)
setfont i_ch% , afont%
if htt% 
  create("Tooltip",%hWnd,i_ch%,"Data file to read in with the RCL command." \
                               + "\n" \
                               + "\nFile structure: Text file, one value per line." \
                               + "\nContent of the file - interpretation according to IO bits in the Status Register  " \
                               + "\n" \
                               + "\n 00 keyboard character  " \
                               + "\n 01 decimal numbers -128 ... 127" \
                               + "\n 10 hexadecimal numbers two digits xx   " \
                               + "\n 11 binary numbers 8 bit " \
                               + "\n" \
                               + "\nIf no data was read, the Z flag is set." \
                               + "\nIf there is too much data in the file, the program terminates at the end of RAM and sets the V flag.  " \
                               + "\nIt is also set by values that do not respect the range." \
                               + "\nIf no file name is entered, the file selection is displayed." \
                               + "\n " )
endif                             
drawtext 658, 82,"In    -"
drawtext 707, 82,"Out" 
'
' --- MGA Display  -  Micro-Graphic-Adapter 8x8, S/W "Maxipixel"  ---
var Mx%  = 664
var My%  =  20 
var Md%  =   6 
var Mxe% = Mx% + 8*Md% +1
var Mye% = My% + 8*Md% +1
roundrect (Mx%-1),(My%-1),(Mxe%+1),(Mye%+1),Md%,Md%  ' outer frame
usebrush 1, white%   
fill Mx%+4*Md% ,My%+4*Md%, black%
usepen 0,1,grey%
roundrect Mx%,My%,Mxe%,Mye%,(Md%-2),(Md% -2) 
whileloop Md% , 7*Md% , Md%                     ' Grid lines, separation of the  "Maxipixel"
  line Mx%+1,My%+&loop,Mxe%-1,My%+&loop
  line Mx%+&loop,My%+1,Mx%+&loop,Mye%-1 
endwhile
usepen 0,1,black%  ' again standard
' --- Output ---
var boutp% = create("Text", %hWnd, "", 733, 59, 66, 16) ' Output binary
setfont boutp% , font% 
var houtp% = create("Text", %hWnd, "", 805, 59, 32, 16) ' Output hexadecimal
setfont houtp% , font% 
var outp%  = create("Text", %hWnd, "", 733, 38, 44, 16) ' Output decimal signed
setfont outp% , font% 
var ansout%= create("Text", %hWnd, "", 793, 38, 27, 16) ' Output ANSI-Code
setfont ansout% , font% 
var coutp% = create("Text", %hWnd, "", 823, 38, 11, 16) ' Output character
setfont coutp% , font% 
var o_ch%  = create("Edit", %hWnd, "output.hcx", 733, 80,118, 18) ' Output channel (default file)
setfont o_ch% ,afont%
if htt% 
  create("Tooltip",%hWnd,o_ch%,"Output to data file with the STO command."\
                               + "\n" \
                               + "\nFile structure: Text file, one value per line." \
                               + "\nContent of the file - interpretation according to IO bits in the Status Register  " \
                               + "\n" \
                               + "\n 00 keyboard character  " \
                               + "\n 01 decimal numbers -128 ... 127" \
                               + "\n 10 hexadecimal numbers two digits xx   " \
                               + "\n 11 binary numbers 8 bit " \
                               + "\n" \                           
                               + "\nIf no data was written, the Z flag is set." \
                               + "\nIf no file name is entered, the file selection is displayed." \
                               + "\n " )
endif                               
' ---  Input-Output protocol ---
var IO% = create("gridbox", %hwnd, ">In;2;48;Out>;2;52;", 0, 878, 18, 127, 432)  'I/O - Gridbox
setfont IO% , spfont% 
if htt% 
  create("Tooltip",%hWnd,IO%,"In- and Output protocol" \
                               + "\ncommands INP and OUT  - display of values " \
                               + "\n" \  
                               + "\ninterpretation according to IO bits in the Status Register " \
                               + "\n" \
                               + "\n 00 keyboard character  " \
                               + "\n 01 decimal numbers -128 ... 127" \
                               + "\n 10 hexadecimal numbers two digits xx   " \
                               + "\n 11 binary numbers 8 bit (over both columns!)" \
                               + "\n                                    >Input." \
                               + "\n                                    .Output> " \
                               + "\n " )
endif                               
hide(IO%)                                                ' hide I/O protocol for now
var shio%  = create("checkbox", %hWnd,"",970, 1, 17, 17) ' for I/O protocol show / hide
case htt% : create("Tooltip",%hWnd,shio%,"Visibility of the input and output protocol. ")
var clrio% = create("Button", %hWnd,"X",980, 450, 17, 17)  ' delete I/O log
setfont clrio%, xfont%
case htt% : create("Tooltip",%hWnd,clrio%,"Delete input and output protocol without asking.")
hide(clrio%) 
'}
'{--- surface CPU -------------------------------------------------
textcolor black% , backgrdc%
drawtext 500,109,"Processor HC680               CPU - Central Processing Unit"
usebrush 1,chipc%
roundrect 500,125,877,450,20,20
fill 650, 130, black%  
'
usefont "Arial", 10,4,0,0,0                    ' small font
textcolor grey% , chipc%    '################
drawtext 846,156,               "14.10.21"     ' date stamp Build 
'                            ################
usefont "Arial", 16,6,0,0,0                    ' Set default font for the window again
' --- Register ---
textcolor black% , chipc% 
drawtext 510,126,"Data register       Shadow register"
drawtext 505,142,"D0                   00             SD0"
R%[0]  =  create("Text", %hWnd, "00000000", 520,158, 66, 16)   ' D0 Register: 00 binary
setfont R%[0], font% 
var r0val% = create("Button", %hWnd, "",    510,173, 86, 8)      ' Tooltip help button
var toolr0val% = create("Tooltip",%hWnd,r0val%, "0 = h00")         ' decimal and hexadecimal display in tooltip
S%[0]  = create("Text", %hWnd, "00000000",620,158, 66, 16)     ' SD0 Register - shadow register to D0
setfont S%[0], font% 
var SD0val% = create("Button", %hWnd, "",    610,173, 86, 8)      ' Tooltip help button
var toolSD0val% = create("Tooltip",%hWnd,SD0val%, "0 = h00")         ' decimal and hexadecimal display in tooltip
'
drawtext 505,185,"D1                   01             SD1"
R%[1]  =  create("Text", %hWnd, "00000000", 520,201, 66, 16)   ' D1 Register: 01 binary
setfont R%[1] , font% 
var r1val% = create("Button", %hWnd, "",    510,216, 86, 8)      ' Tooltip help button
var toolr1val% = create("Tooltip",%hWnd,r1val%, "0 = h00")         ' decimal and hexadecimal display in tooltip
S%[1] = create("Text", %hWnd, "00000000",620,201, 66, 16)      ' SD1 Register - shadow register to  D1
setfont S%[1], font% 
var SD1val% = create("Button", %hWnd, "",    610,216, 86, 8)      ' Tooltip help button
var toolSD1val% = create("Tooltip",%hWnd,SD1val%, "0 = h00")         ' decimal and hexadecimal display in tooltip
'
drawtext 512,234,"Address register" 

drawtext 505,248,"A0                   10             SA0"
R%[2]  =  create("Text", %hWnd, "00000000", 520,264, 66, 16)   ' A0 Register: 10 binary 
setfont R%[2], font% 
var r2val% = create("Button", %hWnd, "",    510,279, 86, 8)      ' Tooltip help button
var toolr2val% = create("Tooltip",%hWnd,r2val%, "0 = h00")         ' decimal and hexadecimal display in tooltip
S%[2]  = create("Text", %hWnd, "00000000",620,264, 66, 16)     ' SA0 Register - shadow register to A0
setfont S%[2], font% 
var SA0val% = create("Button", %hWnd, "",    610,279, 86, 8)      ' Tooltip help button
var toolSA0val% = create("Tooltip",%hWnd,SA0val%, "0 = h00")         ' decimal and hexadecimal display in tooltip
'
drawtext 505,291,"A1                   11             SA1"
R%[3]  =  create("Text", %hWnd, "00000000", 520,307, 66, 16)   ' A1 Register: 11 binary
setfont R%[3] , font%
var r3val% = create("Button", %hWnd, "",    510,322, 86, 8)      ' Tooltip help button
var toolr3val% = create("Tooltip",%hWnd,r3val%, "0 = h00")         ' decimal and hexadecimal display in tooltip
S%[3]  = create("Text", %hWnd, "00000000",620,307, 66, 16)     ' SA1 Register - shadow register to A1
setfont S%[3], font% 
var SA1val% = create("Button", %hWnd, "",    610,322, 86, 8)      ' Tooltip help button
var toolSA1val% = create("Tooltip",%hWnd,SA1val%, "0 = h00")         ' decimal and hexadecimal display in tooltip
'
drawtext 565,335,"Instruction Register - IR"
var IR% = create("Text", %hWnd, "00000000", 620,351, 66, 16)   ' Instruction Register
setfont IR%, font% 
'
var set_IC%  = create("Edit", %hWnd,"00", 581, 386, 20, 20)    ' address IC / program start address            
setfont set_IC%, font% 
case htt% : create("Tooltip",%hWnd,set_IC%,"Resetting the instruction counter/ instruction address (hexadecimal).")
'
hide (set_IC% )                    ' hide for now, only for program stop: show_set_IC ' show control with text
'
drawtext 567,370,"Instruction Counter - IC"
var IC% = create("Text", %hWnd, "00000000", 620,386, 66, 16)     ' Instruction Counter  (is then set to Startadr!)
setfont IC%, font% 
var ICval% = create("Button", %hWnd, "",    610,401, 86, 8)      ' Tooltip help button
var toolICval% = create("Tooltip",%hWnd,ICval%, "Adr 0 = h00")   ' Address, decimal, hexadecimal display in tooltip
'
drawtext 565,418,"Startadr."
drawtext 690,418,"- ST"
var ST% = create("Text", %hWnd, "00000000",620,420, 66, 16)      ' start address register - is set in event loop
setfont ST%, font% 
var STval% = create("Button", %hWnd, "",   610,435, 86, 8)       ' Tooltip help button
var toolSTval% = create("Tooltip",%hWnd,STval%, "Adr 0 = h00")   ' Address, decimal, hexadecimal display in tooltip
'
drawtext 725,335,"Status Register - SR"
usefont "Lucida Console" , 14, 8,0,0,0                           ' font like font% in text field SR Register
drawtext 755,373,"IOXY"                                          ' SR High Nibble
drawtext 788,373,"NZVC"                                          ' SR Low  Nibble: Flags
usefont "Arial", 16,6,0,0,0                                      ' again default font for the window
drawtext 788,385, "FLAG"
var SR% = create("Text", %hWnd, "00000000", 755,351, 66, 16)     ' Status Register
setfont SR%, font% 
var SRval% = create("Button", %hWnd, "",    745,366, 86, 8)      ' Tooltip help button
var IO_SRtxt$ = ""
if htt% 
  var SRhlp$ = "Status Register Bits IOXYNZVC" \
                + "\n " \
                + "\nIn- and Output bits IO  " \
                + "\n 00 keyboard character  " \
                + "\n 01 decimal numbers -128 ... 127" \
                + "\n 10 hexadecimal numbers two digits xx   " \
                + "\n 11 binary numbers 8 bit " \
                + "\n "  \
                + "\nbits XY not used by system" \
                + "\n- free available - " \
                + "\n "  \ 
                + "\nFlags " \
                + "\n N   Negative " \
                + "\n Z   Zero " \
                + "\n V   oVerflow " \
                + "\n C   Carry " \         
                + "\n "
else
  var  SRhlp$ = "00 keyboard character"+"\n "+"\nN   =  0"+"\nZ   =  0"+"\nV   =  0"+"\nC   =  0"   ' for current value in tooltip
endif 
var toolSRval% = create("Tooltip",%hWnd, SRval%, SRhlp$)         ' display in tooltip
'
drawtext 735,404,"Stack Pointer - SP"
var SP% = create("Text", %hWnd, "00000000", 755,420, 66, 16)     ' Stack Pointer, Basisadr. is set at program start!
setfont SP%, font% 
var SPval% = create("Button", %hWnd, "",    745,435, 86, 8)      ' Tooltip help button
var toolSPval% = create("Tooltip",%hWnd,SPval%, "Adr 0 = h00   (Basis after start 245 = hF5)") '  Address, decimal, hexadecimal display in tooltip

' --- Arithmetic Logic Unit -----   
drawtext 702,174,"Arithmetic Logic Unit"
line 698,191,750,191                                  ' ALU-Symbol
lineto 760,203
lineto 770,191
lineto 819,191
lineto 799,280
lineto 719,280
lineto 698,191
line 722,259,796,259 ' result bar                        ' Calculator 9 Bit:
var AL1%  = create("Text", %hWnd, "", 722, 210, 74, 15)  ' ALU storage 1 / Operand
setfont AL1% , font% 
var AL2%  = create("Text", %hWnd, "", 722, 227, 74, 15)  ' ALU storage 2 / Operand
setfont AL2% , font% 
var ALC%  = create("Text", %hWnd, "", 722, 244, 74, 15)  ' ALU storage 3 / Übertrag
setfont ALC% , font% 
var ALR%  = create("Text", %hWnd, "", 722, 261, 74, 15)  ' ALU storage 4 / Resultat
setfont ALR% , font% 
'
drawtext 730,284,"bitwise"
var alu_bitw% = create("CheckBox", %hWnd, "",782,284,16,16)
setfont alu_bitw% , font% 
case htt% : create("Tooltip",%hWnd,alu_bitw%, "Display the calculation process in the ALU bitwise." \
                                              + "\n " \
                                              + "\nDuring the bitwise representation in the ALU:" \
                                              + "\n *  no running keyboard input" \
                                              + "\n *  no mouse handling" \
                                              + "\n *  no stopping possible with start button" \
                                              + "\n " )
'
' temporary controls for temporary ALU registers for multiplication and division
var booth% = create("Button", %hWnd, chr$(187)+" Booth",804,278,68,15)
setfont booth% , sfont% 
if htt%  
  create("Tooltip",%hWnd,booth%,"--- multiplication according to Booth ---" \
                              + "\n " \
                              + "\nRegister D0 is temporarily stored in temporary ALU register A (for addition)."\
                              + "\nThe two's complement -D0 is formed and stored in the temporary register S." \
                              + "\nThe 16-bit result is calculated step by step in the bottom line. For this purpose," \
                              + "\nthe left byte is initialized with 0 and D1 is stored on the right and the auxiliary bit x is set to 0 next to it. " \
                              + "\n " \
                              + "\nSequence control takes place after the last two bits of the result line (with auxiliary bit x):" \
                              + "\n " \                              
                              + "\n>> The result line is shifted 1 bit to the right, the auxiliary bit is dropped out," \
                              + "\n      on the left, the bit identical to the bit shifted away is added as a sign extension." \
                              + "\n" \
                              + "\n00, 11           >>           only  >>  " \            
                              + "\n01         add  >>           D0 is added, then >>  " \
                              + "\n10          sub  >>          -D0 is added, then >>  " \
                              + "\n " \
                              + "\nThe left byte of the last line is copied to the top line as a subtotal." \
                              + "\n(with sign expansion)" \
                              + "\nAfter 8 steps, the 16bit result (without auxiliary bit x) is obtained in the lower double register." \
                              + "\nThe right byte (low byte) is brought to D0. " \
                              + "\nThen check for displayability in the range -128 ... 127 and set the flags." \
                              + "\n ")
endif
hide(booth%) ' hide for now
'
var ASP%  = create("Button", %hWnd, " \ DIV  ", 728, 194, 68, 15) ' Pointer: Shift << >> and bit comparison points | and ! in the dividend
setfont ASP% , spfont% 
if htt%
  create("Tooltip",%hWnd,ASP%,"--- integer division with remainder ---" \
                              + "\n " \
                              + "\nThe signs of the dividend and divisor are stored in temporary ALU memory bits (Vz)." \
                              + "\nThe two's complement is formed from the divisor D1 (temporary ALU registers: N negative, P positive). " \
                              + "\nIf the dividend in D0 is negative, its two's complement is formed first." \
                              + "\nThe division of the positive operands is realized with ALU control bits via the ALU shift registers S, D." \
                              + "\nFor this purpose, the positive dividend in the ALU is moved 'fittingly' over the positive divisor." \
                              + "\nThis is achieved by bit comparison of the bits of the operands standing on top of each other." \
                              + "\nThe difference is then formed by adding the negative devisor." \
                              + "\nThe relevant shifts and additions generate the quotient in the temporary solution register L." \
                              + "\nBased on the stored signs, the sign may now be changed (solution, remainder)." \
                              + "\n " \
                              + "\nThe control bits are shown in the upper right corner of the ALU in the following order:" \
                              + "\n  f (first loop)   t (two)   a (add) " \
                              + "\n  " \
                              + "\n  f: First total pass in bit comparison of dividend and divisor (f = 1).  " \
                              + "\n         The dividend is moved to the right into the auxiliary register D of the dividend if required." \
                              + "\n         In the shifting pointer register S, a 1 is inserted from the left." \
                              + "\n  t: In the first subsequence the bits are compared from the left (symbol | )," \
                              + "\n         possibly shifted (symbols < > ). If this means that the subsequent bits " \
                              + "\n         in the second subprocess must also be checked to determine the size (symbol : ), t = 1 is set." \
                              + "\n  a: Solution bit 1 is appended to the quotient, then addition of the negative devisor (current remainder)," \
                              + "\n         a bit from the auxiliary register D of the dividend is shifted after (symbol <- ).  "\                            
                              + "\n         This is only done if there is still a 1 in the slider pointer register S above it on the left."\
                              + "\n " \
                              + "\nThen, depending on the sign bit in Sg, a sign reversal may occur. " \
                              + "\nThe quotient is brought to D0, the remainder to SD0 (sign remainder like sign dividend)." \
                              + "\n " )
endif
var ALf%  = create("Text", %hWnd, "", 839, 180,  8, 13)  ' ALU storage Division, first pass (shift option >> at 1 over 0)
setfont ALf% , spfont% 
var ALt%  = create("Text", %hWnd, "", 847, 180,  8, 13)  ' ALU storage Division, pass second partial loop
setfont ALt% , spfont% 
var ALa%  = create("Text", %hWnd, "", 855, 180,  8, 13)  ' ALU storage Division, addition from  -abs(Divisor)
setfont ALa% , spfont%                             
var ALS%  = create("Text", %hWnd, "", 798, 195, 65, 13)  ' ALU storage for slide counter Dividend
setfont ALS% , spfont% 
var AV1%  = create("Text", %hWnd, "", 712, 210,  8, 15)  ' ALU storage / sign 1 for Division
setfont AV1% , spfont% 
var AV2%  = create("Text", %hWnd, "", 712, 227,  8, 15)  ' ALU storage / sign 2 or Division
setfont AV2% , spfont% 
'
var ALBA%  = create("Text", %hWnd, "", 798, 210, 65, 15)  ' ALU storage, multiplication according to Booth  / D0 for Addition
setfont ALBA% , font% 
var ALBS%  = create("Text", %hWnd, "", 798, 227, 65, 15)  ' ALU storage, multiplication according to Booth  / Subtraction (2's complement)
setfont ALBS% , font% 
'
var ALD%  = create("Text", %hWnd, "", 798, 210, 65, 15)  ' ALU storage Dividend for shift >> and shift <<
setfont ALD% , font% 
var ALN%  = create("Text", %hWnd, "", 798, 227, 65, 15)  ' ALU storage Divisor (summand, 2's complement)
setfont ALN% , font% 
'
var ALP%  = create("Text", %hWnd, "", 798, 244, 65, 15)  ' ALU storage positive Divisor
setfont ALP% , font% 
var ARL%  = create("Text", %hWnd, "", 798, 261, 65, 15)  ' ALU storage Result / Low-Byte from 16Bit    
setfont ARL% , font% 
var ALx%  = create("Text", %hWnd, "", 865, 261,  8, 15)  ' ALU storage Multiplication according to Booth (extra bit after result/low byte)
setfont ALx% , font% 
'  hide controls for now - only for multiplication / division 
hide(ALf%) : hide(ALt%) : hide(ALa%) : hide(ASP%) : hide(ALS%) : hide(AV1%) : hide(AV2%) 
hide(ALBA%): hide(ALBS%): hide(ALD%) : hide(ALN%) : hide(ALP%) : hide(ARL%) : hide(ALx%)      
'
' ----- insert processor image -----
if fileexists("_HC680.bmp") 
 drawpic "_HC680.bmp",786,127,-1, white%
else
 textcolor white% , chipc%
 drawtext 780, 140, "_HC680.bmp"
endif
'
'}
'{--- surface programming assembler ----------------------------  
create("GroupBox",%hWnd,"",495, 460, 510, 240) 
textcolor black% , backgrdc% 
usefont "Arial", 16,6,0,0,1         ' standard font underlined
drawtext 500,476,"assembler /programming"
usefont "Arial", 16,6,0,0,0         ' standard font for the window
drawtext 720,473,            "program"
drawtext 786,473,                     "| data:"
drawtext 680,489,"Startadr."
drawtext 742,489,            "from to"
drawtext 786,489,                     "| from to"
drawtext 714,504,"hex" 
var startadr% = create("Edit", %hWnd,"00", 690, 504, 20, 20) ' start address of the program is h00 (default)   
setfont startadr%, font%                                     
case htt% : create("Tooltip",%hWnd,startadr%,"hexadecimal start address HC680 Binary code.")
var prgvon% = create("Edit", %hWnd,"", 740, 504, 20, 20)    ' start address of the program for storage           
setfont prgvon%, font% 
case htt% : create("Tooltip",%hWnd,prgvon%,"hexadecimal start address of the binary code to store/move in the assembly file.")
var prgbis% = create("Edit", %hWnd,"", 765, 504, 20, 20)    ' end address of the program < 80 Hex for storage
setfont prgbis%, font% 
case htt% : create("Tooltip",%hWnd,prgbis%,"hexadecimal end address program - for storage/movement")
var datvon% = create("Edit", %hWnd,"", 790, 504, 20, 20)  '  address start data area from 80 hex
setfont datvon%, font% 
case htt% : create("Tooltip",%hWnd,datvon%,"hexadecimal data address start - for storage/moving")
var datbis% = create("Edit", %hWnd,"", 815, 504, 20, 20)  ' data range to address for storage
setfont datbis%, font% 
case htt% : create("Tooltip",%hWnd,datbis%,"hexadecimal data address end - for storage/movement")
'
'--- Assembler file program name, save, load, move
var progname% =  create("Edit", %hWnd,"", 835, 473, 155, 20)
setfont progname%, font% 
var prognametxt$ = ""
var prgn$ = ""                  
if htt%
  prognametxt$ = "Name of the program to save or after loading: \n "
endif 
var toolprogname% = create("Tooltip",%hWnd,progname%, prognametxt$+prgn$)
'
drawtext 877,494,"store"
var store% = create("Button", %hWnd,chr$(174),890,509, 25, 20)
setfont store%, symbolfont%  
if htt% 
  create("Tooltip",%hWnd,store%,"Store a HC680 assembler file." \
                              + "\n " \
                              + "\nThe start address is stored."\
                              + "\nFrom start address (min. 00) to end address (max. 7F) the program, " \
                              + "\nthe data from (min. 80) to (max. FF) are stored." \
                              + "\nIf no values are entered (the part) is not stored." \
                              + "\n " )
endif
drawtext 940,494,"load"  
var load% = create("Button", %hWnd,chr$(172),937,509, 25,20) 
setfont  load%, symbolfont%  
if htt%
  create("Tooltip",%hWnd,load%,"Load an HC680 assembly file into the working memory." \
                              + "\n " \
                              + "\nFaulty assembler commands are interpreted as NOP." \
                              + "\nThe colon after the command address is optional, one or two spaces are sufficient for it." \
                              + "\nAlso, the dots around the operands are optional, then put one to four separator spaces." \
                              + "\nIn the data area from address h80 only the left value or character is read." \
                              + "\nFor a better overview, the data can be set right-justified."\
                              + "\nThe colon after the data address can be omitted, up to five spaces are allowed." \
                              + "\nThe 2nd column (uniform hexadecimal) is optional. It will be recalculated." \
                              + "\nFrom column 21 the comment is read in, the semicolon in front of it is optional." \
                              + "\nPlease note the start address stored in the file." \
                              + "\n " )
endif
drawtext 935,533,"shift"
var verschieb% = create("Edit", %hWnd,"", 880, 532, 36, 17)  ' shift 
setfont verschieb%, font% 
var verstooltxt$ = ""
var umrech$      = ""  
if htt%
   ' tool text (with current value) for shift assembler in RAM
  verstooltxt$ = "  |  shift of program and/or data in memory, decimal or hexadecimal (-)hxx resp. Hxx, $xx" 
  umrech$      = " \n   - conversion is displayed in the tooltip -"
               
endif
var toolverschieb% = create("Tooltip",%hWnd,verschieb%, verstooltxt$ +umrech$)
'                            
'drawtext 896,533," " ' only in german version
'drawtext 935,533," " ' only in german version
var relocate% = create("Button", %hWnd,chr$(189),919,529,14,26) 
setfont  relocate% , symbolfont%   
if htt%
  create("Tooltip",%hWnd,relocate%,"Shift the assembly instructions and/or the data in RAM." \
                              + "\n " \
                              + "\nSpecify the offset in decimal or hexadecimal hxx with sign. "\
                              + "\nIt is shifted from the entered start to the end addresses." \
                              + "\nThe existing contents are overwritten, free lines are set to zero." \
                              + "\nThe RAM section is stored as asm_tmp.txt." \
                              + "\nThe complete RAM is saved before under asm_bak.txt." \
                              + "\n " )
endif
drawtext 500,510,"ASSEMBLER-COMMAND "
drawtext 500,530,"Adr   Op Code   Mnemonic"
var codeup% = create("Button", %hWnd, chr$(173),  658, 534, 20, 20)        
setfont codeup%, symbolfont%  
case htt% : create("Tooltip",%hWnd,codeup%,"RAM - Adr. back")
drawtext 695,530,"Op. 1        Op. 2"
var codedown% = create("Button", %hWnd, chr$(175),  658, 556, 20, 20)
setfont codedown%, symbolfont% 
case htt% : create("Tooltip",%hWnd,codedown%,"RAM - Adr. forward")
var cadr% = create("Text",%hWnd,"00", 500, 548, 18, 16)
setfont cadr%, font% 
var oc% = create("Text", %hWnd, "", 525, 548, 66, 16)  
setfont oc%, font% 
oc$ = "00000000"  'initialize
settext oc%, oc$
' --- Mnemonics ---
mn$[1] ="NOP"
mn$[2] ="CMP" 
mn$[3] ="SWD": mn$[4] ="SWM"
mn$[5] ="MUL": mn$[6] ="DIV"
mn$[7] ="PSA": mn$[8] ="POA"
mn$[9] ="JSR": mn$[10]="RET"
mn$[11]="JIN": mn$[12]="JIZ": mn$[13]="JMP"
mn$[14]="LDC": mn$[15]="## "                  '  ## only two characters + space
mn$[16]="INP": mn$[17]="OUT"
mn$[18]="PSH": mn$[19]="POP"
mn$[20]="SSR": mn$[21]="GSR"
mn$[22]="BTS": mn$[23]="SWN"
mn$[24]="SHL": mn$[25]="SHR"
mn$[26]="ROL": mn$[27]="ROR"
mn$[28]="CLR": mn$[29]="INC": mn$[30]="DEC"
mn$[31]="NOT": mn$[32]="AND": mn$[33]="OR "   ' OR only two characters + space
mn$[34]="ADD": mn$[35]="SUB"
mn$[36]="MOV"
mn$[37]="LOD"
mn$[38]="STO": mn$[39]="RCL": mn$[40]="CPY"
mn$[41]="STP" 
var mn% = create("ChoiceBox", %hWnd, 2, 600,545, 55, 650) : setfont mn%, font% ' command selection
case htt% : create("Tooltip",%hWnd,mn%,"assembler, select or enter command mnemonic")
whileloop 1, sizeof(mn$[])-1
  addstring(mn%,mn$[&loop])   ' mnemonic selection fill
endwhile
settext mn%,"NOP"
' --- Operands ---
op$[1]= ".IA."  :  op$[2]= ".+A." 
op$[3]= ".D0."  :  op$[4]= ".D1." :  op$[5]= ".A0." :  op$[6]= ".A1." 
op$[7]= ".SR."  :  op$[8]= ".SP."
op$[9]= "[D0]"  : op$[10]= "[D1]" : op$[11]= "[A0]" : op$[12]= "[A1]"
op$[13]= "0000" : op$[14]= "0001" : op$[15]= "0010" : op$[16]= "0011" 
op$[17]= "0100" : op$[18]= "0101" : op$[19]= "0110" : op$[20]= "0111" 
op$[21]= "1000" : op$[22]= "1001" : op$[23]= "1010" : op$[24]= "1011" 
op$[25]= "1100" : op$[26]= "1101" : op$[27]= "1110" : op$[28]= "1111" 
op$[29]= ".00." : op$[30]= ".01." : op$[31]= ".10." : op$[32]= ".11." 
var op1% = create("ChoiceBox", %hWnd, 2, 680,545, 60, 800) : setfont op1%, font%
var op2% = create("ChoiceBox", %hWnd, 2, 745,545, 60, 800) : setfont op2%, font%
case htt% : create("Tooltip",%hWnd,op1%,"Assembler - 1st operand  select or fill in")
case htt% : create("Tooltip",%hWnd,op2%,"Assembler - 2nd operand select or fill in")
whileloop 1, 32                 ' 2bit not in the command set - Conformity of the display
    addstring(op1%,op$[&loop])  
endwhile
whileloop 1, 32                 ' with 2bit forIO
    addstring(op2%,op$[&loop])  
endwhile
drawtext 520,564,"Flags"
var fl% = create("Text", %hWnd, "", 557, 566, 34, 16)  
setfont fl%, font% 
drawtext 810,562,"comment to the command"
var opcomm% =create("Edit", %hWnd, "", 600,579, 390, 20) : setfont opcomm%, afont% ' comment to the command
var toolopcomm% = create("Tooltip",%hWnd,opcomm%,"") ' is currently set in event loop
var opcommtxt$ = ""
case htt% : opcommtxt$ = "Enter a comment to the command - even longer than input field, will be visible in the tooltip."
whileloop 0,255
 comment$[&loop] = ";"    ' Data field also for comments on constants from line 128!
endwhile
' --- Hilfe ---
drawtext 800,661,"list of assembler commands"
var hlp%     = create("ChoiceBox", %hWnd, 0, 530,679, 460, 742) : setfont hlp%, sfont% 
' Tooltip is updated continuously!
var toolhlp% = create("Tooltip",%hWnd,hlp%,"Select the command of interest for display.")
' Fill Listbox - Overview/Help for Assembler Commands - Quick Reference Guide
  hlp$[1]  = "Mnem OP OP    - Meaning Command/Addressing -            FLAG "
  hlp$[2]  = " NOP          No OPeration                              .... "
  hlp$[3]  = " CMP          CoMPare D0, D1                            NZVC "
  hlp$[4]  = " SWD          SWap D0, D1                               .... "
  hlp$[5]  = " SWM          SWap Memory Adr(D0), Adr(D1)              .... "
  hlp$[6]  = " MUL          MULtiplication D0 <- D0*D1                NZVC "
  hlp$[7]  = " DIV          DIVision D0 <- D0\D1 Rest SD0             NZVC "
  hlp$[8]  = " PSA          PuSh All Stack <- A,D,SR Reg.             .... " 
  hlp$[9]  = " POA          POp All SR,D,A reg. <- Stack              NZVC "
  hlp$[10] = " JSR          Jump SubR. S<-IC+1,IC<-IC+A1/IC<-A0+A1+ST .... "
  hlp$[11] = " JIN +A       N=1: IC <- IC + A1 Jump If Negative       .... "
  hlp$[12] = " JIZ +A       Z=1: IC <- IC + A1 Jump If Zero           .... "
  hlp$[13] = " JMP +A            IC <- IC + A1 JuMP                   .... "   
  hlp$[14] = " RET          RETturn subroutine IC <-Stack             .... "
  hlp$[15] = " LDC Rg       LoaD Constant   reg xx <- next Byte ##    NZ.. "
  hlp$[16] = " ##  CCCC CCCC   ## Constant Byte                       .... "
  hlp$[17] = " JIN IA       N=1: IC <- A0 +A1 +ST Jump If Negative    .... " 
  hlp$[18] = " JIZ IA       Z=1: IC <- A0 +A1 +ST Jump If Zero        .... "
  hlp$[19] = " JMP IA            IC <- A0 +A1 +ST JuMP                .... "
  hlp$[20] = " JIN RG       N=1: IC <- Reg xx  Jump If Negative       .... "
  hlp$[21] = " JIZ RG       Z=1: IC <- Reg xx  Jump If Zero           .... "
  hlp$[22] = " JMP RG            IC <- Reg xx  JuMP                   .... "
  hlp$[23] = " INP RG       reg xx           <- INPut                 NZ.. "
  hlp$[24] = " OUT RG       OUTput           <- reg xx                .... "
  hlp$[25] = " PSH RG       PuSH Stack       <- reg xx                NZ.. "  
  hlp$[26] = " POP RG       POP reg xx       <- Stack                 NZ.. "
  hlp$[27] = " SSR RG       Set Shadow Register    reg xx -> Sxx      NZ.. "
  hlp$[28] = " GSR RG       Get Shadow Register    reg xx <- Sxx      NZ.. "
  hlp$[29] = " BTS RG       BitTest  reg xx with Shadow register      NZ.. "
  hlp$[30] = " SWN RG       SWap Nibble reg xx                        NZ.. "
  hlp$[31] = " SHL RG       SHift Left     reg xx                     NZ.C "
  hlp$[32] = " SHR RG       SHift Right    reg xx                     .Z.C "
  hlp$[33] = " ROL RG       ROtate Left    reg xx                     NZ.C "
  hlp$[34] = " ROR RG       ROtate Right   reg xx                     NZ.C "
  hlp$[35] = " CLR RG       CLear Register reg xx <- 0                .Z.. "
  hlp$[36] = " INC RG       INCrement      reg xx                     NZVC "
  hlp$[37] = " DEC RG       DECrement      reg xx                     NZVC "
  hlp$[38] = " NOT RG       Reg xx <- NOT reg xx  (bitwise)           NZ.. "
  hlp$[39] = " AND RG  RG   Reg yy <- reg yy  AND     reg xx          NZ.. "
  hlp$[40] = " OR  RG  RG   Reg yy <- reg yy  OR      reg xx          NZ.. "  
  hlp$[41] = " ADD RG  RG   Reg yy <- reg yy  +       reg xx          NZVC "
  hlp$[42] = " ADD RG [RG]  Reg yy <- reg yy  +   Adr(reg xx)         NZVC "
  hlp$[43] = " SUB RG  RG   Reg yy <- reg yy  -       reg xx          NZVC "
  hlp$[44] = " SUB RG [RG]  Reg yy <- reg yy  -   Adr(reg xx)         NZVC "
  hlp$[45] = " MOV[RG] RG   MOVe  Adr(reg yy)  <-     reg xx          NZ.. "
  hlp$[46] = " MOV RG [RG]  MOVe      reg yy   <- Adr(reg xx)         NZ.. "
  hlp$[47] = " MOV RG  RG   MOVe      reg yy   <-    reg xx           NZ.. "
  hlp$[48] = " MOV RG  SR   MOVe      reg yy   <-    SR               NZ.. "
  hlp$[49] = " MOV RG  SP   MOVe      reg yy   <-    SP               NZ.. "
  hlp$[50] = " MOV SR  RG   MOVe      SR       <-    reg xx           NZ.. "
  hlp$[51] = " MOV SP  RG   MOVe      SP       <-    reg xx           NZ.. "
  hlp$[52] = " MOV SR  CC   MOVe      SR       <-    CC..  (2bit IO)  .... "
  hlp$[53] = " MOV RG  IA   MOVe      reg xx   <- Adr(A0+A1+ST)       NZ.. "
  hlp$[54] = " MOV IA  RG   MOVe Adr(A0+A1+ST) <-    reg xx           NZ.. "
  hlp$[55] = " LOD RG       LOad Data reg xx  <- Adr(h80+A1+ST)       NZ.. "
  hlp$[56] = " STO (IO)     STOre file  <- Adr(h80+A1+ST) D0 byte /D1 .Z.. "
  hlp$[57] = " RCL (IO)     ReCalL Adr(h80+A1+ST)<- file  /D1 read D0 .ZV. "
  hlp$[58] = " CPY          CoPY Adr(A1)<-Adr(A0)  D0 byte via D1     .ZV. "
  hlp$[59] = " STP          StoP P. stop, flags from pre-command      vvvv "
  whileloop 1, 59
    addstring(hlp%,hlp$[&loop])    'quick reference, help to fill assembler
  endwhile
'--- Data input ---
drawtext 500,594,"DATA"
var conup%  = create("Button", %hWnd, chr$(173),  658,615, 20, 20) 
setfont conup%, symbolfont% 
case htt% : create("Tooltip",%hWnd,conup%,"RAM - Adr. back")
var condown%= create("Button", %hWnd, chr$(175),  658,637, 20, 20)
setfont condown%, symbolfont% 
case htt% : create("Tooltip",%hWnd,condown%,"RAM - Adr. forward")
drawtext 500,610,"Adr      binary"
var conadr% = create("Text",%hWnd,"80", 500,628, 18, 16) : setfont conadr%, font% 
var conbin% = create("Text",%hWnd,  "", 525,625, 66, 16) : setfont conbin%, font%
drawtext 526,640,"hex"
var conhex% = create("Text",%hWnd,  "", 550,643, 18, 16) : setfont conhex%, font%
var coninp% = create("Edit",%hWnd,  "", 600,625, 56, 20) : setfont coninp%, font%
case htt% : create("Tooltip",%hWnd,coninp%,"keyboard character or decimal number -128 ... 127 or hexadecimal number hxx (also Hxx, $xx)")
var conalt% = create("Text",%hWnd,  "", 685,628, 35, 16) : setfont conalt%, font% 
drawtext 725,608,"ANSI"
var conans% = create("Text",%hWnd,  "", 725,628, 27, 16) : setfont conans%, font% 
drawtext 810,609,"data comment"
var concomm% =create("Edit", %hWnd, "", 760,625,230, 20) : setfont concomm%, afont%
var toolconcomm% =create("Tooltip",%hWnd,concomm%,"") 'is currently set in event loop
var concommtxt$ = ""
case htt% : concommtxt$ = "Enter a comment to the constant - even longer than input field, will be visible in the tooltip."
settext conbin%, "00000000"
settext conhex%, "00"
settext coninp%, "0"
'}
'{--- surface manual, program run, breakpoints, debug, clock ---
var shorthlp% = create("Button",%hWnd,"quick guide" ,387, 1, 109, 17) 
setfont shorthlp%  , spfont% 
var shtbtxt$ = "Please note the respective tooltips," \
  + "\nquick guide in this tooltip." \
  + "\n " \
  + "\nImage of the processor: _HC680.bmp in the program folder. " \
  + "\n " \
  + "\nAdjustable in the INI file in the program folder:" \
  + "\n[RGB background] " \
  + "\nR=value" \
  + "\nG=value" \
  + "\nB=value" \
  + "\n " \
  + "\nThe simple help tooltips can be disabled in the INI file:" \
  + "\n[help tooltip]" \ 
  + "\nH=0 " \
  + "\nThe tooltips with variable content are always available." \
  + "\n " \
  + "\nPlease also take note of the reference to the HC680. " \
  + "\n "
'  
var shorthlp$ = "Quick Reference Guide:" \
            + "\n----------------------"  \
  + "\n Please note the tooltips for the essential elements.                 " \
  + "\n " \
  + "\n Create an assembler/machine program by selecting the mnemonics and operands." \
  + "\n Invalid assembler commands are converted to NOP (00000000). " \
  + "\n Store the empty RAM as assembler and open the file to recognize the structure." \
  + "\n Assembler files can be created and edited with a text editor." \
  + "\n Omissions are possible for easier notation. For details see loading tooltip." \
  + "\n Load one or more assembler sequences respecting the memory addresses." \
  + "\n Although the representation of RAM is designed for assembler instructions only up to line 127,  " \
  + "\n a machine program will be executed even beyond that!  " \
  + "\n The RAM rows starting from 128 are conceptually for data, the stack, the keyboard- and mouse buffer " \
  + "\n and the Micro-Graphic-Adapter (MGA display 8x8 'maxi' pixels)." \
  + "\n If the program runs into this area, however, the bytes are interpreted as machine commands!" \
  + "\n Likewise, data can be written and executed in the range up to line 127." \
  + "\n However, RAM rows 0 and 128 are reconstructed from the edit in the assembler area  " \
  + "\n after manipulation at program stop." \
  + "\n " \
  + "\n Start the machine program with the green start button. " \
  + "\n " \
  + "\n Do not click on the input field that appears when the program is run, see the tool tip." \
  + "\n The byte with the address hF6 serves as keyboard buffer. It is filled in every clock pulse and enables " \
  + "\n even elementary event-driven GUI programs with the Micro-Graphic-Adapter." \
  + "\n In the RAM byte hF7 the MGA status is stored: | black: 1 | row: bbb | click: 1 | column: bbb |" \
  + "\n i.e. left bit set: black, three bit: row, 1 bit: click = 1, three bit: column." \
  + "\n The content of byte hF7 is evaluated by the system in each clock cycle, the addressed pixel is set/deleted."\
  + "\n For programs that respond to keyboard and/or mouse events, experimentally determine the clock range." \
  + "\n " \
  + "\n For multiplication and division, additional ALU registers and buttons are displayed. See tooltips for more information." \
  + "\n " \
  + "\n Please also refer to the simulation documentation and the HC680 manual." \
  + "\n "
case htt% : var toolshorthlp% =create("Tooltip",%hWnd,shorthlp%, shorthlp$) 
'
textcolor  grey%, backgrdc%     ' gray font
drawtext 880,414,"https://"
drawtext 880,428,"cpusimulation.hofk.de"
textcolor black%, backgrdc%     ' standard font color 
'
create("GroupBox",%hWnd,"",387, 10,109,318) 
drawtext 400,30, "HC680"
drawtext 400,44, "binary code"
ellipse  400,70,430,100        ' start knob outer ring
usebrush 1,backgrdc%  
fill 402, 85, black%
ellipse  405,75,425,95         ' start knob
usebrush 1,richgreen%          ' knob rich green
fill 415, 85, black%
drawtext 390,100, "  execute         " 
var abr%  = create("Button",%hWnd,"X",436, 75, 17, 17) ' Operator abort: X STOP
case htt% : create("Tooltip",%hWnd,abr% ,"Cancel program immediately with x, \notherwise click yellow circle.")
setfont abr%, xfont% 
hide(abr%)
'
var bit_stp%  = create("Button",%hWnd," ... bit ... ",390, 70, 102, 45) ' cover start knob, x STOP, clock   
hide(bit_stp%)
var wait_inp%  = create("Button",%hWnd," input ... ",390, 70, 102, 45) ' cover start knob, x STOP, clock  
hide(wait_inp%)
' 
drawtext 427,125,"clock:"       ' variable clock frequency of the processor

whileloop 0,7
  line 400,142+7*&loop,405,142+7*&loop  ' symbolic lines - linear scale range
endwhile  
var takt_scroll% = Create("VScroll",%hWnd,"",405,125,14,180)
setscrollrange takt_scroll%,0,255  ' see scaling calculation
setscrollpos takt_scroll%,10       ' 
if htt%  
  create("Tooltip",%hWnd,takt_scroll%, " --- frequency selection ---"  \
                                      + "\n " \
                                      + "\n Single step (above), then clock frequency from 0.1 to 255Hz, then unbraked. " \
                                      + "\n " \
                                      + "\n- The frequency can also be changed during the program run." \
                                      + "\n   In the single step the breakpoints are editable." \
                                      + "\n   If the frequency is higher, click quickly one after the other to reach stop " \
                                      + "\n   or to change 'bitwise'. Possibly reduce the frequency considerably beforehand." \
                                      + "\n   A stop can always be reached by clicking on the slider in the RAM scroll bar." \
                                      + "\n " \
                                      + "\n- from 10Hz nonlinear scale." \
                                      + "\n " \
                                      + "\n- Above 255Hz unbraked: " \  
                                      + "\n   * No running keyboard input, no mouse handling - 'full' speed." \
                                      + "\n   * No detailed representations of the process." \
                                      + "\n " )
endif
var takthz%=create("Text",%hWnd,"", 422,145, 42, 16) : setfont takthz%, font% 
drawtext 465,145,"Hz"
var nextstep%  = create("Button",%hWnd,"go on", 420, 160, 60, 22)
setfont nextstep%, font% 
'
drawtext 423,185,"Breakpoints"
var breakpt1%  = create("Edit",%hWnd,"", 440, 202, 20, 20)
setfont breakpt1%, font% 
if htt% 
  create("Tooltip",%hWnd,breakpt1%,"Breakpoint 1" \
                                      + "\nHexadecimal address, a single step." \
                                      + "\nNot considered for clock >255Hz." )
endif
var breakpt2%  = create("Edit",%hWnd,"", 440, 224, 20, 20)
setfont breakpt2%, font% 
if htt% 
  create("Tooltip",%hWnd,breakpt2%,"Breakpoint 2" \
                                     + "\nHexadecimal address, a single step." \
                                      + "\nNot considered for clock >255Hz." )
endif
var breakpt3%  = create("Edit",%hWnd,"7F", 440, 246, 20, 20)
setfont breakpt3%, font% 
if htt% 
  create("Tooltip",%hWnd,breakpt3%,"Breakpoint 3   (Default RAM row   127)" \
                                      + "\nHexadecimal address, a single step." \
                                      + "\nNot considered for clock >255Hz." )
endif
drawtext 440,266,"hex"
'
var debug%  = create("Checkbox",%hWnd,"", 432, 290, 17, 17)
drawtext 450,290,"debug"
if htt% 
  create("Tooltip",%hWnd,debug%,"Write to debug file. " \
                                      + "\n " \
                                      + "\nIC, binary code, assembler, SR/flags, all registers," \
                                      + "\nSP with content, keyboard byte and MGA pixel line are recorded." \
                                      + "\n " \
                                      + "\nCan be switched on and off during the program run." \
                                      + "\nNot considered for clock >255Hz." \
                                      + "\n " )
endif
var debugfn%  = create("Edit",%hWnd,"debug.txt", 389, 308, 104, 18)
setfont debugfn%, afont% 
if htt% 
  create("Tooltip",%hWnd,debugfn%,"Enter debug file name. " \
                                      + "\nIf no file name is entered, the file selection is displayed." \
                                      + "\n " \
                                      + "\n --- ATTENTION --- " \
                                      + "\nThe file is always overwritten with the header! (Even if debug is not selected)." \
                                      + "\nAt clock >255Hz there is no entry in the file." \
                                      + "\n " )
endif
'
mgapix$  = "0000m000"                  ' Initialize MGA address pixel/status (m: mouse bit, not checked) 
mga_display                            ' Initialize MGA display (fill mga$[ ])
' 
usefont "Wingdings", 22,20,0,0,0   
drawtext 620,450, Chr$(184)            ' Wingdings clock
usefont "Arial", 16,6,0,0,0            ' Default font for the window
var clock% = create("TEXT",%hWnd,"",648,455,129,13) 
setfont clock%, spfont% 
t0% = 65536                            ' Base value CPU time 2^16 ...
settext clock%,right$(bin$(t0%),16)    ' ... only right 16 bits with 0 are displayed
t%=t0%                                 ' Initialize CPU time
dec t%                                 ' since in clock_pulse immediately inc i%
clock_pulse(1)                         ' Clock with factor 1 (important for single step/ normal clock 1Hz)
'
'}
'{>>> Event loop  >>>
' <<<<<<<<<<<<<<<<<<<<<<<<<
repeat     
  '-------   Reading from ChoiceBox and Edit  ------
  mn$                 = gettext$(mn%)              ' Mnemonic    
  case mn$ = "" : mn$ = "NOP" 
  op1$                = gettext$(op1%)             ' Operand 1
  op2$                = gettext$(op2%)             ' Operand 2
  opcomm$             = trim$(gettext$(opcomm%))   ' Comment on command
  coninp$             = gettext$(coninp%)          ' Constant  
  concomm$            = trim$(gettext$(concomm%))  ' Comment on constant
  '------- Tooltip current program name -------
  prgn$ = gettext$(progname%)
  settext toolprogname%, %hwnd, progname%, prognametxt$ + " * " + prgn$ + " * "
  '-------  Tooltip current to comment (full length readable!)  -------
  tooltip_comment                           
  '--------   Code commands/ store in RAM --------
  assembler_to_binary_code                   
  '--------   Analyze constants/ store in RAM --------
  define_constant                    
  '-------   Insert start address in ST and IC  ------
  sta$ = gettext$(startadr%)                       ' start address hexadecimal
  sta% = val("$"+sta$)                             ' start address decimal
  settext IC%, hex2_to_bin8(sta$)                  ' binary insert IC
  settext ST%, hex2_to_bin8(sta$)                  ' binary insert StIC (Start Instruction Counter)
   '--- Tooltips aktualisieren ---
  settext toolICval%, %hwnd, ICval%, "Adr  "+str$(val("%"+gettext$(IC%))) + " = h"+ bin8_to_hex2(gettext$(IC%)) 
  settext toolSTval%, %hwnd, STval%, "Adr  "+str$(val("%"+gettext$(ST%))) + " = h"+ bin8_to_hex2(gettext$(ST%)) 
  '
  settimer 200  ' 0.2 seconds ...
  '
  waitinput                                          ' <---  event request 
  '
  if %wmTimer  ' query timer
    ' NOTHING                                ... wait 0.2 seconds, otherwise the display flickers
  endif
 
  '-----   8 bit binary code/machine program start   -----
  x% = 415 - %mousex
  y% =  85 - %mousey
  if  (x%*x% + y%*y% < 100) and (%mousekey = 1) ' click on round knob
    coderow% = 0                                ' set to beginning
    restore_instruction                         ' set Mnemonic Op1,2 and comment in input edits
    conrow%  = 128                              ' set to beginning
    restore_const                               ' set constant (input) with comment
   '
    run_binary_code           ' <--- start machine program (binary code HC680)
   '===============
    selectstring(RAM%, -1, "00000000")          ' marking RAM Adr 0
   '
  endif
  '---  clock - single step ---
   get_pulse                     '  determine and display current clock rate (non-linear scale)
  ' ------   buttons programming assembler  ------
  ' command/mnemonic assembler
  if clicked(codeup%)             ' program line up
    if  coderow% > 0              ' with boundary check command line >= 0 
      dec coderow% 
      selectstring(RAM%, -1, d255_to_bin8(coderow%)) ' mark current command line in RAM
      restore_instruction         ' set Mnemonic Op1,2 and comment in input edits
    endif  
  endif
  if clicked(codedown%)           ' program line down
    if  coderow% < 127            ' with boundary check command line < h80
      inc coderow% 
      selectstring(RAM%, -1, d255_to_bin8(coderow%)) ' mark current command line in RAM
      restore_instruction         ' set Mnemonic Op1,2 and comment in input edits
    endif  
  endif 
  '  Konstante Daten
  if clicked(conup%)             ' constant line up
    if  conrow% > 128            ' with boundary check
      dec conrow%
      selectstring(RAM%, -1, d255_to_bin8(conrow%)) ' mark current command line in RAM
      restore_const              ' set constant (input) with comment
    endif  
  endif  
  if clicked(condown%)
    if  conrow% < 255            ' with boundary check
      inc conrow%
      selectstring(RAM%, -1, d255_to_bin8(conrow%)) ' mark current command line in RAM
      restore_const              ' set constant (input) with comment
    endif  
  endif    
  '------  clicked into RAM  ----
  if clicked(RAM%)            
    ramrow% = getcursel(RAM%)  ' (line cursor)
    restore_from_RAM           ' restore command or constant from RAM with comment
    setfocus(%hWnd)
  endif   
  ' ------   delete RAM  ------ 
  if clicked(xram%) 
    RAM_delete                 ' delete RAM, comments and current flags
  endif
  if clicked(xflag%) 
    flag_delete                 ' delete current flags
  endif
  ' ------   CACHE show, hide  ------ 
   if getcheck(shcache%) = 0 
    hide(CACHE%) 
  endif
  if getcheck(shcache%) = 1 
    show(CACHE%)
  endif
  ' ---   show, hide, delete input-output protocol  ---
  if getcheck(shio%) = 0 
    hide(IO%) 
    hide(clrio%)
    textcolor backgrdc% , backgrdc% 
    drawtext 880, 450, "I/O-Prot. delete"
  endif
  if getcheck(shio%) = 1 
    show(IO%)
    show(clrio%)
    textcolor black%, backgrdc% 
    drawtext 880, 450, "I/O-Prot. delete"
  endif
  if clicked(clrio%)  
    clearlist IO%                          
  endif 
   ' --- shift value ---
  rel_value                    ' focus on shift value assembler - being processed
  '-------------   assembler : load store shift    --------------- 
  case  clicked(load%)       : load_asm
  case  clicked(store%)      : store_asm
  case  clicked(relocate%)   : reloc_asm
  ' ------------  quick reference and help for assembler commands  ----------------
  if clicked(shorthlp%)
    messagebox(shtbtxt$ , "NOTICE",48)
  endif
  if clicked(hlp%)
    settext toolhlp%, %hwnd, hlp%, " Command: "+ gettext$(hlp%) +"  "
  endif
  ' 
  taste% = %key                 ' pressed key (scancode)
until taste% = 27               ' exit simulation program with ESC key
'} //end event loop
' <<<<<<<<<<<<<<<<<<<<<<<<< 
'{--- cleanup ------------------------------------------------
killtimer                       ' Release timer
deleteobject sfont%             ' Release object memory
deleteobject font%
deleteobject spfont% 
deleteobject xfont%  
deleteobject afont%
deleteobject symbolfont%
endproc     ' End of main procedure main.
'} 
' --- clock / event handling ------
proc get_pulse    ' determine current clock (non-linear scale)
  takt! = getscrollpos(takt_scroll%)  ' scrollrange - still without scale calculation
  if takt! = 0                        ' scale start  
     takt! = 2 ' otherwise Div by 0 at STEP and bitwise in clock_pulse, so 0.5 sec pause
     settext takthz%,"Step"
     nospeed% = 1                     ' single step
     afterstep% = 1                   ' memorize for recovery status start knob
  else  
    if takt!< 101
      takt!=takt!/10                       ' scale calculation up to 10Hz linear
    else
      takt!=10+(takt!-98)*(takt!-98)/100   ' scale calculation from 10Hz quadratic
    endif 
    if takt!< 256
      set("Decimals",1)
      settext takthz%, str$(takt!)
      set("Decimals",0)
    else
      settext takthz%, "Speed"
    endif
    nospeed% = 0                      ' variable clock  
    halt%    = 0                      ' reset after single step! 
  endif
endproc
proc clock_pulse  ' clock/EVENT HANDLING: stop/goon/singlestep/keyboard/mouse 
 parameters faktor%
  var btmp$ = ""                      ' temporary, not global, because procedure is used in command execution
  get_pulse                           ' get current pulse (non-linear scale)
  '                                                 
  if (takt! < 256)  or (stop% = 1)    ' only with clock < 256Hz
    '
    if (fullspeed% = 1) and (stop% = 0)  ' in case of flying change from unbraked to smaller clock pulse
      usebrush   1, grey%                ' Knob gray
      fill 415, 85, black%
      textcolor darkred%, backgrdc%      ' dark red font
      drawtext 390,100, "wieder anhalten   "
      show(AL1%)                         ' show ALU
      show(AL2%)
      show(ALC%)
      show(ALR%)
      show(alu_bitw%)                    ' show ALU bitwise checkbox
      show(breakpt1%)                    ' show breakpoints checkbox
      show(breakpt2%)
      show(breakpt3%)
      show(debug%)                       ' show debugging check box 
      show(debugfn%)                     ' display filename debug 
      show(CACHE%)                       ' display CACHE
      show(opcomm%)                      ' display command comment
      fullspeed% = 0
    endif
    '
    if getcheck(shio%) = 1               ' show/hide I/O protocol
      show(IO%) 
    else
      hide(IO%) 
    endif
    '
    break1$ = gettext$(breakpt1%)          ' determine breakpoint 1
    break2$ = gettext$(breakpt2%)          ' determine breakpoint 2
    break3$ = gettext$(breakpt3%)          ' determine breakpoint 3
    breakp$ = bin8_to_hex2(gettext$(IC%))  ' IC hexadecimal
    if (break1$ = breakp$)  or ( break2$ = breakp$) or ( break3$ = breakp$) ' breakpoints -> one single step
      break123% = 1
      nospeed%  = 1 
    endif 
    '
    if (takt! < 1.1) or (nospeed% = 1)     ' help to assembler with small clock useful
      show(hlp%)                           
    else
      hide(hlp%)
    endif
    '
    if nospeed% = 1
      show(nextstep%) 
      ms% = 10                            ' a very small amount of time for settimer (important when starting in single step)
    else 
      hide(nextstep%)                     ' hide single step  [go on]
    endif 
    '
    if nospeed% = 0
      ms% = 10000 \(faktor%*10*takt!)     ' variable clock timer in milliseconds
      if afterstep% = 1
        hide(nextstep%) 
        usebrush 1, grey%                 ' knob  gray
        fill 415,85, black%
        textcolor darkred%, backgrdc%     ' dark red font
        drawtext 390,100, "halt again        "
        afterstep% = 0
      endif
    endif  
    '
    setfocus(%hwnd)                      ' for running keyboard query
    settimer ms%                         ' set clock frequency (in miliseconds) 
    '=======================================
    repeat        ' >>>>>>  event loop stop/continue/single step and MGA display >>>>>>>
      '-------                              (outer event loop)
      waitinput     
      '-------
      '
      ' running keyboard input
      if  (%key>5) and (%key<>13) and (%key<>255)  ' Keyboard pressed - no code for an event ...
        key$ = chr$(%key)    
        if key$<>""
          settext inp% , key$                         ' ... insert character in input edit
          btmp$ = d255_to_bin8(%key)
          if %key > 127
           settext altinp%, str$(bin8_to_dez(btmp$)) ' display value of the character
          else
           settext altinp%, ""
          endif  
          settext binp% ,  btmp$                     ' show binary
          settext hinp%, "h" + bin8_to_hex2(btmp$)   ' show hexadecimal
          settext ans% , str$(%key)                  ' show ANSI 
          settext RAM%, 246, 2, btmp$                ' RAM Adr 246 = hF6  insert binary ...
          settext RAM%, 246, 3, key$  + "    h" + bin8_to_hex2(btmp$)  ' ... insert character and value hexadecimal 
        endif 
      endif
      ' events to the MGA Display 
      mk$    = "0"           '  default: no mouse button was pressed (status)
      x%     = %mousex
      y%     = %mousey
      mk%    = %mousekey   
      if (x%>Mx%) and (x%<Mxe%) and (y%>My%) and (y%<Mye%) and (mk%>0)  ' mouse click in the MGA display
        mk$  = "1"        ' a mouse button was pressed (status)
        ip%  = (y%-My%)\Md% +1                ' MGA row    (No. 1 bis 8)
        jp%  = (x%-Mx%)\Md% +1                ' MGA column (No. 1 bis 8)
        click_mga
      endif  
      refresh_mga        ' refresh MGA
      '
      ' round knob: x%, y% already determined
      if (  ((415-x%)*(415-x%)+(85-y%)*(85-y%) < 100) and (mk%=1) and (halt%=0)  ) or (nospeed%=1) or (stop%=1)  
        '
        halt% = 1    ' reset, see loop abort possible actions
        '
        if nospeed% = 1                     ' in single step  
          usebrush 1 , backgrdc%            ' knob like ring - "hidden
          fill 415, 85, black%
          textcolor black% , backgrdc%
          drawtext 390,100,"   Step ...           "     
        else                                ' not in single step  
          usebrush 1,yellow%                ' knob yellow
          fill 415,85,black% 
          textcolor darkgreen%, backgrdc%   ' dark green font
          drawtext 390,100," run further      "
        endif 
        '
        if stop% = 1
          usebrush 1,red%                   ' knob red
          fill 415,85, black%
          drawtext 390,100, " stopped            "
          sleep 2000                        ' delayed display [x] STOP and further
          usebrush 1,yellow%                ' knob yellow
          fill 415,85,black%
          textcolor darkgreen%, backgrdc%   ' dark green font
          drawtext 390,100," run further      "
          stop% = 0                         ' reset, if further execution
        endif
        '
        show(abr%)
        textcolor darkred%, backgrdc%       ' dark red font
        drawtext 456, 77,"STOP"
        hide(inp%)  
        show_set_IC                                    ' show to reset IC if necessary, "manual" command sequence
        settext set_IC%, bin8_to_hex2(gettext$(IC%))   ' insert current value in edit as template
        '-----------------------------------------------
        repeat      ' inner event loop
          '........
          waitinput      ' EVENT QUERY for possible actions:  X STOP program / run further / one command further
          '........
          '
          settext IC%, hex2_to_bin8(gettext$(set_IC%)) '  set IC with possibly changed value
          '--- refresh tooltip decimal, hexadecimal ---
          settext toolICval%, %hwnd, ICval%,"Adr  "+str$(val("%"+gettext$(IC%))) + " = h"+ bin8_to_hex2(gettext$(IC%)) 
          '
          if nospeed% = 0     ' not in single step
            x% = 415 - %mousex
            y% =  85 - %mousey
            case (x%*x% + y%*y% < 100) and (%mousekey = 1) : halt% = 0   'run further
          endif
          '
          if clicked(abr%) 
            break% = 1        ' Operator abort: X STOP
            nospeed% = 0      ' no longer a single step   - order to ' run further  - IMPORTANT -
          endif 
          '
          case clicked(nextstep%)  : onestep% = 1   ' one command forward
          '
        until  (halt% = 0) or (break% = 1) or (onestep% = 1)   ' ... until action selected
        '----------------------------------------------------
        hide_set_IC
        show(inp%)
        hide(abr%)
        textcolor backgrdc%, backgrdc%
        drawtext 456, 77,"STOP"               ' make STOP invisible with background color
        '
        if (nospeed% = 0)
          usebrush 1,grey%                    ' knob gray
          fill 415,85,black%
          textcolor darkred%, backgrdc%       ' dark red font
          drawtext 390,100, "halt  again     "
        endif 
        '
      endif
    until (halt% = 0) or (break% = 1)  or (onestep% = 1)  ' <<<<<<<<<<<<<<  until stop/continue/single step <<<<<<<<<<<<<<<<
    '===================================================== 
     if nospeed% = 0      ' use set clock pulse
       timeover% = 0
       repeat
         case  %wmTimer   : timeover% = 1
       until timeover%  
     endif
     if nospeed% = 1      ' at single step after [go on]
       timeover% = 0
       settimer 200         
       repeat 
         case  %wmTimer   : timeover% = 1 
       until  (timeover%  = 1) and (onestep% = 1)  
      onestep% = 0                    ' reset
     endif
     if break123% = 1     ' after breakpoint
       break123% = 0
       nospeed%  = 0 
       hide(nextstep%) 
       usebrush 1,grey%                    ' knob gray
       fill 415,85,black%
       textcolor darkred%, backgrdc%       ' dark red font
       drawtext 390,100, "halt   again     "
     endif
  else ' at clock > 255Hz unbraked
    if fullspeed% = 0   ' at change clock above 255Hz
      hide(AL1%)        ' hide ALU
      hide(AL2%)
      hide(ALC%)
      hide(ALR%)
      hide(alu_bitw%)   ' hide ALU bitwise checkbox
      hide(breakpt1%)   ' hide breakpoints check box
      hide(breakpt2%)
      hide(breakpt3%)
      hide(debug%)      ' hide debugging check box
      hide(debugfn%)    ' hide filename debug
      hide(CACHE%)      ' hide CACHE
      hide(opcomm%)
      hide(hlp%)        ' hide assembler help (only with small clock)
    endif  
    if afterstep% = 1 
      hide(nextstep%) 
      afterstep% = 0
    endif  
    usebrush 1, backgrdc%                ' Knob like ring - "hidden"
    fill 415,85,black%
    textcolor darkgreen%, backgrdc%      ' dark green font
    drawtext 390,100, "Takt > 255        "  
    fullspeed% = 1
  endif // clock pulse < 255
  '
  '------  clock - CPU-time ------
  set_clock  
  '-------------------------------
endproc
proc bit_pulse    ' clock pulse bitwise 
 parameters faktor% 
  show(bit_stp%)
  get_pulse                           ' determine current clock (non-linear scale)
  if nospeed%  = 0
    hide(nextstep%)                     ' hide single step [go on]
    ms% = 10000 \(faktor%*10*takt!)     ' variable clock timer in milliseconds
  else //    = 1                     
    show(nextstep%) 
    ms% = 10          ' a very small amount of time for settimer (important when starting in single step)
  endif 
  settimer ms%                         ' set clock frequency (in miliseconds)   
  timeover% = 0
  repeat          ' >>>>>> event loop  >>>>>>>         
    if nospeed%  = 0
      waitinput 
      case  %wmTimer   : timeover% = 1 
    else //    = 1 
      waitinput 
      case clicked(nextstep%)  : onestep% = 1   ' one command further
    endif  
  until timeover% or onestep%   ' <<<<<<<<<<<<<<<
  '
  if nospeed% = 1      ' for single step after [go on]
     timeover% = 0
     settimer 200         
     repeat 
       case  %wmTimer   : timeover% = 1 
     until  timeover% and onestep%   
    onestep% = 0                    ' reset
  endif
  ' 
  hide(bit_stp%)
endproc
proc set_clock    ' set CPU time
  if t% = 131072                       ' Overflow at 2^17 ...  
    t% = t0%                           ' t0% = 65536 (base value CPU time 2^16 --> right 16 only zeros)
  else 
    inc t% ' increment CPU time
  endif 
  settext clock%,right$(bin$(t%) ,16)   ' Set 16 bit CPU time
endproc
'{--- display/ clean up/ control ----
proc show                             ' show control
  ShowWindow(&(1), 1)
endproc
proc hide                             ' hide control
  ShowWindow(&(1), 0)
endproc
proc hide_assembler_controls          ' hide controls for assembler programming 
  hide(startadr%) ' hide controls 
  hide(prgvon%)                  
  hide(prgbis%)
  hide(datvon%)
  hide(datbis%)
  hide(verschieb%) 
  hide(cadr%)                  
  hide(oc%)
  hide(mn%)
  hide(op1%)
  hide(op2%)
  hide(codeup%)
  hide(codedown%)
  hide(fl%)
  hide(conadr%)
  hide(conbin%)
  hide(conhex%)
  hide(coninp%)
  hide(conup%)
  hide(condown%)
  hide(conalt%)
  hide(conans%)
  hide(concomm%)
  hide(hlp%)    
  hide(load%)
  hide(store%)
  hide(relocate%)  
endproc
proc show_assembler_controls          ' Show controls for assembler programming
  show(startadr%) ' show controls 
  show(prgvon%)                  
  show(prgbis%)
  show(datvon%)
  show(datbis%)
  show(verschieb%) 
  show(cadr%)                 
  show(oc%)
  show(mn%)
  show(op1%)
  show(op2%)
  show(codeup%)
  show(codedown%)
  show(fl%)
  show(conadr%)
  show(conbin%)
  show(conhex%)
  show(coninp%)
  show(conup%)
  show(condown%)  
  show(conalt%)
  show(conans%)
  show(opcomm%)
  show(concomm%)
  show(hlp%)
  show(load%)  
  show(store%)
  show(relocate%)
endproc
proc clr_hide12                       ' Operands edits 1 and 2 delete, hide
  op1$="" 
  hide(op1%)
  op2$="" 
  hide(op2%)
endproc
proc RAM_delete                       ' delete RAM, comments and current flags with request
    textcolor darkred%, backgrdc%   ' dark red font
    drawtext 50, 684,"delete................."
    drawtext 390,100, " will be deleted  "
    usebrush 1 , backgrdc%          ' knob like ring - "hidden"
    fill 415, 85, black%
    msg% = messagebox("Are you really sure?\n  \nDid you store the program? \n "  \
                      + "\nDo you really want to delete the 256Byte RAM (memory/program/data)"                \
                      + "\nand the last flags and comments completely?","   CAUTION! ",276)
    if msg% = 6  ' Message return ok/yes: 6 
      row% = 0 
      repeat
        settext RAM%, row%, 2,"00000000" 
        if row% < 128
          settext RAM%, row%, 3,"NOP"
        else  
          settext RAM%, row%, 3,"0    h00" ' decimal: sign, 4 digits / 1 space  / hexadec. two digits
        endif  
        case row% < 245 : settext RAM%, row%, 4,"    "       '  4 spaces up to before SP base address
        comment$[row%] = ";"
        inc row%
      until row% = 256 
    endif
    textcolor black%, backgrdc%
    drawtext 50, 684,"delete RAM/Flags "
    drawtext 390,100, "  execute           "
    usebrush 1,richgreen%                 ' knob rich green
    fill 415, 85, black%
    coderow% =   0
    restore_instruction                   ' Set Mnemonic Op1,2 and comment in input edits
    conrow%  = 128
    restore_const                         ' Set constant (input) with comment
endproc  ' 
proc flag_delete                      ' delete current flags without request      
  row% = 0 
  repeat
   settext RAM%, row%, 4,"    "         '  4 spaces
   inc row%
  until row% = 127 
endproc
'}
'{--- flags---------------------------
proc flags_b_res_N_Z_0_0              ' determine flags N$ and Z$ from result in b_res$, V$=0 C$=0     
  N$ = left$(b_res$,1)    ' left bit sign   
  if b_res$ = "00000000"        
    Z$= "1"
  else
    Z$ = "0"
  endif   
  V$ = "0"
  C$ = "0"   
  settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$  ' Set status register with flags 
endproc
proc flags_0_0_0_0                    ' set all flags to zero
  N$ = "0" 
  Z$ = "0" 
  V$ = "0" 
  C$ = "0" 
  settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$  ' set status register with flags   
endproc
proc flags_latest                     ' show last set flags after command execution behind assembler
  case N$ = "1" :  N_$ = "N"
  case N$ = "0" :  N_$ = " "
  case Z$ = "1" :  Z_$ = "Z"
  case Z$ = "0" :  Z_$ = " "
  case V$ = "1" :  V_$ = "V"
  case V$ = "0" :  V_$ = " "
  case C$ = "1" :  C_$ = "C"
  case C$ = "0" :  C_$ = " "
  settext RAM%,  ic_dez_fl% , 4, N_$+Z_$+V_$+C_$     ' show set flags after command execution
endproc  
'}
'{--- help tooltip ------------------
proc tooltip_comment                  ' tooltip current to comment (full length readable!)
  if len(trim$(opcomm$)) = 0
    settext toolopcomm%, %hwnd, opcomm%, opcommtxt$ 
  else 
    settext toolopcomm%, %hwnd, opcomm%, "; "+opcomm$
  endif 
  if len(trim$(concomm$)) = 0
    settext toolconcomm%, %hwnd,concomm%, concommtxt$
  else 
    settext toolconcomm%, %hwnd, concomm%, "; "+concomm$
  endif 
endproc
proc register_tooltip                 ' update tooltips decimal and hexadecimal
  ' dezimale und hexadezimale Anzeige der Register im Tooltip 
  settext toolr0val% , %hwnd, r0val%, str$(bin8_to_dez(gettext$(R%[0]))) + " = h"+bin8_to_hex2(gettext$(R%[0]))
  settext toolr1val% , %hwnd, r1val%, str$(bin8_to_dez(gettext$(R%[1]))) + " = h"+bin8_to_hex2(gettext$(R%[1]))
  settext toolr2val% , %hwnd, r2val%, str$(bin8_to_dez(gettext$(R%[2]))) + " = h"+bin8_to_hex2(gettext$(R%[2]))
  settext toolr3val% , %hwnd, r3val%, str$(bin8_to_dez(gettext$(R%[3]))) + " = h"+bin8_to_hex2(gettext$(R%[3]))
  ' 
  settext toolSD0val%, %hwnd, SD0val%, str$(bin8_to_dez(gettext$(S%[0]))) + " = h"+bin8_to_hex2(gettext$(S%[0])) 
  settext toolSD1val%, %hwnd, SD1val%, str$(bin8_to_dez(gettext$(S%[1]))) + " = h"+bin8_to_hex2(gettext$(S%[1])) 
  settext toolSA0val%, %hwnd, SA0val%, str$(bin8_to_dez(gettext$(S%[2]))) + " = h"+bin8_to_hex2(gettext$(S%[2])) 
  settext toolSA1val%, %hwnd, SA1val%, str$(bin8_to_dez(gettext$(S%[3]))) + " = h"+bin8_to_hex2(gettext$(S%[3])) 
  ' show address decimal and hxadecimal in tooltip 
  settext toolICval%,  %hwnd, ICval%,"Adr  "+str$(val("%"+gettext$(IC%)))+ " = h"+bin8_to_hex2(gettext$(IC%))
  settext toolSPval%,  %hwnd, SPval%,"Adr  "+str$(val("%"+gettext$(SP%)))+ " = h"+bin8_to_hex2(gettext$(SP%))
  ' IO bits and flags 
  IO_SR$ = left$(gettext$(SR%),2)         ' type data IO, left two bits in SR
  select IO_SR$     '  type of storage: 
    caseof "00" 
      IO_SRtxt$ = "00 keyboard character" 
    caseof "01" 
      IO_SRtxt$ = "01 decimal -128..127" 
    caseof "10"
      IO_SRtxt$ = "10 hexadecimal xx" 
    caseof "11" 
      IO_SRtxt$ = "11 binary"
  endselect 
  XY_SR$ = mid$(gettext$(SR%),3,2) + " bits XY "
  settext toolSRval%,  %hwnd, SRval%,  IO_SRtxt$+"\n"+XY_SR$+"\nN   = "+N$+"\nZ   = "+Z$+"\nV   = "+V$+"\nC   = "+C$
endproc
'}
'{--- input output system -------------
proc input_system                     ' input system - user input during program run  
  show(IO%)                     ' show input-output protocol 
  show(wait_inp%)               ' cover start knob 
  setcheck shio%, 1
  setfocus(inp%)  
  repeat   
    inp$  = gettext$(inp%)      ' input decimal number -128 to 127 or hexadecimal number or keyboard character
    if inp$ = ""
      hide(inp_ok%)
      binp$ = ""                    ' "" do not automatically convert to 00000000 
      settext altinp%,""
      settext ans%,""
    else  
      ansi%   = ord(inp$)           ' ANSI code first character      
      if ( (ansi%>47) and (ansi%<58) ) or ( (ansi%=45) and (len(inp$)>1) ) ' decimal digit or minus sign at the beginning 
        inpval% = val(inp$)             ' decimal value of the input
        binp$ = dez_to_bin8(inpval%)    ' Convert number to binary (negative: two's complement)
        if (inpval% > -129) and (inpval% < 128) 
          if inpval% < 0 
            settext altinp%, str$( val("%"+ dez_to_bin8(inpval%)) )  ' alternative representation of the input character/number
          else
            settext altinp%,""
          endif  
          settext ans%, chr$(inpval%) ' display character
          show(inp_ok%)
        else                  ' invalid decimal number:     < -128   oder   > 127           -> OVERFLOW
          hide(inp_ok%)
          binp$ = "OVERFLOW"
          settext altinp%,""
          settext ans%,""
        endif // decimal
      elseif ( (ansi%=36) or (ansi%=72) or (ansi%=104) ) and (len(inp$)=3)  ' $ or H or h at the beginning: hexadecimal number
         binp$ = hex2_to_bin8(mid$(inp$,2,2))      ' hexadecimal number to binary number  
         inpval% = val("%"+ binp$)                 ' corrected input value (letter above F, f to 0)
         settext altinp%,str$(inpval%)
         settext ans%, chr$(inpval%)               ' display character   
         show(inp_ok%)
      else                                    ' input of a keyboard character
        if len(inp$)=1              
          binp$ = d255_to_bin8(ansi%)                       ' ANSI code of the character binary
          if ansi% > 127
            settext altinp%, str$(bin8_to_dez(binp$)) ' display value of the character  
          else
            settext altinp%,""
          endif
          settext ans%, str$(ansi%)                 ' display ANSI code of the character decimally
          show(inp_ok%)
        else
          hide(inp_ok%) 
          binp$ = "ERROR"     ' incorrect input: several characters, but no valid decimal number -> ERROR
          hide(inp_ok%) 
          settext altinp%,""
          settext ans%,""
        endif    
      endif // keyboard character
    endif // non-empty input
    settext binp%, binp$                            ' display input in binary 
    if (binp$="") or (binp$="OVERFLOW") or (binp$="ERROR") ' invalid, no display
      settext hinp%, ""
    else  
      hinp$ = bin8_to_hex2(binp$)
      settext hinp%, "h" + hinp$        ' display input hexadecimal
    endif
    waitinput  
  until clicked(inp_ok%) 
  '
  'IO_SR$                               ' type data IO left 2 bit SR 
  select IO_SR$
      caseof "00"                       ' --- keyboard character --- 
        addstring(IO%, chr$(val("%"+binp$)) +"|"+"")             ' write character to input list
      ' ---
      caseof "01"                       ' --- decimal ---
        addstring(IO%, str$(bin8_to_dez(binp$)) +"|"+"")         ' write decimal number to input list
      ' ---
      caseof "10"                       ' --- hexadecimal xx ---
        addstring(IO%,"h" + hinp$+"|"+"")                        ' write hxx to input list
      ' ---
      caseof "11"                       ' --- 8 bit binary --- 
       addstring(IO%,">"+left$(binp$,4)+"|"+right$(binp$,4)+".") ' write binary to input/output list
  endselect // type data IO_SR
  hide(inp_ok%)
  hide(wait_inp%)
endproc
proc output_system                    ' output system - during program run
  show(IO%)                      ' show input-output protocol
  setcheck shio%, 1
  settext boutp%, boutp$                                            ' binary output
  settext houtp%, "h" + bin8_to_hex2(boutp$)                        ' exadecimal output
  settext outp%, str$(bin8_to_dez(gettext$(boutp%)))                ' output decimal with sign
 
  if left$(boutp$,1)="1"                                            ' output is negative ...
    settext ansout%, str$( val("%"+ gettext$(boutp%)))              ' ... output ANSI code    
  else
    settext ansout%,""                                              ' output decimal is already ANSI code  
  endif
  settext  coutp%, chr$( val("%"+ gettext$(boutp%)))                ' output as character according to ANSI code
  '
  'IO_SR$                               ' type data IO left 2 bit SR
  select IO_SR$
      caseof "00"                       ' --- keyboard character --- 
        addstring(IO%,""+"|"+ gettext$(coutp%))                     ' output list character
      ' ---
      caseof "01"                       ' --- decimal ---
        addstring(IO%,""+"|"+ gettext$(outp%))                      ' output list decimal number
        
      ' ---
      caseof "10"                       ' --- hexadecimal xx ---
        addstring(IO%,""+"|"+gettext$(houtp%))                      ' output list hexadecimal number: xx        
        ' ---
      caseof "11"                       ' --- 8 bit binary --- 
        addstring(IO%,"."+left$(boutp$,4)+"|"+right$(boutp$,4)+">") ' input/output list 8 bit binary 
  endselect // type data IO_SR
endproc 
'}
'{--- number systems / arithmetic -----
proc dez_to_bin3                      ' decimal 0..7    -> 3 bit binary
parameters d%
  var b$ =  bin$(d%) 
  return mkstr$("0", 3-len(b$)) + b$ 
endproc
proc d255_to_bin8                     ' decimal   0..255 (unsigned)                  -> binary 8-digit 
 parameters d%
  var b$ =  bin$(d%)
  return mkstr$("0", 8-len(b$)) + b$ 
endproc
proc dez_to_bin8                      ' decimal -128..127 (sign: two's complement)   -> binary 8-digit  
 parameters d%
    if     ( d% > -1) and (d% < 128) ' positive range with zero
      return d255_to_bin8(d%)        ' with leading zeros
    elseif (d% > -129) and (d% < 0)  ' negative range - two's complement
      return bin$(256 + d%)          ' 1   is first bit
    elseif (d% < -128) or (d% > 127) ' cannot be represented in 8 bit signed form
      return "OVERFLOW"
    endif    
endproc  
proc bin8_to_dez                      ' binary 8-digit                            -> dec -128..127 (sign: two's complement)
 parameters b$ 
  case left$(b$,1)="0" : return val("%"+b$)                     '    0 to 127
  case left$(b$,1)="1" : return -128 + val("%"+ right$(b$,7))   ' -128 to  -1
endproc 
proc dez_to_hex2                      ' decimal (positive) to hexadecimal 2 digits
 parameters d%
  var h$ = hex$(d%)                   ' generate leading zero     
  return mkstr$("0", 2-len(h$)) + h$ 
endproc
proc hex2_to_bin8                     ' hexadecimal 2 digits to binary 8 digits
 parameters h$
  h$ = bin$(val("$"+trim$(h$)))
  return mkstr$("0", 8-len(h$) ) + h$   
endproc
proc bin8_to_hex2                     ' binary 8 digits to hexadecimal 2 digits 
  parameters Byte$
  return hex$(val("%"+left$(Byte$,4)))+hex$(val("%"+right$(Byte$,4)))
endproc
proc bit_add                          ' Addition of 3 bits with carry
  var bz%= 0                          ' initialize
  case b1$ = "1" : inc bz%            ' count set bits
  case b2$ = "1" : inc bz%
  case b3$ = "1" : inc bz%
  select bz%                       ' Number of bits -> result (decimal=):
    caseof 0
      bc$ = "0" : r$ = "0"                        ' 00    (0)   
    caseof 1
      bc$ = "0" : r$ = "1"                        ' 01    (1)
    caseof 2
      bc$ = "1" : r$ = "0"                        ' 10    (2)
    caseof 3
      bc$ = "1" : r$ = "1"                        ' 11    (3)
  endselect
endproc
'}
proc add_ALU_9                 ' addition in the 9 bit arithmetic unit in the ALU with flags
  var bit% = 0  ' start with bit value 0 (right)
  ' 9-bit adder, 8-bit and sign extension for overflow checking 
  ' bit positions (C Carry): C 7 6 5 4 3 2 1 0 - duplicate most significant bit 7 in C, dec. -128 to +127
  settext AL1%, left$(gettext$(AL1%),1) + gettext$(AL1%) ' most significant bit duplicate 1st operand
  settext AL2%, left$(gettext$(AL2%),1) + gettext$(AL2%) ' most significant bit duplicate 2nd operand
  C9$ = "         "           ' Empty carry over
  settext ALC%, C9$   
  R9$ = "         "           ' 9 bit clear result
  settext ALR%, R9$
  ALU_step
  C9$ = "        0"           'least significant carry is set to 0
  settext ALC%, C9$           ' ... and put into the ALU 
  '
  repeat                      ' bitwise addition with carry   
    ALU_bitstep
    b1$ = mid$(gettext$(AL1%),9-bit%, 1)  ' bit read out
    b2$ = mid$(gettext$(AL2%),9-bit%, 1)
    b3$ = mid$(gettext$(ALC%),9-bit%, 1)
    bit_add                   ' addition of the bits 
    if bit% < 8               ' last carry left no longer fits in C9$
      C9$ = space$(7-bit%) + bc$ + right$(C9$, bit%+1)   ' Transfer bit one more to the left ...     
    endif 
    if bit% = 7   ' last carry from 8 bit width left 
      C$ = bc$               ' set carry flag
    endif
    R9$ =   space$(8-bit%) + r$  + right$(R9$, bit%)      ' ... than the result bit.
    settext ALC%,C9$
    settext ALR%,R9$ 
    inc bit%                 ' previous, higher-order bit
  until bit% = 9 
  '
  b_res$ = right$(R9$,8)     ' result right 8 bit
  N$ = left$(b_res$,1)       ' left bit is sign bit  
  if b_res$ = "00000000" 
    Z$ = "1"                 ' set zero-flag
  else
    Z$ = "0"
  endif
  if left$(R9$,1)= mid$(R9$,2,1)  ' left two bit equal  
     V$ =  "0"                       ' ok -> result in the range -128 to 127
   else                           ' left two bit different
     V$ =  "1"                       ' set oVerflow flag 
  endif
  '  C$ will be set in the loop!
   settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$  ' set status register with flags
  ALU_step 
endproc
proc complement1_ALU           ' form one's complement in the ALU
  var bit% = 9
  settext AL1%, " " + gettext$(AL1%)               ' set right justified
  settext AL2%, "         "                        ' unused
  settext ALC%, "         "                        ' unused
  R9$ = "         "                                ' clear 9 Bit result  ...                             
  settext ALR%, R9$                                ' ... and set in the ALU
  bit% = 9
  repeat
    ALU_bitstep
    b1$ = mid$(gettext$(AL1%),bit%, 1)  ' read out bit ...
    if b1$ = "0"
       r$ = "1"                         ' ... complement
    else 
       r$ = "0"
    endif   
    R9$ =   space$(bit%-1) + r$  + right$(R9$, 9-bit%)   
    settext ALR%,R9$           
    dec bit%
  until bit% = 1                         ' without left bit (8 of 9) 
  b_res$ = right$(gettext$(ALR%), 8)
  ALU_step 
endproc  
proc complement2_ALU           ' form two's complement in the ALU (sign reversal)
  complement1_ALU
  settext AL1%,"00000001"      ' add 1 ... 
  settext AL2%, b_res$         ' ... to one's complement
  add_ALU_9                           ' addition in the 9 bit arithmetic unit in the ALU with flags
endproc
proc div_ALU                   ' division with remainder in the ALU 9Bit/8Bit
  var btmp1$ = ""   ' local for data registers D0 D1       
  var btmp2$ = ""
  var special% = 0  ' no special treatment
  var bit% = 0      ' bit counter
  settext AL1%, space$(9)
  settext AL2%, space$(9)
  settext ALC%, space$(9)
  settext ALR%, space$(9)
  show(ASP%) : show(ALN%) : show(ALP%) : show(AV1%) : show(AV2%)  ' show temporary for DIV
  textcolor darkgreen%, chipc% 
  drawtext 704, 192, "Sg"
  drawtext 865, 227, "N"
  drawtext 865, 244, "P"
  '
  btmp1$ = gettext$(R%[0])         ' read out data register 
  btmp2$ = gettext$(R%[1])
  settext AV1% , left$(btmp1$,1)   ' shift sign extension into sign bit
  settext AV2% , left$(btmp2$,1)   ' shift sign extension into sign bit
  ALU_step
  '
  if btmp1$ = "00000000"         ' dividend 0 --> quotient 0, remainder: 0
    '---Dividend----
    settext ASP%, "   D0   "
    settext AL1% , "0"+ btmp1$
    ALU_step
    settext ALR%, "000000000"    ' quotient and remainder 0 (result)
    settext S%[0], "00000000"    '  
    b_res$ = btmp1$              ' D0 remains unchanged 0, b_res$ for Z flag
    flags_b_res_N_Z_0_0          ' set flags
    special% = 1                 ' special treatment (solution, no further calculations)
  else //Dividend not 0
    '-----2---Divisor-----
    settext ASP%, "   D1   "
    settext AL1%, btmp2$           ' divisor in ALU
    if gettext$(AV2%) = "1"        ' negative divisor
      settext ALN%, btmp2$         ' drop negative divisor
      if btmp2$ ="11111111"        ' x \ (-1) = - x  remainder 0
        settext ASP%, "   D0   "
        settext AL1% , btmp1$      ' dividend to AL1
        complement2_ALU            ' calculate 2's complement with flags ( b_res$ is -D0 )
        settext R%[0], b_res$      ' quotient to D0
        settext S%[0], "00000000"  ' remainder 0
        special% = 1               ' special treatment (solution, no further calculations)
      elseif btmp2$ ="10000000"    ' abs(-128) = 128 not in the number range  
        complement2_ALU            ' calculate 2's complement with flags --> results in OVERFLOW
        '                          ' D0, SD0 stay unchanged
        special% = 1               ' special treatment (solution, no further calculations)
      else 
        complement2_ALU            ' calculate 2's complement ... 
        settext ALP%, b_res$       ' ... drop positive divisor
      endif  
    else             // "0"        ' positive divisor
      settext ALP%, btmp2$         ' drop divisor 
      if btmp2$  = "00000001"      ' x \ 1 = x remainder 0                 (internal check: left 8 bit in AL1 zero)
        settext AL1%, "0"+btmp2$   ' display sign extension /
        b_res$ =  btmp1$           ' D0 stays unchanged 
        flags_b_res_N_Z_0_0        ' set flags
        settext S%[0], "00000000"  ' remainder 0
        special% = 1               ' special treatment (solution, no further calculations)
      else
        complement2_ALU            ' calculate 2's complement  ...
        settext ALN%, b_res$       ' ... drop negative divisor
      endif
    endif // divisor sign
  endif //  dividend  0   - not 0
  ALU_step
  '
  if special% = 0 
    '-----1---Dividend----
    settext ASP%, "   D0   "
    
    if gettext$(AV1%) = "1"      ' negative dividend 
      settext AL1% , btmp1$      ' dividend to AL1
      if btmp1$ ="10000000"      ' abs(-128) = 128 not in the number range
        complement2_ALU          ' calculate 2's complement --> results in OVERFLOW
        '                        ' D0, SD0 stay unchanged 
        special% = 1             ' special treatment (solution, no further calculations)
      else 
        complement2_ALU            ' calculate 2's complement ...
        settext AL1% , "0"+b_res$  ' ... positive dividend to AL1
      endif
    else            // "0"
      settext AL1% , "0"+btmp1$ ' positive dividend to AL1
    endif
  endif // special  
  '---------------------'
  if special% = 0  ' if no special treatment  
    settext AL2%,  space$(9)     ' optically 'clear' for divisor to be used
    settext ALC%,  space$(9)     ' not used for bit comparisons ...
    settext ALR%,  space$(9)     ' ... empty result (for a better overview with the many temporary registers)
    ALU_step
    settext AL2% , "0"+ gettext$(ALP%) ' positive divisor
    settext ALf%,  space$(1) 
    settext ALt%,  space$(1)  
    settext ALa%,  space$(1) 
    settext ALS%,  space$(8)  ' temporary auxiliary register for shift status  
    settext ALD%,  space$(8)  ' temporary register for shift >> and shift << (dividend)
    settext ARL%,  space$(8)  ' temporary register for result (quotient)  
    show(ALf%) : show(ALt%) : show(ALa%)  ' show temporary for DIV
    show(ALS%) : show(ALD%) : show(ARL%) 
    '
    settext ASP%, " D0 \D1 "  
    textcolor darkgreen%, chipc% 
    drawtext 839, 165, "f"
    drawtext 847, 165, "t"
    drawtext 855, 165, "a"
    drawtext 865, 193, "S"
    drawtext 865, 210, "D"
    drawtext 865, 261, "L"
    ALU_step
    settext ALf%,  "1"           ' preset, first pass outer loop
    settext ALt%,  "0"           ' preset, no second loop 
    settext ALa%,  "0"           ' preset, no addition of -abs(Devisor) 
    settext ALS%,  "00000000"    ' set temporary auxiliary register for shift status to 0 
    settext ALD%,  "00000000"    ' temporary register for shift >> and shift << (dividend)
    settext ARL%,  "00000000"    ' temporary register for result (quotient) 
    '
    ' calculation of the quotient of the amounts of D0 and D1
    while 1  ' Cancel only with breaks, place partial dividend over divisor.
      ALU_step
      bit% = 3        ' check from left, without sign extension 1 and sign bit 2 (0 because always positive)
      settext ASP%, space$(bit%-2)+"|"+ space$(9-bit%)   ' ASP is displayed from bit 2!
    ' first partial loop
      while 1  ' abort only with breaks, check bits from left
        b1$ = mid$(gettext$(AL1%),bit%,1)   ' read out bit
        b2$ = mid$(gettext$(AL2%),bit%,1)
        b3$ = left$(gettext$(ALS%),1)       ' shift counter left bit: "1" left shift possible
        ' --------------- 
        if b1$+b2$ = "00"
        settext ASP%, space$(bit%-2)+"|"+ space$(9-bit%) 
          if bit% = 9
            ' at bit% = 9      0\0 is not defined, 0 intercepted previously
          else
            inc bit%          ' skip leading zeros
            ALU_bitstep
          endif  
        endif
        ' ---------------
        if b1$+b2$ = "01" 
          if b3$ = "1"   ' shift possible, slide left, slide ALS along (note AL1 9 bit) 
            settext ASP%, space$(bit%-2)+"<"+ space$(9-bit%) 
            settext AL1%, right$(gettext$(AL1%),8)+left$(gettext$(ALD%),1)  ' << AL1_ALD(1) (Do not increase bit counter!)
            settext ALD%, right$(gettext$(ALD%),7)+"0"                      ' << ALD(2..8)_0   
            settext ALS%, right$(gettext$(ALS%),7)+"0"                      ' Slide counter  move left, append 0
            settext ARL%, right$(gettext$(ARL%),7)+"0"                      ' append solution bit 0 (for digit << shift)
            ALU_bitstep
          else //  no << shift possible, dividend < divisor 
            settext ASP%, space$(bit%-2)+"|"+ space$(9-bit%) 
            settext ALt%, "0"                               ' no second loop,
            settext ALa%, "0"                               ' no addition of -abs(devisor)  
            case gettext$(ALf%) = "1" : settext ALf%, "0"   ' so that no more addition
            settext ALR%, gettext$(AL1%)                                   ' bring rest to ALR%
            settext ARL%, right$(gettext$(ARL%),7)+"0"                     ' append solution bit 0 
            break                                                
          endif 
        endif 
        ' ---------------
        if b1$+b2$ = "10" 
          if bit% = 9
            ' at bit% = 9      1\0 is not defined, 0 intercepted previously 
          else
            if gettext$(ALf%) = "1"     ' only on first pass in outer loop: left position dividend to divisor
              settext ASP%, space$(bit%-2)+">"+ space$(9-bit%) 
              settext ALD%, right$(gettext$(AL1%),1)+left$(gettext$(ALD%),7)  ' >> AL1(9)_ALD 
              settext AL1%, "0" + left$(gettext$(AL1%),8)                     ' >> 0_AL1(1..8)
              settext ALS%, "1" + left$(gettext$(ALS%),7)                     ' fill slide counter with 1 from left
              inc bit%
              ALU_bitstep
            else
              settext ALt%, "0"                ' no second loop 
              settext ALa%, "1"                ' addition of -abs(Devisor)         
              settext ARL%, right$(gettext$(ARL%),7)+"1"                     ' append solution bit 1
              break
            endif
          endif  
        endif 
        ' ---------------
        if b1$+b2$ = "11" 
          settext ASP%, space$(bit%-2)+"|"+ space$(9-bit%)  
          if bit% = 9  
           ' at bit% = 9     1\1 = 1 remainder 0 division by 1 is intercepted before, otherwise algorithm faulty
          else  
            settext ALt%, "1"                                   ' second loop (since 1 found over 1)
            inc bit%                                            ' ... from following bit
            break                                               '    
          endif
        endif
        '----------------
      endwhile // first partial loop 
      ALU_bitstep
      '
      if gettext$(ALt%) = "1"                             '  <---  go through subloop two
        settext ASP%, space$(bit%-2)+":"+ space$(9-bit%) 
        while 1  'abort only with breaks      ' second partial loop: check further bits to the right
          b1$ = mid$(gettext$(AL1%),bit%,1)   ' read out bit
          b2$ = mid$(gettext$(AL2%),bit%,1)
          b3$ = left$(gettext$(ALS%),1)       ' shift counter left bit: "1" left shift possible
          ' ---------------
          if b1$+b2$ = "00"  
            if bit% = 9 
              if b3$ = "1"                    '  only interim result still shift possible
                settext ALa%, "1"                                   ' addition of -abs(devisor)
              else //   letzte Teilrechnung
                settext ALa%, "0"                                   ' no addition of -abs(devisor)   
                settext ALR%, "000000000"                           ' remainder 0 to ALR
              endif 
              settext ARL%, right$(gettext$(ARL%),7)+"1"            ' append solution bit 
              break 
            else
               inc bit%
               settext ASP%, space$(bit%-2)+":"+ space$(9-bit%)
              ALU_bitstep
            endif
          endif
          ' ---------------
          if b1$+b2$ = "01"
            if b3$ = "1"   ' shift possible, move ALS along, (note AL1 9 bit)  
              settext ASP%, space$(bit%-2)+"<"+ space$(9-bit%) 
              settext AL1%, right$(gettext$(AL1%),8) + left$(gettext$(ALD%),1)  ' << AL1_ALD(1) (Do not increase bit counter!)
              settext ALD%, right$(gettext$(ALD%),7) + "0"                      ' << ALD(2..8)_0
              settext ALS%, right$(gettext$(ALS%),7) + "0"                      ' slide counter move left, append 0
              settext ARL%, right$(gettext$(ARL%),7)+"0"                        ' append solution bit 0 (for digit << shift)
              settext ARL%, right$(gettext$(ARL%),7)+"1"                        ' append solution bit 1 (for 'Division')
              settext ALa%, "1"                                                 ' addition of -abs(devisor), position reached
              break                                                             
            else
              settext ALa%, "0"                                                 ' no shift possible ,no addition of -abs(devisor)
              settext ARL%, right$(gettext$(ARL%),7)+"0"                        ' append solution bit 0
              settext ALR%, gettext$(AL1%)                                      ' remainder to ALR%
              break 
            endif 
          endif  
          ' ---------------
          if b1$+b2$ = "10"
            settext ARL%, right$(gettext$(ARL%),7)+"1"          ' append solution bit 1
            settext ALa%, "1"                                   ' addition of -abs(devisor), position reached
            break                                               ' dividend greater than divisor
          endif
          ' ---------------
          if b1$+b2$ = "11"   
            if bit% = 9 
              if b3$ = "1"                    ' only interim result still shift possible
                settext ALa%, "1"                                   ' addition of -abs(Devisor)
              else //   last partial calculation
                settext ALa%, "0"                                   ' no addition of -abs(devisor)
                settext ALR%, "000000000"                           ' remainder 0 to ALR
              endif 
              settext ARL%, right$(gettext$(ARL%),7)+"1"            ' append solution bit   
              break 
            else
              inc bit%
              settext ASP%, space$(bit%-2)+":"+ space$(9-bit%)
              ALU_bitstep
            endif
          endif 
          ' ---------------
        endwhile // second partial loop 
      endif 
      settext ASP%, space$(8)
      ALU_step
      '-------
      if gettext$(ALa%) = "1"              ' addition negative divisor
        settext AL1%  , right$(gettext$(AL1%),8)          ' without sign extension, is put in front in add_ALU_9
        settext AL2%  , gettext$(ALN%)                    ' bring -abs(D1) to AL2 for addition
        settext ASP%, " add N  "
        ' -------
        add_ALU_9                          ' <---  addition in the 9 bit arithmetic unit in the ALU with flags
        ' -------
        b3$ = left$(gettext$(ALS%),1)                     ' shift counter left bit
        settext ASP%, space$(8)                           ' clear
        ALU_step
        if b3$ ="1"                                       ' shift counter left bit = 1, shift the bit of the dividend
          settext AL1%, "0"+b_res$                        ' difference in b_res is remainder, set again in AL1
          settext AL2%, "0"+gettext$(ALP%)                ' set positive divisor with sign extension in AL2
          settext ALC%, space$(9)
          settext ALR%, space$(9) 
          ALU_bitstep
          ' trail a further bit of the dividend 
          settext ASP%, space$(bit%-3)+"<-"+ space$(9-bit%) 
          settext AL1%, right$(gettext$(AL1%),8)+left$(gettext$(ALD%),1)  ' << AL1_ALD(1)  (Do not increase the bit counter!)
          settext ALD%, right$(gettext$(ALD%),7)+"0"                      ' << ALD(2..8)_0   
          settext ALS%, right$(gettext$(ALS%),7)+"0"                      ' move Slide counter to left, append 0 
          ALU_step
        else
          break   ' ready, in ALR is remainder
        endif
      else //  no addition of -abs(D1)
        break     ' remainder in ALR
      endif
      case gettext$(ALf%) = "1" : settext ALf%, "0"     ' further passes of the outer loop
    endwhile // outer loop
    ALU_step
    '-------
    ' AV1, AV2 -> sign of quotient and remainder
    if gettext$(AV1%) = "0"                           ' dividend positive ...
      settext S%[0], right$(gettext$(ALR%),8)         ' ... remainder positive
      if gettext$(AV2%) =  "0"                        ' divisor positive ...
        b_res$ = gettext$(ARL%)                       ' ... quotient positive
        ALU_step
      else     // (AV2%) = "1"                        ' divisor negative ... 
        settext AL1%, gettext$(ARL%)                  ' ... quotient negative
        settext ASP%, " Qu (-) "
        complement2_ALU                               ' 2's complement (in b_res)
      endif
    elseif gettext$(AV1%) = "1"                       ' dividend negative ...
      settext AL1% , right$(gettext$(ALR%),8)         ' ... remainder  negative
      settext ASP%, " Re (-) "
      complement2_ALU                                 ' 2's complement (in b_res)
      settext S%[0], b_res$                                              
      if gettext$(AV2%) = "0"                         ' divisor positive ...
        settext AL1%, gettext$(ARL%)                  ' ... quotient negative
        settext ASP%, " Qu (-) "
        complement2_ALU                               '  2's complement (in b_res)
      else    // (AV2%) = "1"                         ' divisor negative ... 
        b_res$ = gettext$(ARL%)                       ' ... quotient positive 
        ALU_step
      endif
    endif
    settext R%[0], b_res$                             ' quotient to D0
    flags_b_res_N_Z_0_0                               ' flags (without special cases)
    ' -----                    
    settext ALS%,  space$(8)   ' clear temporary ALU registers
    settext ALf%,  " " 
    settext ALt%,  " " 
    settext ALa%,  " "  
    settext ALD%,  space$(8) 
    settext ARL%,  space$(8)  
    hide(ALS%) : hide(ALf%) : hide(ALt%) : hide(ALa%) : hide(ALD%) :  hide(ARL%)  ' wieder verbergen
    textcolor chipc% , chipc% 
    drawtext 839, 165, "f"     ' overwrite with background color of the CPU
    drawtext 847, 165, "t"
    drawtext 855, 165, "a"
    drawtext 865, 193, "S"
    drawtext 865, 210, "D"
    drawtext 865, 261, "L"
  endif // special = 0 (no special treatment)
  '
  ' after special treatment
  settext ASP%,  space$(8)   ' clear temporary ALU registers
  settext AV1%,  " " 
  settext AV2%,  " " 
  settext ALN%,  space$(8)                
  settext ALP%,  space$(8)
  hide(ASP%) : hide(AV1%) : hide(AV2%) : hide(ALN%) : hide(ALP%) 
  textcolor chipc% , chipc% 
  drawtext 704, 192, "Sg"        ' overwrite with background color of the CPU
  drawtext 865, 227, "N"
  drawtext 865, 244, "P"
endproc
proc mul_Booth_ALU             '  multiplication according to Booth in the ALU 9Bit/8Bit
  var btmp1$ = gettext$(R%[0])         ' read out data register locally
  var btmp2$ = gettext$(R%[1])
  settext AL1%, space$(9)
  settext AL2%, space$(9)
  settext ALC%, space$(9)
  settext ALR%, space$(9)
  show(booth%) : show(ALBA%)     ' show temporary registers of the ALU
  settext AL1%, btmp1$          ' register D0 to AL1 ...
  ALU_step
  textcolor darkgreen%, chipc% 
  drawtext 865, 210, "A"
  settext ALBA%, btmp1$         ' D0 for addition to temporary register A
  complement2_ALU                ' ... form two's complement
  show(ALBS%)
  textcolor darkgreen%, chipc%
  drawtext 865, 227, "S"
  settext ALBS% , b_res$         ' -D0  for subtraction (two's complement) display in S
  ALU_step 
  show(ARL%) : show(ALx%)        ' temporary registers of the ALU
  textcolor darkgreen%, chipc% 
  drawtext 865, 244, "x"
  settext ALR%  , "000000000"    ' 9 bit: initial value for continuous summation +/-, >> with D0 (sign extension)
  settext ARL%  , btmp2$        ' 8 bit: register for solution, insert  D1
  settext ALx% , "0"             ' 1 bit initial value
  btmp2$ = b_res$               ' restore for subtraction,    +(-D0)
  '
  whileloop 8
    settext AL1%, space$(9)       ' \                
    settext AL2%, space$(9)       '  -  clear ALU registers
    settext ALC%, space$(9)       ' /
    ALU_step 
    b1$ = right$(gettext$(ARL%),1)
    b2$ = gettext$(ALx%)
    if b1$ = b2$                  ' 00 and 11          
      shift_ALRx                  ' shift only (shift >>) with sign extension
    else
      if (b1$="0") and (b2$="1")  
        settext AL2%, btmp1$     ' D0 for addition to AL2   
      endif
      if (b1$="1") and (b2$="0") 
        settext AL2%, btmp2$     ' -D0 for addition to AL2    
      endif  
      settext AL1%, right$(gettext$(ALR%),8)   ' restore running total to AL1
      add_ALU_9                                ' Addition in the 9 bit arithmetic unit in the ALU with flags.
      ALU_step 
      shift_ALRx                  ' shift   (shift >>) with sign extension
    endif    
    ALU_step 
  endwhile
  '
  settext ALR%, " "+ right$(gettext$(ALR%),8) ' >> remove character
  settext ALBA%, space$(8)                    ' \
  settext ALBS%, space$(8)                    '  - clear temporary ALU registers
  settext ARL%,  space$(8)                    ' /
  settext ALx%,  " "                          ' 
  textcolor chipc%, chipc%          ' overwrite with background color
  drawtext 865, 210, "A"
  drawtext 865, 227, "S"
  drawtext 865, 244, "x"
  settext booth%, chr$(187)+" Booth"
  hide(booth%) : hide(ALBA%) : hide(ALBS%) : hide(ARL%) : hide(ALx%)
endproc
'{--- auxiliary procedures assembler ------
proc restore_instruction              ' Restore command (input) with comment
  settext mn% , left$( gettext$(RAM%, coderow%,3) , 3)     ' set mnemonic
  settext op1%,  mid$( gettext$(RAM%, coderow%,3) , 5, 4)  ' set Op 1
  settext op2%,  mid$( gettext$(RAM%, coderow%,3) ,10, 4)  ' set Op 2
  settext opcomm%, trim$(mid$(comment$[coderow%],2,255))   ' set command comment
endproc
proc restore_const                    ' restore constant (input) with comment
  settext coninp%, trim$( left$( gettext$(RAM%, conrow%,3) ,4) )
  settext concomm%, trim$(mid$(comment$[conrow%],2,255))                      
endproc
proc restore_from_RAM                 ' restore command or constant from RAM with comment
    if (ramrow% > -1) AND (ramrow% < 128)  ' ramrow% is -1    when clicking on "Subline" at the end of the gridbox!
      coderow% = ramrow%                  
      restore_instruction      '  set Mnemonic Op1,2 and comment in input editsn
    endif
    if (ramrow% > 127)  AND (ramrow% < 256) 
      conrow%  = ramrow%
      restore_const            ' Set constant (input) with comment
    endif
 endproc 
proc rc                               ' assign register code
 parameters rg$
  case rg$= ".IA." : return ""
  case rg$= ".+A." : return ""
  case len(rg$)= 0 : return ""
  rg$ = mid$(rg$ ,2,2)             ' register without addressing . . resp. [  ]
  case rg$="D0" : return "00"  
  case rg$="D1" : return "01"
  case rg$="A0" : return "10"
  case rg$="A1" : return "11"
endproc   
proc load_asm                         ' load HC680 assembler file (*.txt)
  asmfile$ = ""
  row%  = -1                       ' preassignment for checking whether read
  asmfile$ = loadfile$("load assembler file","HC680 assembler (*.txt)|*.txt")
  if len(asmfile$) > 0
    load_ram(0)                    ' load without shifting into RAM
    initial_r0_r128                ' initialize edits and variables line 0 and 128
  endif  
endproc
proc isnot_hex2                       ' check for incorrect hexadecimal address
 parameters h1$
  var h2$ = right$(h1$,1)
  var ord1% = ord(h1$)    ' ord( ) uses left character of the double-digit address  
  var ord2% = ord(h2$) 
  if len(h1$) > 2          ' check length of h1$
    messagebox("wrong address length - address: "+ h1$  +"\n \nnote address 00  to  FF  resp. ff  ","--- address error ---",16)
    return 1
  endif  
  if   (ord1% < 48) or ((ord1% > 57) and (ord1% < 65)) or ((ord1% > 70) and (ord1% < 97))  or (ord1% > 102) \
    or (ord2% < 48) or ((ord2% > 57) and (ord2% < 65)) or ((ord2% > 70) and (ord2% < 97))  or (ord2% > 102) 
        messagebox("wrong address: "+ h1$  +"\n \nnote address 00  to  FF  resp. ff","--- address error ---",16)  
    return 1
  else 
    return 0
  endif 
endproc
proc rel_value                        ' edit shift value for assembler in RAM
  if getfocus(verschieb%) 
    ansi% = ord(trim$(gettext$(verschieb%)))                     ' ANSI 1. character
    if ( (ansi%=36) or (ansi%=72) or (ansi%=104) )  '  $ ,H ,h  1st character positive hexadecimal number
      shiftass%  = val("$"+ mid$(gettext$(verschieb%),2,3))      ' convert into dec  
      settext toolverschieb%, %hwnd, verschieb%, "dez +"+ str$(verschbg%) + verstooltxt$
    elseif ansi% = 45     
      ansi% = ord(mid$(trim$(gettext$(verschieb%)),2,4))         ' ANSI 2nd character if minus sign at the beginning
      if   ( (ansi%=36) or (ansi%=72) or (ansi%=104) )    ' - and $ ,H ,h  2nd character negative hexadecimal number
        shiftass%  =  -val("$"+ mid$(trim$(gettext$(verschieb%)),3,3))    ' convert into dec - negative
        settext toolverschieb%, %hwnd, verschieb%, "dez "+ str$(verschbg%) + verstooltxt$
      else ' negative decimal
        shiftass%  = val(gettext$(verschieb%))
        settext toolverschieb%, %hwnd, verschieb%, "-h"+ hex$(-verschbg%) + verstooltxt$
      endif
    else  ' therefore positive decimal
        shiftass%  = val(gettext$(verschieb%)) 
        settext toolverschieb%, %hwnd, verschieb%, "h"+ hex$( verschbg%) + verstooltxt$
    endif  
    if ((verschbg%<-255) or (verschbg%>255))     ' overwrite tooltip
     settext toolverschieb%, %hwnd, verschieb%, " decimal value not possible! "  + verstooltxt$
    endif  
  endif  
endproc
proc store_asm                        ' store  HC680 assembler file (*.txt) 
  asmfile$ = ""
  asmfile$ = savefile$("store assembler file","HC680 assembler (*.txt)| *.txt")
  if len(asmfile$) > 0
    pv$ = gettext$(prgvon%)  ' program  from (hexadecimal)
    pb$ = gettext$(prgbis%)  ' program  to   (hexadecimal)
    dv$ = gettext$(datvon%)  ' Data     from (hexadecimal)
    db$ = gettext$(datbis%)  ' Data     to   (hexadecimal)
    row% = -1       ' preassignment for error checking
    case ( len(pv$)=0 ) and ( len(pb$) = 0 ) and ( len(dv$)=0 ) and ( len(db$)=0 ) : dec row% ' no area
    if ( len(pv$)>0 ) and ( len(pb$)>0 )
      if isnot_hex2(pv$) or isnot_hex2(pb$) 
        dec row%   '  Error: Inputs not correct hexadecimal one or two digits
      endif
    endif  
    if ( len(dv$)>0 ) and ( len(db$)>0 )   
      if isnot_hex2(dv$) or isnot_hex2(db$)  ' logical functions with error message ...
         dec row%   '   Error: Inputs not correct hexadecimal one or two digits  
      endif
    endif 
    ' 
    case row%  = -1 :  store_ram   ' save the RAM rows with addresses xx (xx hexadecimal )
    '  
    if row%  < 0       ' no storage is made
      messagebox("No storage was made."," --- error when storing ---",48)
    endif 
  endif // Datei 
endproc 
proc reloc_asm                        ' shift assembler in RAM
  var msgprg$ = ""                 ' text for error message      
  var msgdat$ = ""
  var msgver$ = ""
  pv$ = gettext$(prgvon%)          ' program  from (hexadecimal)
  pb$ = gettext$(prgbis%)          ' program  to   (hexadecimal)
  dv$ = gettext$(datvon%)          ' Data     from (hexadecimal)
  db$ = gettext$(datbis%)          ' Data     to   (hexadecimal)
  '                                
  if ( len(pv$)>0 ) and ( len(pb$)>0 )             ' shifting in the program area
    if isnot_hex2(pv$) or isnot_hex2(pb$)
      msgver$ = ""  ' as error detection, abort (inputs not correct hexadecimal one or two digits)
      '
    else
      msgprg$ = "\n command area  h" + pv$+" to  h" + pb$ 
    endif  
  endif
  '
  if ( len(dv$)>0 ) and ( len(db$)>0 )             ' shifting in the data area
    if isnot_hex2(dv$) or isnot_hex2(db$)  ' logical functions with error message ...
      msgver$ = ""  ' as error detection, abort (inputs not correct hexadecimal one or two digits)
      '
    else  
      msgdat$ = "\n       Data area  h" + dv$+" to  h" + db$  
    endif
  endif
  '
  if shiftass% <> 0  ' not: empty or 0
    msgver$ =   + "\nshift decimal "+ str$(verschbg%) +" in RAM? "
  endif 
  '
  if msgprg$ <> ""           ' shifting in the program area
    if    ( (val("$"+pv$)  + verschbg%) <  0 )    \
       or ( (val("$"+pb$)  + verschbg%) > 127 )          
      messagebox("Old or new program area incorrect.     ","---  Error when shifting!  ---",48) 
      msgver$ = ""  ' as termination indicator
      msgprg$ = "b_fehler"
    endif
  endif
  '
  if msgdat$ <> ""           ' shifting in the data area
    if    ( (val("$"+dv$)+verschbg%) < 128 )    \
       or ( (val("$"+db$)+verschbg%) > 255 )    
      messagebox("Old or new data range incorrect.     "  ,"---  Error when shifting!  ---",48) 
      msgver$ = ""  ' as termination indicator
      msgdat$  = "b_fehler"
    endif
  endif 
  '
  if  (msgver$ = "") or ( (msgver$ <>"") and (msgprg$ = "") and (msgdat$ = "")  ) ' incorrect values
    if  (( msgprg$ <> "b_fehler" ) and ( msgdat$ <> "b_fehler" ))                 ' no error message occurred yet
    '  
      messagebox("Error! \n\nPlease check the values of the shifting.  "," --- Shifting in RAM ---", 48)  
    endif
  else    '   
    if ( messagebox("Do you want to have " + msgprg$ + msgdat$ + msgver$," --- Shifting in RAM ---", 289) = 1 )  
      asmfile$ = "asm_tmp.txt"       ' store asm_tmp.txt as
      store_ram                      ' cache (with check from < to, otherwise error message)
      if row% > -1                   ' saving temporary file successful, further steps possible
        pv$ = "00"                   ' complete RAM ...
        pb$ = "7F"
        dv$ = "80"
        db$ = "FF"
        asmfile$ = "asm_bak.txt"     ' ... as backup asm_bak.txt
        store_ram                    ' save 
        '
        asmfile$ = "asm_tmp.txt"     ' use buffer ...
        clear_source_ram             ' ... RAM rows, delete comments of the old addresses of the shift arean ... 
        load_ram(verschbg%)          ' ... load with shift into RAM
        initial_r0_r128              ' establish initial state assembler
      endif
    endif // shift message ok
  endif // message faulty values  
endproc
proc clear_source_ram                 ' set RAM source range of shift to zero
assign #1,asmfile$ 
  reset #1
  input #1, asm$                    ' title line - discard
  input #1, asm$                    ' start address without matter
  input #1, asm$                    ' intermediate line heading commands - discard
  ' --- reading in assembler commands and data
  whilenot ( eof(#1) )  
    input #1, asm$
    asm$   = trim$(asm$)                ' discard surrounding spaces
    row%   = val("$"+left$(asm$,2))     ' decimal RAM address
    ' set contents to NOP, zero, empty
    if row% < 128                       ' commands:
      coderow% = row%                     ' decimal RAM address
      mn$ ="00000000"                     ' reset!
      opcomm$ = ""                        ' clear comment
      assembler_to_binary_code            ' set command, operands and comment
    endif
    if row% > 127                       ' Data:
      conrow% = row%                      ' decimal RAM address
      coninp$ = ""                        ' reset!
      concomm$ = ""                       ' clear comment
      define_constant                     ' set constant and comment
    endif
  endwhile // file end reached 
  close #1  
endproc
proc load_ram                         ' load RAM rows from file (addresses before commands/data)
 parameters rel%        ' parameters for shifting when reading in, then set old addresses to NOP, zero
  var ts% = 0           ' No. substring, separation different number of spaces between addr., mnemonic, operands
  assign #1,asmfile$ 
  reset #1
  input #1, asm$                    ' program name from title line
  prgn$ =  trim$(substr$(asm$,2,";"))
  settext progname%, prgn$
  input #1, asm$
  settext startadr%,left$(asm$,2)   ' 2-digit hexadecimal address Start address
  input #1, asm$                    ' intermediate line heading commands - discard
  ' --- Reading in assembler commands and data
  whilenot ( eof(#1) )  
    input #1, asm$
    asm$   = trim$(asm$)                ' discard surrounding spaces
    '
    hex2$  = left$(asm$,2)              ' ord( ) uses left character of the two-digit address
    hex1$  = right$(hex2$,1)            ' right digit
    if rel% = 0                         ' check file entries when loading assembler
      if   (ord(hex2$)< 48) or ((ord(hex2$)>57) and (ord(hex2$)< 65)) or ((ord(hex2$)>70) and (ord(hex2$)< 97))  or (ord(hex2$)>102) \
        or (ord(hex1$)< 48) or ((ord(hex1$)>57) and (ord(hex1$)< 65)) or ((ord(hex1$)>70) and (ord(hex1$)< 97))  or (ord(hex1$)>102) 
        messagebox("Abort, wrong address:    "+ hex2$  +"\n \nNote address 00 to FF or ff.          ","--- Error while loading the file! ---",48)
        break                            ' abort
      endif
    endif
    '
    l_asm% = len(asm$)                  ' length of the assembler line
    row%   = val("$"+left$(asm$,2))     ' decimale RAM-address
    '
    row% = row% + rel%                  ' new adess (rel% only if shifted , otherwise call with 0)   
    '
    if row% < 128                     ' Commands
      coderow% = row%                     ' decimale RAM-address
      mn$ ="" : op1$="" : op2$=""         ' reset, because of input#1 otherwise old content remains!
      ts% = 2                             ' ts% =2 --> second substring is mnemonic of the command
      mn$ = substr$(asm$,ts%," ")         
      if mn$ = ""                         ' space character instead of :
        inc ts%  
        mn$ = substr$(asm$,ts%," ")  
      endif  
      case len(mn$) = 2 : mn$ = mn$ + " " ' add space character at OR, ##
      if l_asm% >  11 
        inc ts%
        op1$ =  substr$(asm$,ts%," ")     ' Operand after a space character
        if op1$ = ""
          inc ts%                         ' more spaces present as separation ...
          op1$ = substr$(asm$,ts%," ")  
        endif  
        if op1$ = "" 
          inc ts%
          op1$ = substr$(asm$,ts%," ")
        endif  
        if op1$ = ""
          inc ts%
          op1$ = substr$(asm$,ts%," ")
        endif  
        case len(op1$) = 2 : op1$ = "."+op1$+"."  ' add points
      else
        op1$ = ""
      endif // Operand 1
     '
      if len(op1$) > 0                   ' first operand present
        inc ts%
        op2$ =  substr$(asm$,ts%," ")    ' second operand after a space character
        if op2$ = ""
          inc ts%                        ' more spaces present as separation ...
          op2$ = substr$(asm$,ts%," ") 
        endif 
        if op2$ = ""
          inc ts%
          op2$ = substr$(asm$,ts%," ") 
        endif  
        if op2$ = ""
          inc ts%
          op2$ = substr$(asm$,ts%," ") 
        endif  
        case len(op2$) = 2 : op2$ = "."+op2$+"."  ' add points
      else  
        op2$ = ""
      endif // operand 2
      '
      if l_asm%  > 19                     ' comment present (with ; position 20  -  starting from position 21)
        opcomm$ = mid$(asm$,21,l_asm%-20) ' read in without ;  - will be added again internally!
      endif   
      assembler_to_binary_code            ' set command, operands and comment
    endif 
    '
    if row% > 127                     ' data 
      conrow% = row%                      ' decimal RAM address
      coninp$ = ""                        ' reset, because otherwise old content remains at input#1!
      coninp$ = substr$(asm$,2," ")       'second substring is value of constant
      case coninp$="" : coninp$ = substr$(asm$,3," ")   'if two spaces as separation
      case coninp$="" : coninp$ = substr$(asm$,4," ")   'if three spaces as separation
      case coninp$="" : coninp$ = substr$(asm$,5," ")   'if four spaces as separation
      case coninp$="" : coninp$ = substr$(asm$,6," ")   'if five spaces as separation
      if l_asm%  > 19                      ' Comment present (starting from position 20 with ;)
        concomm$ = mid$(asm$,21,l_asm%-20) ' read in without semicolon, will be added again internally 
      endif
      define_constant                     ' Set constant and comment
    endif
  endwhile // file end reached
  close #1
endproc
proc initial_r0_r128                  ' initialize addr. 0 and 128
  coderow% = 0                            ' set back to default start adr. 00
  restore_instruction                     ' set Mnemonic Op1,2 and comment in input edits
  mn$      = gettext$(mn%)                ' read out Mnemonic again 
  op1$     = gettext$(op1%)               ' read out operand 1 again 
  op2$     = gettext$(op2%)               ' read out operand 2 again
  opcomm$  = gettext$(opcomm%)            ' comment on command - read out again 
  hide(op1%)                              ' hide operand inputs 
  hide(op2%)
  conrow% = 128                           ' set to start constants again
  restore_const                           ' set constant and comment for it in input edits
  coninp$  = gettext$(coninp%)            ' read out constant again
  concomm$ = gettext$(concomm%)           ' read out comment to constant again
endproc
proc store_ram                        ' store assembler within the given limits
   if    ( val("$"+pv$) < val("$"+pb$) +1 ) \
     and ( val("$"+dv$) < val("$"+db$) +1 )  '  check    start address < = end address
    assign #1,asmfile$
    rewrite #1              ' overwrite existing 
    asm$ = "HC680 Assembler    ;"+prgn$
    print #1, asm$
    asm$ = right$(gettext$(startadr%),2) + ": ST             ; Startadr."
    print #1, asm$
    asm$ = "Adr Mnm _Op_ _Op_  ;  - Kommentar -"
    print #1, asm$                                                               
    ' --- program --- 
    if (len(pv$)>0) and (len(pb$)>0)         ' no specification - no storage of the program area
      row% = val("$"+pv$)                    ' store program from start address
        while row% < val("$"+pb$) +1           ' until end address program 
          asm$ = gettext$(RAM%, row%, 1) + ": "+trim$(gettext$(RAM%, row%, 3))
          asm$ = asm$ + space$( 19 - len(asm$) ) + comment$[row%]   
          print #1, asm$ 
          inc row% 
        endwhile 
    endif  
   ' --- Daten ---
    if (len(dv$)>0) and (len(db$)>0)         ' no specification - no storage of the data area
      row% = val("$"+dv$)                    ' store from data address start
      while row% < val("$"+db$) + 1            ' until end address data
        asm$ = gettext$(RAM%, row%, 1) + ": "+  trim$(gettext$(RAM%, row%, 3)) 
        asm$ = asm$ + space$(7) + comment$[row%] 
        print #1, asm$
        inc row%    
      endwhile 
    endif
    close #1
  else
    messagebox("program or data \n   'to' < 'from' \nstorage not possible  "  ,"--- Error while storing! ---",48) 
    row% = -1   ' as identifier "not stored" 
  endif  
endproc
'}
proc assembler_to_binary_code  ' assembler --> binary code
  select mn$              ' opcode binary (structured)  /    Meaning / Effect
  
                          '       group bit  yy   xx    / yy, xx partly operands (registers)
                          '        ---   -   --   --
     caseof ""                                               ' display of the affected flags
                           oc$ =  ""                           
       clr_hide12:                                            fl$ = "    "
    caseof "NOP"
                           oc$ =  "000"+"0"+"00"+"00"   
      clr_hide12:                                             fl$ = "    "
    caseof "CMP"
                           oc$ =  "000"+"0"+"00"+"01"   
      clr_hide12:                                             fl$ = "NZVC"
    caseof "SWD"
                           oc$ =  "000"+"0"+"00"+"10"    
      clr_hide12:                                             fl$ = "    "  
    caseof "SWM" 
                           oc$ =  "000"+"0"+"00"+"11"   
      clr_hide12:                                             fl$ = "    "
    caseof "MUL"  
                           oc$ =  "000"+"0"+"01"+"00"    
      clr_hide12:                                             fl$ = "NZVC"
    caseof "DIV" 
                           oc$ =  "000"+"0"+"01"+"01"   	 
      clr_hide12:                                             fl$ = "NZVC"
    caseof "PSA" 
                           oc$ =  "000"+"0"+"01"+"10"    
      clr_hide12:                                             fl$ = "    "
    caseof "POA" 
                           oc$ =  "000"+"0"+"01"+"11"    
      clr_hide12:                                             fl$ = "NZVC"
    caseof "JSR"  
                           oc$ =  "000"+"0"+"10"+"00"     
      clr_hide12:                                             fl$ = "    "
    caseof "RET"                            ' Attention: order code
                           oc$ =  "000"+"0"+"11"+"00"    ' 
      clr_hide12:                                             fl$ = "NZVC"
    caseof  "JIN", "JIZ" , "JMP"  
      show(op1%)
      select op1$
        caseof ".+A."   
          case mn$="JIN" : oc$ =  "000"+"0"+"10"+"01"    
          case mn$="JIZ" : oc$ =  "000"+"0"+"10"+"10"    
          case mn$="JMP" : oc$ =  "000"+"0"+"10"+"11"    
                                                              fl$ = "    "
        caseof ".IA."
          case mn$="JIN" : oc$ =  "000"+"0"+"11"+"01"
          case mn$="JIZ" : oc$ =  "000"+"0"+"11"+"10"
          case mn$="JMP" : oc$ =  "000"+"0"+"11"+"11"
                                                              fl$ = "    "
        caseof ".D0.",".D1.",".A0.",".A1."  ' Attention: order code               
          case mn$="JIN" : oc$ =  "000"+"1"+"01" + rc(op1$) 
          case mn$="JIZ" : oc$ =  "000"+"1"+"10" + rc(op1$) 
          case mn$="JMP" : oc$ =  "000"+"1"+"11" + rc(op1$) 
                                                              fl$ = "    "
        otherwise
          oc$ = "00000000"
          fl$ = "    "
      endselect 
      op2$ = "" : hide(op2%) 
    caseof "LDC"                            
      show(op1%)
      select op1$
        caseof ".D0.",".D1.",".A0.",".A1."   ' Attention: order code
                           oc$ =  "000"+"1"+"00" + rc(op1$) : fl$ = "NZ  "         
        otherwise
          oc$ = "00000000"
          fl$ = "    " 
        endselect
        op2$ = "" : hide(op2%) 
    caseof  "## "
      show(op1%): show(op2%)    
      op1$ = trim$(op1$) : op2$ = trim$(op2$)
      '
      if   (    ( len(op1$) = 4 ) and ( len(op2$) = 4 )    )      \
        and \ 
           (    ( (left$(op1$,1) ="0") or (left$(op1$,1) ="1") )  \ 
            and ( (mid$(op1$,2,1)="0") or (mid$(op1$,2,1)="1") )  \                                  
            and ( (mid$(op1$,3,1)="0") or (mid$(op1$,3,1)="1") )  \ 
            and ( (right$(op1$,1)="0") or (right$(op1$,1)="1") )  \ 
            and ( (left$(op2$,1) ="0") or (left$(op2$,1) ="1") )  \ 
            and ( (mid$(op2$,2,1)="0") or (mid$(op2$,2,1)="1") )  \                                  
            and ( (mid$(op2$,3,1)="0") or (mid$(op2$,3,1)="1") )  \ 
            and ( (right$(op2$,1)="0") or (right$(op2$,1)="1") )  \ 
           )  
                                                               '  constants check    
       '------------------------------------------------------        
                           oc$ =  op1$ + op2$            :  fl$ = "    "   
      else
        oc$ = "00000000"  
        fl$ = "    "
      endif 
    caseof "INP", "OUT" , "PSH", "POP" , "SSR" ,  "GSR" , "BTS" , "SWN"    
      show(op1%)
      select op1$
        caseof ".D0.",".D1.",".A0.",".A1."
          if mn$="INP" 
                           oc$ =  "001"+"0"+"00" + rc(op1$) : fl$ = "NZ  " 
          endif
          if mn$="OUT" 
                           oc$ =  "001"+"0"+"01" + rc(op1$) : fl$ = "    "
          endif 
          if mn$="PSH" 
                           oc$ =  "001"+"0"+"10" + rc(op1$) : fl$ = "NZ  "
          endif                 
          if mn$="POP" 
                           oc$ =  "001"+"0"+"11" + rc(op1$) : fl$ = "NZ  " 
          endif   
          if mn$="SSR" 
                           oc$ =  "001"+"1"+"00" + rc(op1$) : fl$ = "NZ  " 
          endif   
          if mn$="GSR" 
                           oc$ =  "001"+"1"+"01" + rc(op1$) : fl$ = "NZ  " 
          endif   
          if mn$="BTS"
                           oc$ =  "001"+"1"+"10" + rc(op1$) : fl$ = "NZ  "
          endif                 
          if mn$="SWN"                 
                           oc$ =  "001"+"1"+"11" + rc(op1$) : fl$ = "NZ  "
          endif                    
        otherwise
          oc$ = "00000000"  
          fl$ = "    "  
      endselect 
      op2$ = "" : hide(op2%)  
    caseof "SHL" ,"SHR", "ROL", "ROR", "CLR", "INC","DEC", "NOT"     
      show(op1%)
      select op1$
        caseof ".D0.",".D1.",".A0.",".A1."
          if mn$="SHL"
                           oc$ =  "010"+"0"+"00" + rc(op1$)  : fl$ = "NZ C"
          endif                 
          if mn$="SHR"
                           oc$ =  "010"+"0"+"01" + rc(op1$)  : fl$ = " Z C"
          endif                 
          if mn$="ROL"
                           oc$ =  "010"+"0"+"10" + rc(op1$)  : fl$ = "NZ C"
          endif                 
          if mn$="ROR" 
                           oc$ =  "010"+"0"+"11" + rc(op1$)  : fl$ = "NZ C"
          endif 
          if mn$="CLR" 
                           oc$ =  "010"+"1"+"00" + rc(op1$)  : fl$ = " Z  "
          endif
          if mn$="INC"
                           oc$ =  "010"+"1"+"01" + rc(op1$)  : fl$ = "NZVC"
          endif  
          if mn$="DEC" 
                           oc$ =  "010"+"1"+"10" + rc(op1$)  : fl$ = "NZVC"
          endif  
          if mn$="NOT" 
                           oc$ =  "010"+"1"+"11" + rc(op1$)  : fl$ = "NZ  "
          endif
        otherwise
          oc$ = "00000000"
          fl$ = "    "
      endselect 
      op2$ = "" : hide(op2%)       
    caseof  "AND" , "OR "
      show(op1%) : show(op2%)
      select op1$              
        caseof ".D0.",".D1.",".A0.",".A1."
          select op2$
            caseof ".D0.",".D1.",".A0.",".A1."
              if op1$ = op2$                 ' exclude equality, code for MOV with SR, SP
                oc$ = "00000000"  
                fl$ = "    "
              else
                case mn$="AND": oc$= "011"+"0" + rc(op1$) + rc(op2$)          ' with op1<>op2
                case mn$="OR ": oc$= "011"+"1" + rc(op1$) + rc(op2$)          ' with op1<>op2
                                                                fl$ = "NZ  "
              endif 
            otherwise
              oc$ = "00000000"  
              fl$ = "    "
          endselect  
        otherwise
          oc$ = "00000000"
          fl$ = "    "
      endselect 
    caseof  "ADD", "SUB"
      show(op1%): show(op2%)
      select op1$              
        caseof ".D0.",".D1.",".A0.",".A1."  
          select op2$                   
            caseof ".D0.",".D1.",".A0.",".A1."   
              if op1$ = op2$                 ' exclude equality, code for MOV with SR, SP
                oc$ = "00000000"  
                fl$ = "    "
              else                              '  Attention: order code:
                case mn$="ADD": oc$= "100"+"0" + rc(op1$) + rc(op2$) ' 1.     ' with op1<>op2
                case mn$="SUB": oc$= "101"+"0" + rc(op1$) + rc(op2$) ' 3.     ' with op1<>op2
                                                                fl$ = "NZVC"   
              endif
            caseof "[D0]","[D1]","[A0]","[A1]"   ' 4th bit addressing type Op.2
              case mn$="ADD": oc$= "100"+"1" + rc(op1$) + rc(op2$)   ' 2.
              case mn$="SUB": oc$= "101"+"1" + rc(op1$) + rc(op2$)   ' 4.
                                                              fl$ = "NZVC" 
            otherwise
              oc$ = "00000000"
              fl$ = "    "
          endselect 
        otherwise
          oc$ = "00000000" 
          fl$ = "    "
      endselect 
    caseof  "MOV"                                                    
      show(op1%): show(op2%)  
      select op1$ 
        caseof "[D0]","[D1]","[A0]","[A1]"
          select op2$ 
            caseof ".D0.",".D1.",".A0.",".A1."  
                          oc$ = "110"+"0" + rc(op1$) + rc(op2$) 
                                                            fl$ = "NZ  "
            otherwise                              
              oc$ = "00000000" 
              fl$ = "    "
          endselect         
        caseof ".D0.",".D1.",".A0.",".A1."  
          select op2$  
       
            caseof "[D0]","[D1]","[A0]","[A1]"
                          oc$ = "110"+"1" + rc(op1$) + rc(op2$)
                                                            fl$ = "NZ  "
            caseof ".D0.",".D1.",".A0.",".A1."
              if op1$ = op2$                 ' exclude equality, code for MOV SR <- CC
                oc$ = "00000000"  
                fl$ = "    "
              else     
                          oc$ = "111"+"0" + rc(op1$) + rc(op2$)              ' with op1<>op2
                                                            fl$ = "NZ  "
              endif                                              
      ' !!! from !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                              ' Attention: order code:
            caseof ".SR."
                          oc$= "011"+"0" + rc(op1$) + rc(op1$)     ' Code like AND with double op1 !
                                                            fl$ = "NZ  "
            caseof ".SP."
                          oc$= "011"+"1" + rc(op1$) + rc(op1$)     ' Code like OR with double op1 !
                                                            fl$ = "NZ  "
      ' !!! to !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                                                   
            caseof ".IA."                               
                          oc$ = "111"+"1"+"00" + rc(op1$) : fl$ = "NZ  "   ' op1 is register
            otherwise
              oc$ = "00000000" 
              fl$ = "    "
          endselect  
          
      '!!! from !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        caseof ".SR."
          select op2$ 
            caseof ".D0.",".D1.",".A0.",".A1."
                          oc$= "100"+"0" + rc(op2$) + rc(op2$)     ' Code like ADD with double op2 !
                                                            fl$ = "NZ  "
            caseof ".00.",".01.",".10.",".11."                     ' set IO bits in SR
                          oc$ = "111"+"0" +  mid$(op2$,2,2) + mid$(op2$,2,2) ' Code instead of MOV Rg=Rg !
                                                            fl$ = "    "    ' no flags at IO
            otherwise                              
              oc$ = "00000000" 
              fl$ = "    "
            endselect  
        caseof ".SP."  
          select op2$ 
            caseof ".D0.",".D1.",".A0.",".A1."
                          oc$= "101"+"0" + rc(op2$) + rc(op2$)     ' Code like SUB with double op2 ! 
                                                            fl$ = "NZ  "
            otherwise                              
              oc$ = "00000000" 
              fl$ = "    "
            endselect 
      '!!! to !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
          
        caseof ".IA."                                ' IA 1st operand
          select op2$ 
            caseof ".D0.",".D1.",".A0.",".A1."      
                          oc$ = "111"+"1"+"01" + rc(op2$) : fl$ = "NZ  "   ' op2 is register
            otherwise
              oc$ = "00000000"  
              fl$ = "    "
          endselect
        otherwise
          oc$ = "00000000" 
          fl$ = "    "
      endselect      
    caseof "LOD"                                                            
      show(op1%)
      select op1$
        caseof ".D0.",".D1.",".A0.",".A1."
                          oc$ = "111"+"1"+"10" + rc(op1$) : fl$ = "NZ  "   ' op1 is register  
        otherwise
          oc$ = "00000000" 
          fl$ = "    "
      endselect 
      op2$ = "" : hide(op2%)
    caseof "STO"                                                               
                          oc$ = "111"+"1"+"11"+"00"       : fl$ = " Z  "
      clr_hide12
    caseof "RCL"                                                    
                          oc$ = "111"+"1"+"11"+"01"       : fl$ = " ZV "
      clr_hide12  
    caseof "CPY"                                                  
                          oc$ = "111"+"1"+"11"+"10"       : fl$ = " ZV "
      clr_hide12
    caseof "STP"                                                   
                          oc$ = "111"+"1"+"11"+"11"       : fl$ = "vvvv"
      clr_hide12                                        ' Flags from the pre-command are preserved!
    otherwise // mnemonics
     oc$ = "00000000"
     fl$ = "    "
  endselect
  settext RAM%, coderow%, 2, oc$                            ' insert op code into RAM
  settext RAM%, coderow%, 3, mn$ +" "+ op1$ +" " + op2$     ' insert command/value into RAM
  case (oc$ = "00000000") AND (mn$<>"## "): settext RAM%, coderow%, 3, "NOP"           ' set standard
  case (oc$ = "00000000") AND (mn$="## ") : settext RAM%, coderow%, 3, "##  0000 0000" ' set zero
  settext cadr%, dez_to_hex2(coderow%)                      ' insert code address hexadecimal
  settext oc%  , oc$                                        ' insert Op Code
  settext fl%, fl$                                          ' insert flags
  comment$[coderow%]  = ";"+ opcomm$                        ' Store comment in comment array
endproc
proc define_constant           ' assembler --> data definition
  settext conadr%, dez_to_hex2(conrow%)  
  ansi%   = ord(coninp$)
  if ((ansi%>47) and (ansi%<58)) or ((ansi%=45) and (len(coninp$)>1)) ' decimal digit or minus sign at the beginning
    conval% = val(coninp$)
    conbin$ = dez_to_bin8(conval%)     ' convert to binary number (negative: two's complement)  
    if (conval% > -129) and (conval% < 128) 
      settext conalt%, str$( val("%"+ dez_to_bin8(conval%)) )  ' alternative representation of the input character/number
      settext conans%, chr$(conval%) ' display character
    else      ' --- numeric input: < -128 or > 127 -> OVERFLOW -> set to zero ---
      coninp$ = "0"
      conbin$ = "00000000"
      settext coninp%,coninp$  
      settext conalt%,""
      settext conans%,""   
    endif
  elseif ( (ansi%=36) or (ansi%=72) or (ansi%=104) ) and (len(coninp$)=3)  ' $ or H or h at the beginning: Hexadecimal number
    conbin$ = hex2_to_bin8(mid$(coninp$,2,2))                ' hexadecimal number to binary number 
    conval% = val("%"+ conbin$)                              ' corrected input value (letter above F, f to 0)
    settext conalt%, str$( val("%"+ dez_to_bin8(conval%)) )  ' alternative representation of the input character/number
    settext conans%, chr$(conval%)                           ' display character
  else                ' input of a keyboard character
    if len(coninp$)=1        
      conbin$ = d255_to_bin8(ansi%)                      ' ANSI code of the character binary
      settext conalt%, str$(bin8_to_dez(conbin$ ))       ' value of the character
      settext conans%, str$(ansi%)                       ' ANSI code of the character decimal
    else   ' more than one character
      coninp$ = "0"
      conbin$ = "00000000"
      settext conalt%,""
      settext conans%,""
    endif 
  endif  
  settext conbin%, conbin$                               ' display binary 
  settext conhex%, bin8_to_hex2(conbin$)                 ' display hexadecimal
  settext RAM%, conrow%, 2, conbin$                      ' store in binary form in RAM
  sp_h$ = space$(5-len(coninp$)) +"h"                    ' varying spaces before h for hexadecimal value 
  settext RAM%,conrow%,3,coninp$+sp_h$+gettext$(conhex%) ' display value in RAM 
  comment$[conrow%]  = ";"+concomm$                      ' store constant comment in comment array
endproc
'{--- auxiliary procedures program run ---
proc ram_adr_cykl                     ' Intercept RAM area overflow, address cyclically in RAM
    case (row% > 255) : row% = row% - 256    
    case (row% <   0) : row% = row% + 256    
endproc    
proc set_IC                           ' set Instruction Counter  (cyclic)
  ' catch jump error/RAM range overflow:
  case (ic_dez% > 255) : ic_dez% = ic_dez% - 256  ' program execution cyclically in RAM
  case (ic_dez% <   0) : ic_dez% = ic_dez% + 256  ' program execution cyclically in RAM                 ' 
  settext IC%, d255_to_bin8(ic_dez%)              ' set instruction counter
endproc
proc show_set_IC                      ' show:   IC manual input 
  textcolor black% , chipc%   
  drawtext 540,386,"    set" 
  show(set_IC%)
  drawtext 581,402,"hex"
endproc
proc hide_set_IC                      ' hide: IC manual input  
  textcolor black% , chipc%      
  drawtext 540,386,"            " 
  hide(set_IC%)
  drawtext 581,402,"      "
endproc
proc set_D1                           ' make the entry in D1 visible for store/copy commands (clock)
  parameters bytewert$
    settext R%[1], bytewert$                                                ' put down in D1  
  '.............................. Display ................. 
    if fullspeed% = 0                                
      ms% = 10000 \(2*10*takt!)    ' 2-fold intermediate clock in milliseconds for display in D1 
      settimer ms% 
      timeover% = 0
      repeat
         case  %wmTimer   : timeover% = 1
      until timeover% 
      set_clock            ' CPU time set
    endif ' ...................................................
endproc
proc push_b_res                       ' put result byte on stack
  temp%  = bin8_to_dez(b_res$)
  settext RAM%, starow% , 2, b_res$                                         '  binary
  sp_h$ = space$(5-len(str$(temp%))) +"h"  ' varying spaces before h for hexadecimal value 
  settext RAM%, starow% , 3, str$(temp%) + sp_h$ + bin8_to_hex2(b_res$)     '  decimal hexadecimal
endproc
proc shift_ALRx                       ' ALU multiplication according to Booth: ALR_ARL_ALx >> shift by 1 bit
  settext booth%, str$(&loop)+chr$(187)+" Booth"
  settext ALx%  , right$(gettext$(ARL%),1)
  settext ARL% , right$(gettext$(ALR%),1) + left$(gettext$(ARL%),7)
  settext ALR%  , chr$(187)+mid$(gettext$(ALR%),2,1) + mid$(gettext$(ALR%),2,7)   ' >> shift by 1 bit
endproc 
proc ALU_bitstep                      ' intermediate step (clock) ALU bitwise
  if fullspeed% = 0 
    if  getcheck(alu_bitw%) 
      bit_pulse(2)
    endif
  endif  
endproc 
proc ALU_step                         ' intermediate step (takt) ALU
  case fullspeed% = 0 : clock_pulse(2)
endproc 
'}
'{--- Micro Graphic Adapter (MGA) ----

proc mga_display                      ' Micro-Graphic-Adapter: display from RAM
  declare x%, y%, i%, j%
  x% = Mx%-Md%\2
  y% = My%-Md%\2
  i% = 1
  repeat
    mga$[i%] = gettext$(RAM%, 247 + i% , 2)
    j% = 1
    repeat
      if mid$(mga$[i%], j%, 1) = "0"
        usebrush 1, white%
      else
        usebrush 1, black%
      endif
      fill x% + j%*Md% ,  y% + i%*Md% , grey%   ' fill maxipixel with white/black
      inc j%
    until j% = 9 
    inc i%
  until i% = 9
endproc
proc click_mga                        ' click in the MGA display
  var btmp1$ = ""
  var btmp2$ = ""
  var tmp% = 0
 ' write pixel address and status into RAM byte 247 = hF7 (NOTE! -1 -> store as values 0 to 7)
  mgarow$ = gettext$(RAM%, 247 + ip% , 2) '  ' get MGA row from RAM ...
  pix$  = mid$(mgarow$,jp%,1)             ' ... therein pixel in column jp (1 to 8)
  btmp1$ = pix$ +  dez_to_bin3(ip%-1) + mk$  +  dez_to_bin3(jp%-1) ' generate MGA address/pixel row ...
  settext RAM%, 247, 2, btmp1$ '                                   ' ... write into RAM (addr hF7) in binary form
  tmp% = bin8_to_dez(btmp1$)
  btmp2$ = str$(tmp%) 
  sp_h$ = space$(5-len(btmp2$ )) +"h"                           ' varying spaces before h for hexadecimal value  
  settext RAM%, 247, 3, btmp2$ + sp_h$ + bin8_to_hex2(btmp1$)  ' write value decimal, hexadecimal 
endproc 
proc refresh_mga                      ' Refresh MGA display after change
  var btmp1$ = ""
  var btmp2$ = ""
  var tmp% = 0
  if mgapix$ <> left$(gettext$(RAM%, 247,2) ,4)+"m"+right$(gettext$(RAM%, 247,2), 3)
   ' pixel address row in RAM byte 247 = hF7 has changed (without mouse!)
    mgapix$ = gettext$(RAM%, 247,2)   ' new take over
    ip%     = val("%"+ mid$(mgapix$,2,3)) + 1    ' row  (No. 1 to 8)
    jp%     = val("%"+ mid$(mgapix$,6,3)) + 1    ' column (No. 1 to 8)
    pix$    = left$(mgapix$, 1, 1)               ' 
    mgarow$   = gettext$(RAM%, 247 + ip% , 2)      ' get MGA row from RAM
    mgarow$   = left$(mgarow$,jp%-1) + pix$ + right$(mgarow$,8-jp%) ' generate new MGA row  ... 
    settext RAM%, 247 + ip%, 2, mgarow$                         ' ... write into RAM binary  
    tmp% = bin8_to_dez(mgarow$)
    btmp1$ = str$(tmp%) 
    sp_h$ = space$(5-len(btmp1$ )) +"h"                      ' varying spaces before h for hexadecimal value 
    settext RAM%, 247 + ip%, 3, btmp1$ + sp_h$ + bin8_to_hex2(mgarow$) ' write value decimal, hexadecimal
  endif
  whileloop 1, 8                        
    if mga$[ &loop] <> gettext$(RAM%, 247 + &loop , 2) ' when a display row is changed
      mga_display      ' Micro-Graphic-Adapter: create and display the entire display from RAM ...
      break            ' ... then abort
    endif 
  endwhile
endproc 
'}
proc run_binary_code           ' program run of the machine program (8 bit binary code)
' --- initialization program run ---
  debugfile$ = gettext$(debugfn%)           ' debug filename
  if len(debugfn%) = 0
    debugfile$ = savefile$("store debug","HC680 Debug  (*.txt)| *.txt")
  endif  
  assign #8,debugfile$
  rewrite #8                                ' overwrite possibly existing file
  debug$ = "IC; Bin.Code; Assembler    ; SR/Flags; D0;SD0; D1;SD1; A0;SA0; A1;SA1; SP;[SP; Ta; Pix"
  print #8,debug$                           ' always write header
  '
  hide_assembler_controls
  '
  hide(clrio%)                              ' button IO protocol (delete, hide)
                          'hide(shio%)      ' checkbox IO protocol - hide ???
  hide(shcache%)                            ' checkbox CACHE ( hide )
  hide(xram%)                               ' delete-button  RAM (hide)
  hide(xflag%) 
  '
  if htt%
    settext toolRAM%, %hwnd, RAM%, ""       ' empty tooltip for RAM (annoying when running the program)
  endif
  show(CACHE%)                              ' CACHE show
  show(inp%)                                ' Show keyboard input
  textcolor darkred%, backgrdc%             ' dark red font
  drawtext 390,100, "  halt          "
  usebrush 1,grey%                          ' Run knob gray
  fill 415,85,black%
  halt%     = 0                             ' Hold program by operator: 1
  stop%     = 0                             ' after STP command: 1
  break%    = 0                             ' operator abort with X STOP: 1
  break123% = 0                             ' after one of the three breakpoints: 1
  onestep%  = 0                             ' for the time being no step further with single step                  
  whileloop 0,3   
    settext R%[&loop],"00000000"            ' initialize D and A register with 0
    settext S%[&loop],"00000000"            ' initialize SD and SA registers with 0
  endwhile  
  settext IR%, "00000000"                   ' No Operation in IR
  hide_set_IC                               ' set IC - hide with text
  ' --- IC is set in advance (in the event loop) ---
  ic_dez% = val("%"+gettext$(IC%))          ' determine decimal start address (binary code) in RAM from IC
  settext SP%,"11110101"                    ' set stack pointer: Addr. 245 = hF5 ...
  starow% = 245                             ' ... and decimal in background variable of the SP
  settext RAM%, 245,4,"<-SP"                ' ... and marking in the RAM
  settext SR%, "00000000"                   ' Status register both nibble to 0
  flags_0_0_0_0    ' all single flags zero  ' N-Flag (negative)
  '                                         ' Z-Flag (zero )
  '                                         ' V-Flag (overflow) 
  '                                         ' C-Flag (carry)
 '------------
  repeat ' ---  decode and execute 8 bit machine instructions from RAM  ---
    ' ---  prepare command execution  ---
    ' Takt/clock with factor 1, event request for Halt/ Continue/ Single step/ Breakpoints/ Debug/ MGA display.
    clock_pulse(1)  ' also important at fullspeed = 1 to reduce the clock rate
    if break% = 1 
      break
    endif 
    ' ------------
    ic_dez% = val("%"+gettext$(IC%))        ' determine decimal address of the command in RAM from IC
    ic_dez_fl% = ic_dez%                    ' remember address for entry of flags set by command
    settext set_IC%, bin8_to_hex2(gettext$(IC%))  ' current IC hexadecimal in edit control
    selectstring(RAM%, -1, gettext$(IC%))   ' mark current command line in RAM
    '-------------
     if getcheck(debug%)    ' ' write into debug file
      debug$ = gettext$(RAM%,ic_dez%,1)+"; " + gettext$(RAM%,ic_dez%,2)+"; "                     ' address (IC) hex; ' binary code                                 
      debug$ = debug$ + gettext$(RAM%,ic_dez%,3)+ space$(13-len(gettext$(RAM%,ic_dez%,3)))+"; "  ' assembler  
      debug$ = debug$ + gettext$(SR%)+ "; "                                                      ' status register (flags)
      '
      debug$ = debug$ + bin8_to_hex2(gettext$(R%[0]))+"; "+ bin8_to_hex2(gettext$(S%[0]))+"; "   ' registers and shadow registers
      debug$ = debug$ + bin8_to_hex2(gettext$(R%[1]))+"; "+ bin8_to_hex2(gettext$(S%[1]))+"; "
      debug$ = debug$ + bin8_to_hex2(gettext$(R%[2]))+"; "+ bin8_to_hex2(gettext$(S%[2]))+"; " 
      debug$ = debug$ + bin8_to_hex2(gettext$(R%[3]))+"; "+ bin8_to_hex2(gettext$(S%[3]))+"; "
      '
      debug$ = debug$ + bin8_to_hex2(gettext$(SP%))+ "; " + bin8_to_hex2(gettext$(RAM%,val("%"+gettext$(SP%)),2))+"; " ' Stack pointer and content
      debug$ = debug$ + bin8_to_hex2(gettext$(RAM%,246,2))+"; "+ gettext$(RAM%,247 ,2)            ' keyboard byte hex; MGA pixel binary 
      print #8,debug$
    endif
    ' ------------
    if comment$[ic_dez%] = ";"              ' if there is no command comment
      settext opcomm%, "; "                 ' show only comment characters with spaces
    else                                    '  otherwise
      settext opcomm%, mid$(comment$[ic_dez%],2,254)          ' insert current command comment without ; 
    endif
    settext toolopcomm%, %hwnd, opcomm%, comment$[ic_dez%]    ' tooltip current to comment (full length readable!)
    ' -----------
    IO_SR$ = left$(gettext$(SR%),2)         ' type of data IO, left two bits in status register
    N$     = mid$(gettext$(SR%),5,1)        ' read out flags from the status register
    Z$     = mid$(gettext$(SR%),6,1)  
    V$     = mid$(gettext$(SR%),7,1)  
    C$     = mid$(gettext$(SR%),8,1) 
    ' ------------
    oc$ = gettext$(RAM%,ic_dez%,2)          ' read out 8 bit instruction (operation code/machine instruction with operands) ...
    whileloop 0,15                          '  ... 16 surrounding commands transferred to the cache
      settext CACHE%,&loop ,1,gettext$(RAM%,ic_dez% + &loop - 7 ,2)               
    endwhile
    settext CACHE%,7,0,">"                  ' mark current command: >
    settext IR%, oc$                        ' write opcode/machine instruction into the Instruction Register   
    ' --------------
    ' Operationscode gliedern:
    ocg$   =  left$(oc$,3)                  ' Opcode Bit 1|2|3 (code group)
    ocb$   =   mid$(oc$,4,1)                ' Opcode bit 4 (addressing type/ command variants)
    ocyy$  =   mid$(oc$,5,2)                ' Opcode Bit 5|6 (partly destination register)
    ocxx$  = right$(oc$,2)                  ' Opcode Bit 7|8 (partly source register)
    ry%    = val("%"+ocyy$)                 ' yy decimal (partly index of the register field)  
    rx%    = val("%"+ocxx$)                 ' xx decimal (partly index of the register field)
    ' --- analyze opcode --- decode/execute command   ---
    select ocg$        '  3-digit groups                
      caseof "000"                     
        select ocb$    ' bit
          caseof    "0" ' = ocb$         ' Code right 4 bit fixed - without operand/register specification
            ocyyxx$ = ocyy$+" "+ocxx$    '       space for grouping - better overview
            select ocyyxx$ 
                                         '         ocg b yy xx   <-- grouping operation code/ 8 bit machine instruction
                                  ' mn             --- - -- --   '   _XXX  command execution   machine command in command procedure 
              caseof "00 00"                    
                _NOP              ' NOP          ' 000 0 00 00	   No OPeration          
              caseof "00 01"                                                               
                _CMP              ' CMP          ' 000 0 00 01	   CoMPare D0, D1 (D0-D1)
              caseof "00 10"                   
                _SWD              ' SWD          ' 000 0 00 10	   SWap D0, D1
              caseof "00 11"               
                _SWM              ' SWM          ' 000 0 00 11	   SWap Memory Adr(D0), Adr(D1)
              caseof "01 00"                    
                _MUL              ' MUL          ' 000 0 01 00	   MULtiplication D0 <- D0*D1
              caseof "01 01"                     
                _DIV              ' DIV          ' 000 0 01 01	   DIVision D0 <- D0\D1	integer
              caseof "01 10"                     
                _PSA              ' PSA          ' 000 0 01 10	   PuSh All Stack <- A,D,SR Reg.	
              caseof "01 11"                     
                _POA              ' POA          ' 000 0 01 11	   POp All SR,D,A  Reg. <- Stack
              caseof "10 00"                
                _JSR              ' JSR          ' 000 0 10 00	   Jump SubRoutine Stack<-IC+1, A0=0: IC<-IC+A1 else IC<-A0+A1+ST
                                       ' ATTENTION!        Observe order of the opcode!  
              caseof "11 00"      ' RET          ' 000 0 11 00  	 RETturn subroutine IC <-Stack                     
                _RET                            
              caseof "10 01" , "11 01"           
                _JIN              ' JIN +A   	   ' 000 0 10 01	   N=1: IC <- IC + A1	      Jump If Negative    
                                  ' JIN IA	     ' 000 0 11 01     N=1: IC <- A0 + A1 + ST  Jump If Negative
              caseof "10 10" , "11 10"            
                _JIZ              ' JIZ +A       ' 000 0 10 10     Z=1: IC <- IC + A1	      Jump If Zero
                                  ' JIZ IA       ' 000 0 11 10     Z=1: IC <- A0 + A1	+ ST  Jump If Zero
              caseof "10 11" , "11 11"                                       
                _JMP              ' JMP +A       ' 000 0 10 11	        IC <- IC + A1	      JuMP
                                  ' JMP IA       ' 000 0 11 11	        IC <- A0 + A1	+ ST  JuMP  
            endselect ' ocyyxx$            
          caseof    "1"   ' = ocb$                        ' code right 2 bit operand register xx 
          
            if  ocyy$ = "00"                                        
              _LDC                ' LDC RG       ' 000 1 00 xx     LoaD Constant Register   Reg xx <- next Byte ##        
            else ' ocyy$ 
              _JIN_JIZ_JUMP_Reg   ' JIN RG 	     ' 000 1 01 xx 	   N=1: IC <- Reg xx	  Jump If Negative
                                  ' JIZ RG	     ' 000 1 10 xx  	 Z=1: IC <- Reg xx	  Jump If Zero
                                  ' JMP RG 	     ' 000 1 11 xx          IC <- Reg xx	  JuMP
            endif
        endselect ' ocb$
      caseof "001"   
        select ocb$
          caseof "0"
            select ocyy$                   
              caseof "00"    
                _INP               ' INP RG      ' 001 0 00 xx     Reg xx      <- INPut
              caseof "01"                       
                _OUT               ' OUT RG      ' 001 0 01 xx     OUTput      <- Reg xx
              caseof "10"                    
                _PSH               ' PSH RG	     ' 001 0 10 xx     PuSH  Stack <- Reg xx 
              caseof "11"                      
                _POP               ' POP RG	     ' 001 0 11 xx     POP  Reg xx <- Stack  
            endselect ' ocyy$ 
          caseof "1"
            select ocyy$                   
              caseof "00" 
                _SSR               ' SSR RG      ' 001 1 00 xx    Set Shadow Register  Reg xx -> Sxx  (SDx, SAx)
              caseof "01"   
                _GSR               ' GSR RG      ' 001 1 01 xx    Get Shadow Register  Reg xx <- Sxx  (SDx, SAx)
              caseof "10"
                _BTS               ' BTS RG      ' 001 1 10 xx    BitTest Reg xx with Shadowregister
              caseof "11"
                _SWN               ' SWN RG      ' 001 1 11 xx    SWap Nibble  Reg xx
            endselect ' ocyy$     
        endselect  'ocb$ 
      caseof "010"
        select ocb$
          caseof "0"
            select ocyy$
              caseof "00"                         
                _SHL              ' SHL RG	     ' 010 0 00 xx   SHift Left   Reg xx
              caseof "01"                         
                _SHR              ' SHR RG	     ' 010 0 01 xx   SHift Right  Reg xx
              caseof "10"                         
                _ROL              ' ROL RG       ' 010 0 10 xx   ROtate Left  Reg xx
              caseof "11"                         
                _ROR              ' ROR RG	     ' 010 0 11 xx   ROtate Right Reg xx
            endselect ' ocyy$ 
          caseof "1"
            select ocyy$
              caseof "00"                         
                _CLR              ' CLR RG	     ' 010 1 00 xx   CLear Register Reg xx <- 0
              caseof "01" , "10"                  
                _INC_DEC          ' INC RG	     ' 010 1 01 xx   INCrement Reg xx  
                                  ' DEC RG	     ' 010 1 10 xx   DECrement Reg xx   
              caseof "11"                         
                _NOT              ' NOT RG	     ' 010 1 11 xx   Reg xx <- NOT Reg xx (bitwise)
            endselect ' ocyy$
        endselect ' ocb$
      caseof "011"   
        if ocyy$ = ocxx$
          _MOV_SRSP               ' MOV RG  SR   ' 011 0 yy yy   MOVe      Reg yy <-  SR    *1) xx=yy
                                  ' MOV RG  SP   ' 011 1 yy yy   MOVe      Reg yy <-  SP    *2) xx=yy
        else
          _AND_OR                 ' AND RG  RG	 ' 011 0 yy xx   Reg yy <- Reg yy AND Reg xx,  xx<>yy
                                  ' OR  RG  RG	 ' 011 1 yy xx   Reg yy <- Reg yy OR  Reg xx,  xx<>yy
        endif                          
      caseof "100"  
        if ocyy$ = ocxx$
          _MOV_SRSP               ' MOV SR  RG 	 ' 100 0 xx xx	 MOVe      SR <- Reg xx     *3) xx=yy
        else
          _ADD                    ' ADD RG  RG	 ' 100 0 yy xx   Reg yy <- Reg yy + Reg xx,    xx<>yy
                                  ' ADD RG  [RG] ' 100 1 yy xx   Reg yy <- Reg yy + Adr(Reg xx)
        endif                          
      caseof "101"
        if ocyy$ = ocxx$
          _MOV_SRSP               ' MOV SP  RG 	 ' 101 0 xx xx   MOVe      SP <- Reg xx     *4) xx=yy 
        else  
          _SUB                    ' SUB RG  RG	 ' 101 0 yy xx   Reg yy <- Reg yy - Reg xx,    xx<>yy
                                  ' SUB RG  [RG] ' 101 1 yy xx   Reg yy <- Reg yy - Adr(Reg xx)
        endif                          
      caseof "110"     
        _MOV_RAM                  ' MOV [RG] RG	 ' 110 0 yy xx   MOVe Adr(Reg yy) <- Reg xx, 
                                  ' MOV RG  [RG] ' 110 1 yy xx   MOVe     Reg yy  <- Adr(Reg xx)
      caseof "111"              
        if ocb$ = "0" 
          if ocyy$ = ocxx$
            _MOV_SRCC
                                   ' MOV SR  CC	 ' 111 0 CC CC	 MOVe      SR <- CC..       *5) xx=yy 2Bit IO        
          else
            _MOV_REG               ' MOV RG  RG  ' 111 0 yy xx   MOVe     Reg yy  <- Reg xx,    xx<>yy 
          endif
        endif ' ocb$ = "0"     
        if ocb$ = "1"     
          select ocyy$
            caseof "00" , "01"                            
              _MOV_IA              ' MOV RG  IA  ' 111 1 00 xx   MOVe     Reg xx   <- Adr(A0+A1+ST)
                                   ' MOV IA  RG  ' 111 1 01 xx   MOVe Adr(A0+A1+ST)<- Reg xx  
            caseof "10"                                
              _LOD                 ' LOD RG	     ' 111 1 10 xx   LOad Data Reg xx  <- Adr(h80+A1+ST)
            caseof "11"      ' Code right 2 bit fixed: 4 single commands (without register specification)
              select ocxx$
                caseof "00"                       
                  _STO	           ' STO (IO)    ' 111 1 11 00   STOre   file <- Adr(h80+A1+ST) D0 byte, via D1 (type: IO) 
                caseof "01"       
                  _RCL             ' RCL (IO)    ' 111 1 11 01   ReCalL  Adr(h80+A1+ST) <- file  via D1 (type: IO)  /D0 Byte readed
                caseof "10"                      
                  _CPY	           ' CPY	       ' 111 1 11 10   CoPY Adr(A1)<-Adr(A0)    D0 byte via D1
                caseof "11"                         
                  _STP             ' STP         ' 111 1 11 11   StoP   stop program
              endselect ' ocxx$
          endselect ' ocyy$
        endif ' ocb$ = "1"         
      otherwise ' ocg$             ' error/ no command
        stop% = 1                          ' cancel program
        usebrush 1,red%            ' run knob red
        fill 415,85,black%
        messagebox("No valid command   ","error",48)
        inc ic_dez%
    endselect ' ocg$
    flags_latest                 ' show last set flags after command execution behind assembler
    register_tooltip             ' update tooltips with decimal and hexadecimal contents of registers  
  until 0                        ' abort with [X] STOP: break% = 1 --> break   
  ' ----------  finalization program run      -------------------------------------------------------
  whileloop 0,3   
    settext R%[&loop],"00000000"            ' initialize D,A registers with 0 
    settext S%[&loop],"00000000"            ' Initialize SD,SA registers with 0
  endwhile  
  settext IR%, "00000000"                   ' No Operation in Instruction Register
        ' IC  -->    is set in event loop                             
  settext opcomm%, mid$(comment$[0],2,254)  ' insert comment for top program line
  settext SR%, "00000000"                   ' status register both nibble to 0
  flags_0_0_0_0    ' alle Einzelflags Null  ' N-Flag (negative),
  settext RAM%, starow%, 4,"    "           ' stack pointer delete current marker
  settext SP%,"11110101"                    ' set stack pointer to base address: Addr. 245 = hF5 ...
  starow% = 245                             ' ... and decimal in background variable of the SP
  settext RAM%, 245,4,"<-SP"                ' ... and new mark in RAM
  register_tooltip                          ' update tooltips of the registers 
  if htt%
    settext toolRAM%, %hwnd, RAM%, toolRAM$   ' fill tooltip for RAM again
    settext toolSRval%, %hwnd, SRval%, SRhlp$ ' reset tooltip for status register
  endif  
                'setcheck shio%, 1                         ' status: IO protocol visible
  show(xram%)                               ' show  the delete button  RAM  again
  show(xflag%)                              ' show  the delete button  Flags  again
  show(clrio%)                              ' show  the Clear IO protocol button
                'show(shio%)                               ' Checkbox IO-Protokol  - show
  show(shcache%)                            ' Checkbox CACHE  - show
  '
  hide(inp%)                                'hide keyboard input
  ' show again after fullspeed > 255HZ
  show(AL1%)                                ' show ALU 
  show(AL2%)
  show(ALC%)
  show(ALR%)
  show(alu_bitw%)                           ' show ALU bitwise
  show(breakpt1%)                           ' breakpoints                        
  show(breakpt2%) 
  show(breakpt3%) 
  show(debug%)                              ' debug 
  show(debugfn%)                            ' filename debug  
  show(CACHE%)                              ' CACHE 
  show_assembler_controls                   ' assembler controls 
  usebrush 1,richgreen%                     ' run knob rich green
  fill 415,85,black%
  textcolor black%,backgrdc%
  drawtext 390,100, "  execute           "
  hide(nextstep%)                           ' hide after STOP at single step
  close #8                                  ' close debug file
endproc
'{*** execution HC680 binary code - machine commands ***
 '
         ' Mnem Op1 Op2     machine command    effect/meaning
         '                   ocg b yy xx
           '                 --- - -- --
proc _NOP  ' NOP           ' 000 0 00 00	 No OPeration
  flags_0_0_0_0 
  inc ic_dez%                                  
  set_IC                                      ' only one command forward
endproc  
proc _CMP  ' CMP           ' 000 0 00 01	 CoMPare D0, D1 (D0-D1)
  settext AL1%, gettext$(R%[1])                ' put D1 in ALU
  complement1_ALU                              ' form one's complement of AL1
  settext AL1%, "00000001"                     ' 1 for addition in 1st operand
  settext AL2%,  b_res$                        ' set result in 2nd operand
  add_ALU_9                                    ' form two's complement by addition
  settext AL1%, gettext$(R%[0])                ' D0
  settext AL2%, b_res$                         '    -D1   for comparison ( bottom value in ALU is subtracted)                        
  add_ALU_9                                    ' Execute comparison D0+(-D1) in the ALU (with flags)
  inc ic_dez%                                  ' Result of subtraction is discarded - flags only
  set_IC
endproc                            	
proc _SWD  ' SWD           ' 000 0 00 10	 SWap D0, D1
  b_res$ = gettext$(R%[0])
  settext R%[0], gettext$(R%[1])
  settext R%[1], b_res$
  flags_0_0_0_0 
  inc ic_dez%                       
  set_IC                          
endproc
proc _SWM  ' SWM           ' 000 0 00 11	 SWap Memory Adr(D0), Adr(D1)
  row%    = val("%"+gettext$(R%[0]))  
  temp%   = val("%"+gettext$(R%[1])) 
  btemp1$ = gettext$(RAM%, row%  ,2)
  btemp2$ = gettext$(RAM%, temp% ,2)
  settext RAM%, row%,  2, btemp2$      ' binary enter
  sp_h$ = space$(5-len(str$(bin8_to_dez(btemp2$ )))) +"h"     ' variable spaces before h for hexadecimal value
  settext RAM%, row%, 3, str$(bin8_to_dez(btemp2$ )) + sp_h$ + bin8_to_hex2(btemp2$  )    ' dec. hex insert      
  settext RAM%, temp%, 2, btemp1$      ' binary enter
  sp_h$ = space$(5-len(str$(bin8_to_dez(btemp1$)))) +"h"     ' variable spaces before h for hexadecimal value
  settext RAM%, temp%, 3, str$(bin8_to_dez(btemp1$)) + sp_h$ + bin8_to_hex2(btemp1$ )    ' dec. hex insert
  flags_0_0_0_0 
  inc ic_dez%                       
  set_IC                          
endproc
proc _MUL  ' MUL           ' 000 0 01 00	 MULtiplication D0 <- D0*D1
  var tmp% = 0      ' local
  tmp%   = bin8_to_dez(gettext$(R%[0]) )*bin8_to_dez(gettext$(R%[1])) ' decimal result of the mutiplication
  '
  if fullspeed% = 0   
    mul_Booth_ALU                     ' --- Display Booth algorithm in the ALU (without flags)
  endif   
  '
  if (tmp% > -129) and (tmp% < 128) ' result in the area
    b_res$  = dez_to_bin8(tmp%)
    flags_b_res_N_Z_0_0
  else 
    b_res$ = right$(bin$(tmp%), 8)   ' corresponds to low byte ALM of ALR,ARL
    N$ =  "0"
    Z$ =  "0"
    V$ =  "1"                        ' oVerflow - set flag 
    if tmp% > 255                    ' carry, if one assumes unsigned operands
      C$ = "1"  
    else
      C$ = "0"  
    endif
    settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$    ' Set status register with flags
  endif 
  '
  settext R%[0], b_res$               ' enter result into D0
  inc ic_dez% 
  set_IC
endproc
proc _DIV  ' DIV           ' 000 0 01 01	 DIVision D0 <- D0\D1	remainder SD0
  if val("%"+gettext$(R%[1])) = 0     ' Catch division by 0
    ' D0, SD0    remain unchanged 
    N$="0"
    Z$="0"
    V$="1"                            ' set oVerflow flag
    C$="0"                           
    settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$    ' set status register with flags 
    messagebox("Command was not executed. \nThe V-flag is set."," --- Division by 0 --- ",48)  
  else 
    if fullspeed% = 0
        div_ALU                       ' demonstrate binary division in ALU, results in D0 and remainder in SD0
        '                             ' flags are set in div_ALU
    else // fast calculation (but adjust -128)
      if (val("%"+gettext$(R%[0])) = -128) or (val("%"+gettext$(R%[1])) = -128) ' OVERFLOW +128 for two's complement in ALU! 
        ' D0, SD0 remain unchanged
        N$="0"
        Z$="0"
        V$="1"                        ' set oVerflow flag   
        C$="0"                            
        settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$    ' set status register with flags  
      else
        ' decimal remainder -> insert into shadow register SD0   
        settext S%[0], dez_to_bin8( bin8_to_dez(gettext$(R%[0])) MOD bin8_to_dez(gettext$(R%[1])) ) 
        ' 
        ' decimal quotient -> insert into b_res$ for flags and into D0      
        b_res$    =    dez_to_bin8( bin8_to_dez(gettext$(R%[0])) \ bin8_to_dez(gettext$(R%[1])) ) 
        settext R%[0], b_res$ 
        flags_b_res_N_Z_0_0
      endif  
    endif
    '
  endif
  inc ic_dez%
  set_IC
endproc
proc _PSA  ' PSA           ' 000 0 01 10	 PuSh All Stack <- A,D,SR Reg.
  ' push all four address and data registers and SR on the stack 
  settext RAM%, starow%, 4,"    "        ' delete old pointer for position stack pointer 
  b_res$  = gettext$(R%[3])    
  push_b_res                 ' A1
  dec starow% 
  b_res$  = gettext$(R%[2])    
  push_b_res                 ' A0
  dec starow% 
  b_res$  = gettext$(R%[1])   
  push_b_res                 ' D1
  dec starow% 
  b_res$  = gettext$(R%[0])   
  push_b_res                 ' D0
  dec starow% 
  b_res$  = gettext$(SR%)   
  push_b_res                 ' SR
  dec starow% 
  settext SP%, d255_to_bin8(starow%)     ' enter current address into SP
  settext RAM%, starow%, 4,"<-SP"        ' set indicator for position stack pointer 
  flags_0_0_0_0                          ' set all flags to zero
  inc ic_dez%
  set_IC
endproc
proc _POA  ' POA           ' 000 0 01 11	 POp All SR,D,A Reg. <- Stack                     
  ' get all four data and address registers and SR from the stack
  if starow% < 251                          ' SR and 4 registers ...
    settext RAM%, starow%, 4,"    "         '    delete old pointer for position stack pointer
    inc starow%                             ' ... stack pointer each 1 direction RAM end
    settext SP%, d255_to_bin8(starow%)      ' set SP to top entry in stack memory
    settext SR%, gettext$(RAM%,starow%,2)   ' SR   
    inc starow%
    settext R%[0], gettext$(RAM%,starow%,2) ' D0   
    inc starow%
    settext R%[1], gettext$(RAM%,starow%,2) ' D1   
    inc starow%
    settext R%[2], gettext$(RAM%,starow%,2) ' A0   
    inc starow%
    settext R%[3], gettext$(RAM%,starow%,2) ' A1   
    settext SP%, d255_to_bin8(starow%)      ' enter current address in SP
    settext RAM%, starow%, 4,"<-SP"         ' set indicator for position stack pointer
  else
    messagebox("error:        RAM end reached!"," --- stack-error ---",48)
    stop% = 1 
  endif  
  ' separate flags from stack into SR for display
   N$ = mid$(gettext$(SR%),5,1)
   Z$ = mid$(gettext$(SR%),6,1)
   V$ = mid$(gettext$(SR%),7,1)
   C$ = mid$(gettext$(SR%),8,1)
  inc ic_dez%
  set_IC
endproc
proc _JSR  ' JSR           ' 000 0 10 00	 Jump SubRoutine Stack<-IC+1, A0=0: IC<-IC+A1 else IC<-A0+A1+ST
  temp% = ic_dez%  + 1                ' return address  IC+1                      
  b_res$ = d255_to_bin8(temp%)
  settext RAM%, starow% , 2, b_res$   ' return address  IC+1 to stack ' binary    
  sp_h$ = space$(5-len(str$(temp%))) + "h"                               ' variable spaces before h for hexadecimal value  
  settext RAM%, starow% , 3, str$(temp%) + sp_h$ + bin8_to_hex2(b_res$)  ' decimal  hexadecimal
  settext RAM%, starow%, 4,"    "     ' delete old indicator for position stack pointer 
  dec starow%                         ' by 1 smaller address in the stack ...
  settext SP%, d255_to_bin8(starow%)  ' ... insert in the stack pointer   
  settext RAM%, starow%  , 4,"<-SP"   ' set indicator for position stack pointer
  flags_0_0_0_0                       ' set all flags to zero 
  if gettext$(R%[2])="00000000"                                                         ' A1 signed
    ic_dez% = ic_dez% + bin8_to_dez(gettext$(R%[3]))           ' if A0 = 0: IC <- IC + A1   jump to subroutine
  else
    ic_dez% = val("%"+gettext$(R%[2])) + bin8_to_dez(gettext$(R%[3])) + sta% ' IC <- A0 + A1 + ST jump to subroutine
  endif
  set_IC                                                             
endproc
proc _RET  ' RET           ' 000 0 11 00   RETturn subroutine      IC <- Stack
  if starow% < 255                      ' not yet at the end of memory
    settext RAM%, starow%, 4,"    "     ' delete old indicator for position stack pointer
    inc starow%                         ' ... stack pointer 1 direction each End RAM 
    settext SP%, d255_to_bin8(starow%)  ' SP on top entry
    settext RAM%, starow% , 4,"<-SP"    ' set indicator for position stack pointer
    ic_dez% = val("%"+gettext$(RAM%,starow%,2) )  ' decimal return address from stack ...
    set_IC                                        ' ... set in IC
  else
     messagebox("error:       RAM end reached!"," --- stack-error ---",48)
    stop% = 1 
  endif  
  flags_0_0_0_0                              ' set all flags to zero 
endproc
           ' JIN +A        ' 000 0 10 01	 N=1: IC <- IC + A1	      Jump If Negative    
proc _JIN  ' JIN IA	       ' 000 0 11 01   N=1: IC <- A0 + A1 + ST	Jump If Negative
  if N$ = "1"                                ' if N-Flag = 1                                           ' A1 signed
    case ocyy$="10": ic_dez% = ic_dez% + bin8_to_dez(gettext$(R%[3]))                         ' IC <- IC + A1 
    case ocyy$="11": ic_dez% = val("%"+gettext$(R%[2])) + bin8_to_dez(gettext$(R%[3])) + sta% ' IC <- A0 + A1 + ST 
  else             
    inc ic_dez%                              ' if N-Flag = 0
  endif
  set_IC 
  flags_0_0_0_0                              ' set all flags to zero          
endproc
           ' JIZ +A        ' 000 0 10 10   Z=1: IC <- IC + A1	      Jump If Zero
proc _JIZ  ' JIZ IA        ' 000 0 11 10   Z=1: IC <- A0 + A1 + ST	Jump If Zero
  if Z$ = "1"                                '  if Z-Flag = 1                                         ' A1 signed
    case ocyy$="10": ic_dez% = ic_dez% + bin8_to_dez(gettext$(R%[3]))                        ' IC <- IC + A1 
    case ocyy$="11": ic_dez%= val("%"+gettext$(R%[2])) + bin8_to_dez(gettext$(R%[3])) + sta% ' IC <- A0 + A1 + ST 
  else
    inc ic_dez%                              ' if Z-Flag = 0
  endif
  set_IC 
  flags_0_0_0_0                              ' set all flags to zero
endproc
           ' JMP +A        ' 000 0 10 11	      IC <- IC + A1	      JuMP
proc _JMP  ' JMP IA        ' 000 0 11 11	      IC <- A0 + A1	+ ST  JuMP                                                                                               ' A1 vorzeichenbehaftet
  case ocyy$="10": ic_dez% = ic_dez% + bin8_to_dez(gettext$(R%[3]))                          ' IC <- IC + A1 
  case ocyy$="11": ic_dez%= val("%"+gettext$(R%[2])) + bin8_to_dez(gettext$(R%[3])) + sta%   ' IC <- A0 + A1  + ST
  set_IC   
  flags_0_0_0_0                              ' set all flags to zero
endproc
proc _LDC  ' LDC RG	       ' 000 1 00 xx   LoaD Constant  Reg xx <- next Byte ##
  inc ic_dez%       ' row with constant byte ## CCCC CCCC  ... further ...
  b_res$ = gettext$(RAM%, ic_dez% ,2)
  settext R%[rx%], b_res$
  flags_b_res_N_Z_0_0  
  inc ic_dez%                              ' ... with command line after next
  set_IC
endproc
           ' JIN RG 	     ' 000 1 01 xx   N=1: IC <- Reg xx	  Jump If Negative
           ' JIZ RG	       ' 000 1 10 xx   Z=1: IC <- Reg xx	  Jump If Zero                           
           ' JMP RG 	     ' 000 1 11 xx        IC <- Reg xx	  JuMP                            
proc _JIN_JIZ_JUMP_Reg  
  if ((ocyy$="01") and (N$="1")) or ((ocyy$="10") and (Z$="1")) or (ocyy$="11")         ' JUMPs register   
    ic_dez% = val("%"+gettext$(R%[rx%]))                                                ' IC <- Reg xx  
  else                                                                       ' also A1 = R[3] value unsigned
    inc ic_dez%                  
  endif
  set_IC 
  flags_0_0_0_0                             ' set all flags to zero
endproc                      
proc _INP  ' INP RG (IO)   ' 001 0 00 xx   Reg xx           <- INPut  
  ' --- input system (user input during program run)
  input_system 
  '-----------------------
  settext R%[rx%], binp$ 
  settext RAM%, 246, 2, binp$                     ' enter into RAM Adr 246 = hF6 binary  ...
  settext RAM%, 246, 3, chr$(bin8_to_dez(binp$))  + "    h"  + bin8_to_hex2(binp$) ' ... write character and value in hexadecimal 
  b_res$ = binp$           ' for flags
  flags_b_res_N_Z_0_0  
  inc ic_dez%
  set_IC 
endproc
proc _OUT  ' OUT RG (IO)   ' 001 0 01 xx   OUTput           <- Reg xx 
  boutp$ = gettext$(R%[rx%]) 
  ' --- output system (during program run)
  output_system   
  ' --------------------
  flags_0_0_0_0            ' set all flags to zero
  inc ic_dez%
  set_IC 
endproc
proc _PSH  ' PSH RG	       ' 001 0 10 xx   PuSH  Stack      <- Reg xx 
  starow% =  val("%"+gettext$(SP%))  
  settext RAM%, starow% , 4,"    "    ' delete old indicator for position stack pointer
  b_res$ =  gettext$(R%[rx%])
  push_b_res
  dec starow%                                     ' by 1 smaller address ...
  settext SP%, d255_to_bin8(starow%)              '   ... write into SP
  settext RAM%, val("%"+gettext$(SP%)), 4,"<-SP"  ' set indicator for position stack pointer
  flags_b_res_N_Z_0_0                             
  inc ic_dez%
  set_IC 
endproc
proc _POP  ' POP RG	       ' 001 0 11 xx   POP  Reg xx      <- Stack 
  if starow% < 255
    settext RAM%, val("%"+gettext$(SP%)), 4,"    "      ' delete old indicator for position stack pointer 
    inc starow%                               ' stack pointer 1 further in direction of end RAM ...
    settext SP%, d255_to_bin8(starow%)                ' ... write into SP
    settext RAM%, val("%"+gettext$(SP%)), 4,"<-SP"      ' set indicator for position stack pointer
    b_res$ = gettext$(RAM%,starow%,2) 
    settext R%[rx%], b_res$     
    flags_b_res_N_Z_0_0
    inc ic_dez%
    set_IC 
  else
     messagebox("error:      RAM end reached!"," --- stack-error ---",48)
    stop% = 1 
  endif
endproc
proc _SSR  ' SSR RG        ' 001 1 00 xx   Set Shadow Register  Reg xx -> Sxx  (SDx, SAx)
  b_res$ = gettext$(R%[rx%])
  settext S%[rx%], b_res$
  flags_b_res_N_Z_0_0
  inc ic_dez%
  set_IC 
endproc
proc _GSR  ' GSR RG        ' 001 1 01 xx   Get Shadow Register  Reg xx <- Sxx  (SDx, SAx)
   b_res$ =  gettext$(S%[rx%])
  settext R%[rx%] , b_res$                
  flags_b_res_N_Z_0_0
  inc ic_dez%
  set_IC 
endproc
proc _BTS  ' BTS RG        ' 001 1 10 xx   BitTest Reg xx with Shadowregister
  var bit% = 9
  settext AL1%, " " + gettext$(R%[rx%])     ' set right-justified in AL1
  settext AL2%, " " + gettext$(S%[rx%])     ' set right-justified in AL2 
  settext ALC%, "         "                 ' unused
  R9$ = "         "                         ' 9 bit - clear result ...                             
  settext ALR%, R9$                         ' ... and put into the ALU 
  repeat
    ALU_bitstep 
    if mid$(gettext$(AL2%),bit%, 1) = "1"        ' check only if the bit in the shadow register is set 
       if mid$(gettext$(AL1%),bit%, 1)  = "1"    ' compare bit from register 
         r$ = "0"                                ' match: 0
       else
         r$ = "1"                                ' deviation: 1
       endif
    else   
      r$ = "0"                                   ' not tested always: 0                      
    endif 
    R9$ =   space$(bit%-1) + r$  + right$(R9$, 9-bit%)   
    settext ALR%,R9$           
    dec bit%
  until bit% = 1                         ' without left bit (8 from 9)
  b_res$ = right$(gettext$(ALR%), 8)     ' result is discarded, only flags
  flags_b_res_N_Z_0_0                    ' match - set zero flag, negative flag if default negative but register positive
  inc ic_dez%
  set_IC 
endproc
proc _SWN  ' SWN RG        ' 001 1 11 xx   SWap Nibble  Reg xx
  b_res$ = right$(gettext$(R%[rx%]),4) + left$(gettext$(R%[rx%]),4)
  settext R%[rx%] , b_res$ 
  flags_b_res_N_Z_0_0    
  inc ic_dez%
  set_IC 
endproc
proc _SHL  ' SHL RG	       ' 010 0 00 xx   SHift Left   Reg xx
  N$ = mid$(gettext$(R%[rx%]),2,1)                 ' Negative flag (after shifting)
  if val("%"+right$(gettext$(R%[rx%]),7))= 0 
    Z$ = "1"                                       ' Zero flag
  else
    Z$ = "0"
  endif 
  V$ = "0"                                         ' oVerflow flag
  C$ = left$(gettext$(R%[rx%]),1)                  ' Carry flag 
  settext AL1%, "         "                        ' unused
  settext AL2%, "         "                        ' unused
  settext ALC%, "         "                        ' unused
  settext ALR%,"0" + gettext$(R%[rx%])             ' put into ALU
  ALU_step 
  settext ALR%, C$ + mid$(gettext$(ALR%),3,7) + "0"     ' shift left
  settext R%[rx%], right$(gettext$(ALR%),8)  
  settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$                  ' set status register with flags
  inc ic_dez%
  set_IC 
endproc
proc _SHR  ' SHR RG	       ' 010 0 01 xx   SHift Right  Reg xx
  N$ = "0"                                         ' Negative flag
  if val("%"+left$(gettext$(R%[rx%]),7))= 0 
    Z$ = "1"                                       ' set Zero flag 
  else
    Z$ = "0"       
  endif
  V$ = "0"
  C$ = right$(gettext$(R%[rx%]),1)                 ' Carry flag
  settext AL1%, "         "                        ' unused
  settext AL2%, "         "                        ' unused
  settext ALC%, "         "                        ' unused
  settext ALR%, "0" + gettext$(R%[rx%])            ' put into ALU
  ALU_step   
  settext ALR%, C$ + "0"+ mid$(gettext$(ALR%),2,7)       ' shift right
  settext R%[rx%], right$(gettext$(ALR%),8)   
  settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$                  ' set status register with flags
  inc ic_dez%
  set_IC 
endproc
proc _ROL  ' ROL RG        ' 010 0 10 xx   ROtate Left  Reg xx
  N$ = mid$(gettext$(R%[rx%]),2,1)                 ' Negative flag (after rotation) 
  if gettext$(R%[rx%]) = "00000000"
    Z$ = "1"
  else
    Z$ = "0"
  endif
  V$ = "0"
  C$ = left$(gettext$(R%[rx%]),1)                  ' Carry flag 
  settext AL1%, "         "                        ' unused
  settext AL2%, "         "                        ' unused
  settext ALC%, "         "                        ' unused
  settext ALR%,"0"+ gettext$(R%[rx%])              ' put into ALU 
  ALU_step                                         
  settext ALR%,C$ + mid$(gettext$(ALR%),3,7) + C$  ' rotate left  
  settext R%[rx%], right$(gettext$(ALR%),8)   
  settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$                  ' set status register with flags
  inc ic_dez%
  set_IC 
endproc
proc _ROR  ' ROR RG	       ' 010 0 11 xx   ROtate Right Reg xx
  N$ = right$(gettext$(R%[rx%]),1)                 ' Negative flag (after rotation) 
  if gettext$(R%[rx%]) = "00000000"
    Z$ = "1"
  else
    Z$ = "0"
  endif                
  V$ = "0"
  C$ = N$                                          ' Carry flag equals Negative-flag    
  settext AL1%, "         "                        ' unused
  settext AL2%, "         "                        ' unused
  settext ALC%, "         "                        ' unused
  settext ALR%,"0"+ gettext$(R%[rx%])              ' put into ALU 
  ALU_step                                                 
  settext ALR%, C$ + C$ + mid$(gettext$(ALR%),2,7) ' rotate right 
  settext R%[rx%], right$(gettext$(ALR%),8) 
  settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$                  '  set status register with flags
  inc ic_dez%  
  set_IC 
endproc
proc _CLR  ' CLR RG	       ' 010 1 00 xx   CLear Register Reg xx <- 0
  b_res$ = "00000000" 
  settext R%[rx%],b_res$                            ' clear register
  flags_b_res_N_Z_0_0   
  inc ic_dez%
  set_IC 
endproc
           ' INC RG	       ' 010 1 01 xx   INCrement Reg xx  
           ' DEC RG	       ' 010 1 10 xx   DECrement Reg xx 
proc _INC_DEC                       
  settext AL1%,gettext$(R%[rx%]) 
  case ocyy$="01" : settext AL2%,"00000001"         ' +1 (INC)
  case ocyy$="10" : settext AL2%,"11111111"         ' -1 (DEC)
  add_ALU_9                                         ' addition in the ALU (with flags)
  settext R%[rx%],right$(gettext$(ALR%), 8)
  inc ic_dez%
  set_IC 
endproc
proc _NOT  ' NOT RG	       ' 010 1 11 xx   Reg xx <- NOT Reg xx (bitwise)
  settext AL1%, gettext$(R%[rx%])                  ' set into  ALU
  complement1_ALU                                  ' form one's complement in the ALU
  settext R%[rx%], right$(b_res$,8)                ' Enter result
  flags_b_res_N_Z_0_0  
  inc ic_dez%
  set_IC 
endproc
           ' MOV RG  SR    ' 011 0 yy yy   MOVe   Reg yy <-  SR      *1) xx=yy (observe sequence code!)
           ' MOV RG  SP    ' 011 1 yy yy   MOVe   Reg yy <-  SP      *2) xx=yy
           ' MOV SR  RG 	 ' 100 0 xx xx	 MOVe       SR <- Reg xx   *3) xx=yy 
           ' MOV SP  RG 	 ' 101 0 xx xx   MOVe       SP <- Reg xx   *4) xx=yy 
proc _MOV_SRSP 
  if ocg$="011"
    case ocb$ = "0" :  b_res$ = gettext$(SR%)    ' <- SR
    case ocb$ = "1"   :b_res$ = gettext$(SP%)    ' <- SP
    settext R%[ry%], b_res$ 
  endif  
  if ocg$="100" 
    b_res$ = gettext$(R%[rx%])  
    settext SR%, b_res$                          ' SR <-  
  endif
  if ocg$="101" 
    b_res$ = gettext$(R%[rx%])  
    settext SP%, b_res$                          ' SP <-
  endif 
  flags_b_res_N_Z_0_0
  inc ic_dez%
  set_IC  
endproc
           ' AND RG  RG	   ' 011 0 yy xx   Reg yy <- Reg yy AND Reg xx, xx<>yy 
           ' OR  RG  RG	   ' 011 1 yy xx   Reg yy <- Reg yy OR  Reg xx, xx<>yy 
proc _AND_OR  
  var bit% = 9
  settext AL1%," "+gettext$(R%[rx%])               ' set right 8Bit of the 9Bit arithmetic unit
  settext AL2%," "+gettext$(R%[ry%])
  settext ALC%, "         "                        ' unused 
  R9$ = "         "                                ' 9 bit clear result ...                             
  settext ALR%, R9$                                ' ... and put into the ALU 
  repeat
    ALU_bitstep 
    b1$ = mid$(gettext$(AL1%),bit%, 1)  ' read out bit
    b2$ = mid$(gettext$(AL2%),bit%, 1)  
    if ocb$ = "0"                           ' AND
      if b1$+b2$="11" 
        r$="1"
      else
        r$="0"
      endif
    endif
    if ocb$ = "1"                           ' OR 
      if b1$+b2$="00" 
        r$="0"
      else
        r$="1"
      endif         
    endif
    R9$ =   space$(bit%-1) + r$  + right$(R9$, 9-bit%)   
    settext ALR%,R9$           
    dec bit%
  until bit% = 1                         ' without left bit (8 from 9)
  b_res$ = right$(gettext$(ALR%), 8)
  settext R%[ry%],b_res$
  flags_b_res_N_Z_0_0 
  inc ic_dez%
  set_IC 
endproc

           ' ADD RG  RG	   ' 100 0 yy xx   Reg yy <- Reg yy + Reg xx,   xx<>yy 
           ' ADD RG  [RG]  ' 100 1 yy xx   Reg yy <- Reg yy + Adr(Reg xx)
proc _ADD                       
  case ocb$ = "0" : settext AL1%,gettext$(R%[rx%])                             ' ADD RG  RG	
                                          ' also A1 = R[3] value unsigned
  case ocb$ = "1" : settext AL1%,gettext$(RAM%,val("%"+gettext$(R%[rx%])),2)   ' ADD Reg [Reg]   
  settext AL2%,gettext$(R%[ry%]) 
  add_ALU_9                                   ' addition in the ALU (with flags)
  settext R%[ry%],right$(gettext$(ALR%), 8)
  inc ic_dez%
  set_IC 
endproc
           ' SUB RG  RG	   ' 101 0 yy xx   Reg yy <- Reg yy - Reg xx,   xx<>yy 
proc _SUB  ' SUB RG  [RG]  ' 101 1 yy xx   Reg yy <- Reg yy - Adr(Reg xx)
  if ocb$ = "0"                          ' SUB RG  RG	  
    settext AL1%, gettext$(R%[rx%])            ' set Reg xx in ALU
  endif 
  if ocb$ = "1"                          ' SUB Reg [Reg] 
    settext AL1%, gettext$(RAM%, val("%"+gettext$(R%[rx%])) ,2)      ' also A1 = R[3] value unsigned
  endif 
  complement1_ALU                              ' form one's complement of AL1
  settext AL1%, "00000001"                     ' 1 for addition in 1st operand
  settext AL2%,  b_res$                        ' set result in 2nd operand
  add_ALU_9                                    ' form two's complement by addition:
  settext AL1%,gettext$(R%[ry%])               ' y
  settext AL2%, b_res$                         '    -x   (bottom value in the ALU is subtracted)      
  add_ALU_9                                    ' addition y + (-x) in the ALU (with flags)
  settext R%[ry%],right$(gettext$(ALR%), 8)
  inc ic_dez%
  set_IC 
endproc
           ' MOV [RG] RG	 ' 110 0 yy xx   MOVe Adr(Reg yy)   <- Reg xx 
           ' MOV RG  [RG]  ' 110 1 yy xx   MOVe     Reg yy    <- Adr(Reg xx)
proc _MOV_RAM                                  
  if ocb$ = "0"                          ' MOV [Reg] <- Reg
    row% = val("%"+gettext$(R%[ry%]))    ' also A1 = R[3] value unsigned
    b_res$ = gettext$(R%[rx%])  
    settext RAM%, row%, 2, b_res$                                                       ' binary enter
    sp_h$ = space$(5-len(str$(bin8_to_dez(b_res$)))) +"h"     ' variable spaces before h for hexadecimal value   
    settext RAM%, row%, 3, str$(bin8_to_dez(b_res$)) + sp_h$ + bin8_to_hex2(b_res$ )    ' dec. hex insert  
    flags_b_res_N_Z_0_0
    inc ic_dez%
    set_IC 
  endif
  if ocb$ = "1"                          ' MOV  Reg  <- [Reg]         
    row%=val("%"+gettext$(R%[rx%]))      ' also A1 = R[3] value unsigned
    b_res$ = gettext$(RAM%, row% ,2)
    settext R%[ry%], b_res$ 
    flags_b_res_N_Z_0_0    
    inc ic_dez%
    set_IC 
  endif
endproc
           ' MOV SR  CC	   ' 111 0 CC CC	 MOVe       SR <- CC..    *5) xx=yy 2 bit IO   
proc _MOV_SRCC
  settext SR% , ocxx$ + right$(gettext$(SR%),6)  ' <- CC.. .... set left two bit (IO)
  flags_0_0_0_0                                  ' set all flags to zero
  inc ic_dez%
  set_IC 
endproc
           ' MOV RG  RG    ' 111 0 yy xx   MOVe     Reg yy    <- Reg xx, xx<>yy  
proc _MOV_REG            
  b_res$ = gettext$(R%[rx%])  
  settext R%[ry%], b_res$ 
  flags_b_res_N_Z_0_0
  inc ic_dez%
  set_IC 
endproc
           ' MOV RG  IA    ' 111 1 00 xx   MOVe     Reg xx    <- Adr(A0+A1+ST)
           ' MOV IA  RG    ' 111 1 01 xx   MOVe Adr(A0+A1+ST) <- Reg xx  
proc _MOV_IA                                                       
  if ocyy$ = "00"                        ' Reg <- Adr.(A0 + A1 + ST)                       
    row%=val("%"+gettext$(R%[2])) + bin8_to_dez(gettext$(R%[3])) + sta% ' A1 signed
    ram_adr_cykl                          ' intercept RAM area overflow, address cyclically in RAM
    b_res$ = gettext$(RAM%, row% ,2)  
    settext R%[rx%], b_res$                         ' target register here (as with input) is Reg xx 
  endif     
  if ocyy$ = "01"                        ' Adr.(A0 + A1 + ST)  <- Reg   
    row%=val("%"+gettext$(R%[2])) + bin8_to_dez(gettext$(R%[3])) + sta% ' A1  signed
    ram_adr_cykl                         ' intercept RAM area overflow, address cyclically in RAM
    b_res$ = gettext$(R%[rx%])                                   ' here: source register Reg xx
    settext RAM%, row%, 2, b_res$                                                       ' binary enter
    sp_h$ = space$(5-len(str$(bin8_to_dez(b_res$)))) +"h"     ' variable spaces before h for hexadecimal value 
    settext RAM%, row%, 3, str$(bin8_to_dez(b_res$)) + sp_h$ + bin8_to_hex2(b_res$)     '  dec. hex. enter
  endif  
  flags_b_res_N_Z_0_0   
  inc ic_dez%
  set_IC 
endproc
proc _LOD  ' LOD RG	       ' 111 1 10 xx   LOad Data Reg xx   <- Adr(h80+A1+ST)
  ' from byte 128 intended for data
  row% =    128 + bin8_to_dez(gettext$(R%[3])) + sta%   ' A1 signed
  ram_adr_cykl                           ' intercept RAM area overflow, address cyclically in RAM
  b_res$ = gettext$(RAM%, row% ,2)  
  settext R%[rx%], b_res$
  flags_b_res_N_Z_0_0  
  inc ic_dez%
  set_IC 
endproc
proc _STO	 ' STO (IO)	     ' 111 1 11 00   STOre   file <- Adr(h80+A1+ST) D0 byte  via D1  (typ: IO)
  iofile$ = gettext$(o_ch%)               ' output channel file
  if len(iofile$) = 0
    iofile$ = savefile$("store data","HC680 file  (*.hcx)| *.hcx")
  endif  
  assign #10,iofile$
  rewrite #10                             ' overwrite existing
  ' from byte 128 intended for data
                ' A1 signedt 
  row% = 128 + bin8_to_dez(gettext$(R%[3])) + sta% ' from Adr.(h80 + A1 + ST)  D0-byte - store external
  ram_adr_cykl                            ' intercept RAM area overflow, address cyclically in RAM
  'IO_SR$                                 ' type data IO, left two bits in SR
  temp% = 0                               ' counting data
             '   D0 unsigned
  while temp% < val("%"+gettext$(R%[0]))  ' Number of bytes to be copied in D0 (unsigned)                  
    btemp1$ = gettext$(RAM%, row%, 2)                   ' 8 bit binary for D1 entry
    set_D1(btemp1$)                                     ' place in D1 and make visible
    select IO_SR$     ' Type of storage: 
      caseof "00" 
        btemp1$ = chr$(val("%"+btemp1$))   '  character
      caseof "01"   
        btemp1$ = bin8_to_dez(btemp1$)     '  decimal
      caseof "10"  
        btemp1$ = bin8_to_hex2(btemp1$)    '  hexadecimal: xx  
      caseof "11"    
        'btemp1$ = btemp1$                  '  8 bit binary (take over)
    endselect
    print #10,btemp1$  
    inc row%  
    if row% = 256               ' RAM end ...   ' messagebox("RAM-end!","Error while storing the file \nless data written    ",0)
      break                     ' ... abort, less data are written
    endif
    inc temp%                               ' counter for number of stored values
    inc t%                                  ' clock  - continue counting
  endwhile // write
  row% = 0                                  ' reset
  close #10                                 ' close file
  '
  settext R%[0], d255_to_bin8(temp%)          ' place the number (unsigned) of the actually written data in D0
  N$ = "0"
  if temp% = 0                  
    Z$ = "1"                                  ' set Z flag if no data was written
  else
    Z$ = "0" 
  endif
  V$ = "0"                               
  C$ = "0"
  settext SR%, left$(gettext$(SR%),4) + N$ + Z$ + V$ + C$  ' Set flags in SR
  inc ic_dez%
  set_IC 
endproc
proc _RCL  ' RCL (IO)      ' 111 1 11 01   ReCalL  Adr(h80+A1+ST) <- file   via D1 (type: IO)  /D0 byte read
  var bit% = 0 
  V$ =  "0"                              ' oVerflow Flag,  set 0 in advance
  iofile$ = gettext$(i_ch%)              ' Input channel file
  if len(iofile$) = 0 
    iofile$ = loadfile$("load data","HC680 file  (*.hcx)| *.hcx")
  endif  
  assign #10,iofile$ 
  reset #10
  ' from 128 intended for data, A1 signed  
  row% =    128      +       bin8_to_dez(gettext$(R%[3])) + sta% ' from h80 + A1 + ST,   read in  
  ram_adr_cykl                      ' intercept RAM area overflow, address cyclically in RAM
  'IO_SR$                           ' type data IO, left two bits in SR
  temp% = 0                         ' count data
  whilenot eof(#10)
    input #10, btemp1$
    btemp1$ = trim$(btemp1$) 
    '-------------                  ' Type of data to be read in:
    select IO_SR$
      caseof "00"                            ' --- Keyboard character --- 
        conval% = ord(btemp1$)                                                     ' ANSI 0..255 code value of first character 
        btemp2$ = d255_to_bin8(conval%)                                            ' binary convert
        set_D1(btemp2$)                                                            ' put down in D1 and make visible
        settext RAM%,row%,2, btemp2$                                               ' binary enter
        sp_h$ = space$(5-len(btemp1$)) +"h"                                        ' variable spaces before h for hexadecimal value                                 
        settext RAM%,row%,3, btemp1$ + sp_h$ + bin8_to_hex2(btemp2$)               ' write in    character, hex
        ' ---
      caseof "01"                           ' --- number ---
        conval% = val(btemp1$)                                                     ' get value from string
        if ((conval% > 127) or (conval% < -128))                                   ' not illustratable --> 0
          conval% = 0   
          btemp1$="0"
          V$ = "1"                                                                 ' set oVerflow flag 
        endif  
        btemp2$ = dez_to_bin8(conval%)                                             ' binary convert
        set_D1(btemp2$)                                                            ' put down in D1 and make visible
        settext RAM%,row%,2, btemp2$                                               ' binary enter
        sp_h$ = space$(5-len(btemp1$)) +"h"                                        ' variable spaces before h for hexadecimal value                                
        settext RAM%,row%,3, btemp1$ + sp_h$ + bin8_to_hex2(btemp2$)               ' write in    number, hex
        ' ---
      caseof "10"                            ' --- hexadecimal xx ---
        conval% = val("$" + btemp1$)                                               ' decimal without sign: 0..255
        if conval% > 255                                                           ' not illustratable  --> 00
          conval% = 0                         
          btemp1$ ="00"
          V$ = "1"                                                                 ' set oVerflow flag
        endif 
        btemp2$ = d255_to_bin8(conval%)                                            ' binary convert
        set_D1(btemp2$)                                                            ' put down in D1 and make visible
        settext RAM%,row%,2, btemp2$                                               ' binary enter
        sp_h$ =  space$(5-len(str$(bin8_to_dez(btemp2$))) )                        ' variable spaces before h for hexadecimal value 
        settext RAM%,row%,3, str$(bin8_to_dez(btemp2$)) + sp_h$ + "h"+ btemp1$     ' write in    dec, hex
       ' ---
      caseof "11"                            ' --- 8 bit binary --- 
        if (len(btemp1$) > 8) 
          btemp1$  = right$(btemp1$,8)                                                ' cut left to 8
          V$ = "1"                                                                    ' set oVerflow flag
        endif
        case (len(btemp1$) < 8) : btemp1$  =  mkstr$("0", 8 - len(btemp1$)) + btemp1$ ' fill left to 8 with 0
        bit% = 0                                                                   
        repeat                                                                        ' check for 0 resp. 1
          inc bit%
          if ( (mid$(btemp1$,bit%,1) <> "0") and (mid$(btemp1$,bit%,1) <> "1") )      ' invalid binary digit ...
            btemp1$ = "00000000"                                                      ' ... zero byte
            bit% = 8
            V$ =  "1"                                                                 ' set oVerflow Flag
          endif
        until bit% = 8
        set_D1(btemp1$)                                                               ' put down in D1 and make visible
        settext RAM%,row%,2,btemp1$                                                   ' binary enter
        sp_h$ = space$(5-len(str$(bin8_to_dez(btemp1$)))) +"h"                        ' variable spaces before h for hexadecimal value 
        settext RAM%,row%,3, str$(bin8_to_dez(btemp1$))+ sp_h$ + bin8_to_hex2(btemp1$)  ' write in    dez, hex
    endselect // type data IO_SR
   '----------------------------
    inc row%    
    if row% = 256 
         V$ =  "1"                          ' set oVerflow flag  ... 
      break                                 '         ... too much data for RAM size, abort  
    endif  
    inc temp%                               ' count imported data 
    inc t%                                  ' continue clock count
  endwhile // read in 
  '
  row%  = 0                                 ' set to start again
  close #10                                 ' close file  
  '
  settext R%[0], d255_to_bin8(temp%)        ' store number (unsigned) of read-in data in D0
  N$ = "0"
  if temp% = 0                  
    Z$ = "1"                                ' set Z flag if no data was read
  else
    Z$ = "0" 
  endif
  ' V$  is set to 0 in advance and in the loop
  C$ = "0"
  settext SR%, left$(gettext$(SR%),4) + N$ + Z$ + V$ + C$  ' set flags in SR
  inc ic_dez% 
  set_IC 
endproc
proc _CPY	 ' CPY	         ' 111 1 11 10   CoPY Adr(A1)<-Adr(A0)     D0 byte via D1
  V$ =  "0"                                ' oVerflow flag,  reset in advance
  var i% = 0                               ' Count data
  while i% < val("%"+gettext$(R%[0]))      ' number of bytes to be copied in D0 (unsigned)
    temp% = i% + val("%"+gettext$(R%[2]))  ' determine source row
    if temp% = 256                         ' RAM end reached ...  'messagebox("RAM end reached!","--- error during copying! ---",0)
      break                                ' ... less data are copied, abort
    endif  
    btemp1$ = gettext$(RAM%, temp% , 2)    ' read binary from source row
    set_D1(btemp1$)                        ' store in D1 and make visible
    row% = i%  + val("%"+gettext$(R%[3]))  ' determine target row
    if row% = 256 
      V$ =  "1"                            ' oVerflow    ' messagebox("RAM end reached - overflow!","--- error during copying! ---",0)
      break                                ' too many bytes for RAM size, abort 
    endif  
    settext RAM%, row%, 2, btemp1$                             ' binary enter
    sp_h$ = space$(5-len(str$(bin8_to_dez(btemp1$ )))) +"h"    ' variable spaces before h for hexadecimal value 
    settext RAM%, row%, 3, str$(bin8_to_dez(btemp1$ )) + sp_h$ + bin8_to_hex2(btemp1$) ' write in    dez, hex
    inc i%
    inc t%                                  ' clock continue counting 
  endwhile 
  settext R%[0], d255_to_bin8(i%)             ' store number (unsigned) of copied bytes in D0
  N$ = "0"
  if i% = 0                  
    Z$ = "1"                                  ' set Z flag if no data was copied
  else
    Z$ = "0" 
  endif
  ' V$  is processed beforehand and possibly in the loop at break (target row)
  C$ = "0"
  settext SR%, left$(gettext$(SR%),4) + N$ + Z$ + V$ + C$  ' Set flags in SR
  inc ic_dez% 
  set_IC 
endproc
proc _STP  ' STP           ' 111 1 11 11 	 StoP
  stop% = 1   
  inc ic_dez%  
  set_IC
  ' -->  modify flags not  - continuation of the program also conceivable with subsequent jump command
endproc
'} 
' *****************************************************
'. 