' Simulation  Mikroprozessor HC680 -fiktiv-   8 Bit
'----------------------------------------------------
'{--> Übersicht: Register, Adessierungsarten, feste RAM-Adressen
          '
          ' Register:
          ' Nr Bez.  xx Bin  Art    
          ' 0  D0    00      Datenregister
          ' 1  D1    01      Datenregister
          ' 2  A0    10      Adr.-Basisreg.
          ' 3  A1    11      Adr.-Indexreg.
          ' SD0/SD1 Schattenreg. zu D0/D1
'         ' SA0/SA1 Schattenreg. zu A0/A1
          '    IR Instruction Register 
          '    IC Instruction Counter
          '    SR Status Register 
          '    SP Stack Pointer
          '    ST Startadresse
          ' ------------------------------
          '  A1 ist als Offset +A, IA 
          '  vorzeichenbehaftet
          ' ------------------------------               
          '
          ' Status Register SR
          '     IOXYNZVC
          ' Ein/ IO=00 Zeichen
          ' Ausg.  =01 dezimal
          '        =10 hexadezimal
          '        =11 binär
          ' frei verügbar XY
          ' Flags N Negative
          '       Z Zero
          '       V oVerflow
          '       C Carry
          '
          ' -----------------------------------
          ' -->  Adressierungsarten	      in
          '                            Assembler
          '                            _________
          ' * Adr./Register fest
          '
          ' Wert im/in Register:
          ' * Register direkt      
          '   Reg xx, Reg yy             .Rg.
          ' Wert im/in RAM (Adr. im Reg.)          
          ' * Register indirekt           
          '   Adr.(Reg xx)               [Rg]
          '            yy
          '
          ' Adr. mit Offset
          ' * IC relativ		                
          '   Adr.: IC + A1              .+A.
          '
          ' * IndexAdresse             
          '   Adr.: A0 + A1  + ST        .IA.
          '
          ' * bei  LOD/STO/RCL
          '   Adr.: h80 + A1 +ST
          ' ---
          '   A1 als Index mit Vorzeichen
          '
          ' -------------------------------------          
          ' feste RAM-Adressen:
          '
          ' h00 Standard Startadresse
          ' h80 Basisadr. Daten (down)
          ' hF5 Basisadr. Stack (up)
          ' hF6 Adresse Tastatureingabe
          ' hF7 Adresse Display-Pixel
          ' hF8 - hFF  MGA-Display 8x8 ("Maxipixel")
'}
'{--> Übersicht: Mnemonics Assembler & Maschinenbefehle des HC680 
'             
'                       Operationscode - Systematik der Gruppierung:
'                         g Gruppe
'                         b Bit Adressierungsart/Befehlsvarianten
'                         yy,xx 2 Register oder Adressierungsart/Befehlsvarianten   
'
'       Assembler       Maschinenbef.	    Wirkung /Bedeutung	
'                     Opcode/Binärcode     	        Adressierungsart
'
'       Mnem.            g  b yy xx       -----------------------------------------	
'            Operanden 
'        NOP 	          000 0 00 00	      No Operation	
'        CMP 	          000 0 00 01	      CoMPare D0, D1	
'        SWD            000 0 00 10	      SWap D0, D1
'        SWM 	          000 0 00 11	      SWap Memory Adr(D0), Adr(D1)
'               arithmetische/ Stack Befehle --------------------------------------
'        MUL	          000 0 01 00	      MULtiplication D0 <- D0*D1	
'        DIV	          000 0 01 01	      DIVision D0 <- D0\D1	Rest SD0	
'        PSA	          000 0 01 10	      PuSh All Stack <- A,D,SR Reg.
'        POA	          000 0 01 11	      POp All SR,D,A Reg. <- Stack	
'               Sprungbefehle	 ----------------------------------------------------		
'        JSR	          000 0 10 00	      Jump SubRoutine Stack<-IC+1, A0=0: IC<-IC+A1 sonst IC<-A0+A1+ST
'        JIN +A	        000 0 10 01       N=1: IC <- IC +A1     Jump If Negative
'        JIZ +A	        000 0 10 10  	    Z=1: IC <- IC +A1	    Jump If Zero
'        JMP +A	        000 0 10 11	           IC <- IC +A1	    Jump
'                       ...........
'        RET	          000 0 11 00  	    RETturn subroutine IC <-Stack
'        JIN IA	        000 0 11 01  	    N=1: IC <- A0 +A1 +ST Jump If Negative	
'        JIZ IA	        000 0 11 10  	    Z=1: IC <- A0 +A1 +ST	Jump If Zero
'        JMP IA 	      000 0 11 11	           IC <- A0 +A1 +ST JuMP
'               Lade Konstante ----------------------------------------------------  
'        LDC Rg         000 1 00 xx       LoaD Constant Register    Reg xx <- next Byte ##
'        ##  CCCC CCCC                    ## Constant Byte
'                             .. Register ..
'        JIN RG 	      000 1 01 xx 	    N=1: IC <- Reg xx	    Jump If Negative
'        JIZ RG	        000 1 10 xx  	    Z=1: IC <- Reg xx	    Jump If Zero
'        JMP RG 	      000 1 11 xx            IC <- Reg xx	    JuMP
'               Eingabe/ Ausgabe /Stack Befehle -----------------------------------
'        INP RG (IO)    001 0 00 xx   	  Reg xx        <- INPut
'        OUT RG	(IO)    001 0 01 xx   	  OUTput        <- Reg xx
'        PSH RG	        001 0 10 xx   	  PuSH  Stack   <- Reg xx
'        POP RG	        001 0 11 xx   	  POP  Reg xx   <- Stack
'               Schattenregister /Nibble ----------------------------------------
'        SSR Rg         001 1 00 xx   	  Set Shadow Register   Reg xx -> Sxx (SDx, SAx)
'        GSR RG         001 1 01 xx       Get Shadow Register   Reg xx <- Sxx (SDx, SAx)
'        BTS RG         001 1 10 xx       BitTest with Shadow Register
'        SWN RG         001 1 11 xx       SWap Nibble Reg xx
'               arithmetische/ logische Befehle/ SR/ SP--------------------------
'        SHL RG	        010 0 00 xx   	  SHift Left   Reg xx
'        SHR RG	        010 0 01 xx   	  SHift Right  Reg xx
'        ROL RG	        010 0 10 xx   	  ROtate Left  Reg xx
'        ROR RG	        010 0 11 xx   	  ROtate Right Reg xx
'                       ...........
'        CLR RG	        010 1 00 xx   	  CLear Register Reg xx <- 0	
'        INC RG	        010 1 01 xx   	  INCrement Reg xx  
'        DEC RG	        010 1 10 xx       DECrement Reg xx
'        NOT RG	        010 1 11 xx   	  Reg xx <- NOT Reg xx (bitweise)
'                       ----- Reg Reg/ *) Transportbefehle SR/ SP -----------------
'        MOV RG  SR     011 0 yy yy       MOVe      Reg yy <-  SR     *1) xx=yy
'        AND RG  RG	    011 0 yy xx   	  Reg yy <- Reg yy AND Reg xx,   xx<>yy  
'        MOV RG  SP     011 1 yy yy       MOVe      Reg yy <-  SP     *2) xx=yy
'        OR  RG  RG	    011 1 yy xx   	  Reg yy <- Reg yy OR  Reg xx,   xx<>yy
'                       -----------------------------------------------------------
'        MOV SR  RG 	  100 0 xx xx	      MOVe          SR <- Reg xx  *3) xx=yy
'        ADD RG  RG	    100 0 yy xx   	  Reg yy <- Reg yy +  Reg xx,    xx<>yy
'        ADD RG  [RG]   100 1 yy xx   	  Reg yy <- Reg yy +  Adr(Reg xx)
'                       -----------------------------------------------------------
'        MOV SP  RG 		101 0 xx xx     	MOVe          SP <- Reg xx  *4) xx=yy
'        SUB RG  RG	    101 0 yy xx   	  Reg yy <- Reg yy -  Reg xx,    xx<>yy
'        SUB RG  [RG]   101 1 yy xx   	  Reg yy <- Reg yy -  Adr(Reg xx)
'              Transportbefehle ---------------------------------------------------
'        MOV [RG] RG	  110 0 yy xx  	    MOVe Adr(Reg yy) <- Reg xx 
'        MOV RG  [RG]	  110 1 yy xx   	  MOVe Reg yy      <- Adr(Reg xx)
'                       ----- Const. ----                         
'        MOV SR  CC		  111 0 CC CC	      MOVe          SR <- CC..    *5) xx=yy 2Bit IO
'                       ..... Reg Reg .. 
'        MOV RG  RG   	111 0 yy xx   	  MOVe Reg yy      <- Reg xx,    xx<>yy 
'                             .. Reg ..
'        MOV RG  IA     111 1 00 xx   	  MOVe Reg xx      <- Adr(A0+A1+ST)
'        MOV IA  RG     111 1 01 xx   	  Adr(A0+A1+ST)  <- Reg xx
'        LOD RG	        111 1 10 xx   	  Load Data   Reg xx <- Adr(h80+A1+ST)
'             Speicherbefehle/Kopierbefehl /Stopp ---------------------------------
'        STO (IO)	      111 1 11 00   	  STOre   Datei <- Adr(h80+A1+ST) D0 Byte, über D1 (Art: IO) 
'        RCL (IO)       111 1 11 01       ReCalL  Adr(h80+A1+ST) <- Datei; über D1 (Art: IO)  /D0 Byte gelesen
'        CPY		        111 1 11 10	      CoPY Adr(A1)<-Adr(A0); D0 Byte über D1
'        STP		        111 1 11 11	      StoP   Programm anhalten, Flags vom Vorbefehl   
'        --------------------------------------------------------------------------
'   Läuft der IC unter h00/über hFF wird er zyklisch in den gültigen Bereich gesetzt, ebenso die Operanden-Adr(h80/A0 +A1+ST).
'   Keine Angabe bei FLAG: Flag wird 0 gesetzt.  Daten IO: 00 Zeichen, 01 dezimal, 10 hexadezimal, 11 binär (je ein Wert pro Zeile).
'      
'}
main
proc main   ' {
'{--- Fenster / Farben / Schrift  ------------------------------------
windowtitle "Simulation               Prozessor HC680 -fiktiv-             8 Bit Daten/Adressen           V 1.0.8"
windowstyle 31
window 8,8 - 1024,748
useicon "KNOPF1"
'
set("Decimals",0)
var black%     = RGB(0,0,0)
var white%     = RGB(255,255,255)
var grey%      = RGB(192,192,192)    ' Knopf, Gitternetzlinien grau
'
var red%       = RGB(240,0,0)        ' Knopf rot
var yellow%    = RGB(255,255,0)      ' Knopf gelb
var richgreen% = RGB(0,200,0)        ' Knopf sattgrün 
'
var darkgreen% = RGB(0,160,0)        ' dunkelgrüne Schrift
var darkred%   = RGB(225,0,0),       ' dunkelrote Schrift
'
'Vorgabe Fensterfarbe und Hilfe Tooltipps anzeigen (wenn INI.TXT nicht im Ordner) 
var b_red%     = 238                 ' Hintergrund Rotanteil
var b_green%   = 238                 ' Hintergrund Grünanteil
var b_blue%    = 211                 ' Hintergrund Blauanteil
var htt%       = 1                   ' Hilfe-Tooltips anzeigen 1, verbergen 0 
var ini$ = ""
if fileexists("INI.TXT")             ' wenn vorhanden aus Datei überschreiben
  assign #1, "INI.TXT"
  reset #1
  whilenot EOF(#1)
    input #1,ini$
    case left$(ini$,2) ="R=" : b_red%   = val(mid$(ini$,3,3))
    case left$(ini$,2) ="G=" : b_green% = val(mid$(ini$,3,3))
    case left$(ini$,2) ="B=" : b_blue%  = val(mid$(ini$,3,3))
    case left$(ini$,2) ="H=" : htt%     = val(mid$(ini$,3,1))
  endwhile
  close #1
endif
var backgrdc%  = RGB(b_red%, b_green%, b_blue%)           ' Hintergrundfarbe               
var chipc%     = RGB(b_red%+15, b_green%+15, b_blue%+15)  ' Chipfarbe: IO und CPU    
'
cls backgrdc%                     
textcolor black%, backgrdc%     
usefont "Arial", 16,6,0,0,0          ' Standardschrift für das Fenster
' --- Schriften für die Controls ---                                        
var sfont%       = create("font","Lucida Console" , 12, 7,0,0,0)         
var font%        = create("font","Lucida Console" , 14, 8,0,0,0) 
var spfont%      = create("font","Lucida Console" , 12, 8,0,0,0)
var xfont%       = create("font","Arial", 17,9,1,0,0)
var afont%       = create("font","Arial", 15,7,0,0,0)
var symbolfont%  = create("font","Symbol",19,10,0,0,0)
  '}
'{--- globale Variablen für die Simulation ---------------------------
declare inp$                   ' User Input im Edit dezimal/ Zeichen/ hexadezimal hxx Hxx $xx
declare hinp$                  ' Input hexadezimal
declare binp$                  ' Input binär
declare inpval%                ' Wert Input
declare ansi%                  ' ANSI-Code Zeichen oder des ersten Zeichens im String
declare boutp$                 ' Output binär
declare oc$                    ' Opcode des Befehls (binär, gegliedert: xxx x xx xx)
declare mn$, op1$, op2$        ' Mnemonic,  Operand 1, Operand 2
declare ocg$                   ' Opcode Gruppe 3 Bit
declare ocb$                   ' Opcode Bit (Stelle 4)
declare ocyy$                  ' Opcode 2Bit (teils Ziel-Register)
declare ocxx$                  ' Opcode 2Bit (teils Quell-Register
declare rx%                    ' Opcode dezimal (z.T. Index des Registerfeldes)
declare ry%                    ' Opcode dezimal (z.T. Index des Registerfeldes)
declare ocyyxx$                ' yy xx zusammenfassen (mit Leerstelle)
declare coninp$                ' Konstante  - Eingabe aus Edit
declare conbin$                ' Konstante binäre Darstellung
declare conval%                ' dezimaler Wert der Konstanten
declare opcomm$                ' Kommentar zu Befehl
declare concomm$               ' Kommentar zu Konstante
declare IO_SR$                 ' linke zwei Bit des Status Registers, Art Ein/Ausgabe Zeichen, dez, hex, bin
declare XY_SR$                 ' Bits 3,4 des Status Registers, frei nutzbar
declare fl$                    ' Flags die vom Befehl gesetzt werden können
declare N$                     ' N-Flag (negativ)            0/1 --> Status Register SR
declare Z$                     ' Z-Flag (zero/ Null)         0/1 --> Status Register SR
declare V$                     ' V-Flag (overflow/ Überlauf) 0/1 --> Status Register SR 
declare C$                     ' C-Flag (carry / Übertrag)   0/1 --> Status Register SR
declare N_$                    ' N-Flag als Zeichen N  nach Befehlsausführung
declare Z_$                    ' Z-Flag als Zeichen Z  nach Befehlsausführung       
declare V_$                    ' V-Flag als Zeichen V  nach Befehlsausführung
declare C_$                    ' C-Flag als Zeichen C  nach Befehlsausführung
      ' V-Flag, oVerflow-Flag: Ist das Overflow-Flag gesetzt, dann trat bei der letzten Rechenoperation
         ' ein Überlauf auf, wenn man von vorzeichenbehafteten Operanden ausgeht. (< -128  oder  > 127) 
      ' C-Flag, Carry-Flag: Ist dieses Flag gesetzt, dann trat bei der letzten Rechenoperation ein Übertrag auf,
         ' wenn man von vorzeichenlosen Operanden ausgeht.(>255) 
         ' War der letzte ausgeführte Befehl eine Schiebe/Rotations-operation, so zeigt das Carry-Flag an,
         ' ob ein Bit heraus- oder herumgeschoben wurde.
declare C8$, R8$               ' Übertrag und Resultat 8 Bit 
declare C9$, R9$               ' Übertrag und Resultat 9 Bit (ALU)
declare bit%                   ' Bitzähler
declare bit$                   ' Bit "0" oder "1"
declare b1$, b2$, b3$          ' einzelne Bits der Operanden, des Übertrags, des Schiebezählers
declare bc$, r$                ' Bit-Übertrag, Bit-Resultat
declare x%, y%, mk%, mk$       ' Mausoordinaten x%, y% und eine Maustaste gedrückt: mk%  1 --> mk$  "1" 
declare ip%, jp%               ' Zeilen- und Spaltenindex der Maxipixel des MGA-Displays (Micro-Graphic-Adapter)
declare pix$                   ' MGA-Pixel (0 oder 1)
declare mgapix$                ' MGA Adresse Pixel/Status (7 Bit aus RAM Zeile 247 = hF7)
declare b_res$                 ' Byte mit Ergebnis/ Zwischenergebnis einer Operation
declare temp%                  ' globale temporäre ganze Zahl zur Zwischenspeicherung
declare btemp1$, btemp2$       ' globales temporäres Byte, Zwischenspeicherung
declare iofile$                ' Kanaldatei (intern), I/O-Datei mit Befehl STO speichern/ mit RCL zu laden
declare asmfile$               ' HC 680 Assemblerdatei
declare asm$                   ' Asseblerzeilen in Datei
declare l_asm%                 ' Länge der Assemblerzeile
declare takt!                  ' variabler Takt des Prozessors
declare ms%                    ' Taktwartezeit im Millisekunden
declare t0%                    ' Basiswert CPU-Zeit
declare t%                     ' CPU-Zeit
declare debugfile$             ' Debug-Datei 
declare debug$                 ' Debug zum IC-Stand
declare breakp$                ' Breakpoint    hexadezimaler Vergleichswert
declare break1$                ' Breakpoint 1, hexadezimal
declare break2$                ' Breakpoint 2, hexadezimal
declare break3$                ' Breakpoint 3, hexadezimal
declare ramr$                  ' Ram-Zeile, Inhalt
declare row%                   ' berechnete Nummer der RAM-Zeile, Hilfsvariable
declare mgarow$                ' Zeileninhalt im MGA-Display
declare pv$                    ' Programm von - hexadezimale Adresse zur Speicherung
declare pb$                    ' Programm bis - hexadezimale Adresse zur Speicherung
declare dv$                    ' Daten    von - hexadezimale Adresse zur Speicherung
declare db$                    ' Daten    bis - hexadezimale Adresse zur Speicherung
declare bin8$                  ' Binärzahl 8-Bit 
declare hex2$                  ' Hexadezimalzahl, 2 Stellen 
declare hex1$                  ' Hexadezimalziffer
declare sp_h$                  ' variable Leerzeichen vor h für hexadezimalen Wert im RAM
declare msg%                   ' Meldungsergebnis
declare taste%                 ' Tastencode in Ereignisschleife, beenden mit Taste 27 (ESC)
declare key$                   ' Taste bei Programmlauf (Binärcode --> RAM Zeile 246 = hF6)
declare mn$[]                  ' Feld für Mnemonics des Assemblers
declare op$[]                  ' Feld für Operanden 1 und 2 für Assemberbefehle
declare R%[3]                  ' Registerfeld:         R%[0]= DO, R%[1]= D1, R%[2]= AO, R%[3]= A1
declare S%[3]                  ' Schattenregisterfeld: S%[0]=SDO, S%[1]=SD1, S%[2]=SAO, S%[3]=SA1
declare comment$[]             ' Kommentarfeld für Befehle und Konstanten
declare mga$[]                 ' RAM-Zeilen MGA-Display, Inhalt 
declare hlp$[]                 ' Feld, Inhalt der Strukturhilfe Assembler-Befehle
var ramrow%    = 0             ' Zeilennummer im RAM
var sta%       = 0             ' Standard-Startadresse dez
var sta$       = "00"          ' Standard-Startadresse hex
var coderow%   = 0             ' Nummer Befehlszeile (ab h00 ist Standard)
var ic_dez%    = 0             ' dezimaler Wert Instruction Counter IC
var ic_dez_fl% = 0             ' dezimal IC - zum Eintrag der vom Befehl gesetzten Flags merken
var conrow%    = 128           ' Nummer Konstantenszeile
var starow%    = 245           ' Vorgabe,  Stackzeile (Basisadresse)
var verschbg%  = 0             ' Verschiebung Assembler im Ram
var halt%      = 0             ' Programm anhalten durch Bediener: 1
var stop%      = 0             ' nach STP-Befehl oder Fehler: 1
var break%     = 0             ' Bedienerabbruch mit X STOP: 1
var break123%  = 0             ' nach einem der drei Breakpoints: 1
var timeover%  = 0             ' Timer abgelaufen
var onestep%   = 0             ' bei Einzelschritt auf weiter geklickt: 1 
var nospeed%   = 0             ' Programmausführung im Einzelschritt: 1
var afterstep% = 0             ' nach Programmausführung im Einzelschritt: 1  (zur Wiederherstellung Status Startknopf)
var fullspeed% = 0             ' ab > 255Hz fullspeed = 1 (merken, kein Halt, bei Bedarf Takt verringern)
'}
'{--- Oberfläche RAM und CACHE ---------------------------------------
drawtext 18,1, "  Random Access Memory     -        256 Byte RAM"
'roundrect 2,16,385,684,20,20
var ramkopf$ = "Adresse;0;75;hex;2;36;Inhalt;2;83;Befehl/Wert;0;116;FLAG;0;44;"  
var RAM%     = create("Gridbox", %hwnd, ramkopf$, 0, 4, 18, 379, 664)              'RAM - Gridbox
setfont RAM%, font% 
'
if htt%   ' Wird bei Programmlauf immer ausgeblendet- störend! (deshalb variable toolRAM$ zum Einblenden)  
  var toolRAM$ = "RAM        8 Bit Adressen / 256 Byte RAM, Spalte für Assembler und gesetzte Flags" \
                + "\n" \
                + "\nMaschinenbefehl je 1 Byte inklusive Operanden (bei LDC Konstante im Folgebyte)" \
                + "\nDaten/Zahlenraum: dezimal -128 ... 127 "\
                + "\n" \
                + "\nKlicken Sie auf eine Zeile im RAM, um einen Assembler-Befehl" \
                + "\noder konstante Daten (ab hexadezimal 80) im Assemblerbereich einzugeben." \
                + "\n" \
                + "\nfeste Adressen: " \
                + "\nF5 Basisadresse Stackpointer" \ 
                + "\nF6 Tastaturbyte" \
                + "\nF7 Status MGA-Display (Pixelbyte, siehe Kurzanleitung) " \ 
                + "\nF8 bis" \
                + "\nFF     Zeilen MGA-Display" \
                + "\n" \
                + "\nAktuell gesetzte Flags werden beim Programmlauf angezeigt." \
                + "\n " 
  var toolRAM% = create("Tooltip",%hWnd,RAM%,toolRAM$)
endif  
'
whileloop 0,255                                 ' RAM-Adressen erzeugen, Inhalt Null
  bin8$ = d255_to_bin8(&loop)
  hex2$ = dez_to_hex2(&loop)
  ramr$ = bin8$ + "|" + hex2$ + "|" + "00000000" +"|"
  case &loop < 128 : ramr$ = ramr$ + "NOP"
  case &loop > 127 : ramr$ = ramr$ + "0    h00"
  addstring(RAM%, ramr$)
endwhile
settext RAM%, 245,4,"<-SP"                      ' Basisadresse STACKPOINTER
settext RAM%, 246,4,"->Ta"                      ' Pufferbyte für Tastatur
settext RAM%, 247,4,">Pix"                      ' MGA Display Pixel
whileloop 248,255  
   settext RAM%,  &loop,4,"row"+str$(&loop-247) ' MGA Display Zeile (1 bis 8)
endwhile 
'
var xram%    = create("Button" , %hWnd, "X", 170,  684,  17,  17)
setfont xram%, xfont%  
if htt% 
  create("Tooltip",%hWnd,xram%,"VORSICHT! \nDen gesamten RAM, die Flag-Spalte und die Kommentare nach Sicherheitsabfrage löschen.\n ")
endif
drawtext 50, 684,"RAM/Flags löschen"
'
var xflag%    = create("Button" , %hWnd, "X", 323, 684,  17,  17)
setfont xflag%, xfont%  
if htt% 
  create("Tooltip",%hWnd,xflag%,"ACHTUNG! \nDie Spalte der zuletzt gesetzten Flags ohne Sicherheitsabfrage löschen.\n ")
endif
drawtext 235, 684,"Flags löschen"
'
var CACHE% = create("gridbox", %hwnd," ;2;16;CACHE;2;80", 0, 388, 330, 105, 352)  'Cache - Gridbox
setfont CACHE%, font% 
if htt% 
 create("Tooltip",%hWnd,CACHE%,"Beim Programmlauf werden den aktuellen Befehl umgebende Maschinenbefehle geladen.")
endif
whileloop 0,15
  addstring(CACHE%,space$(1)+"|"+space$(8)) ' Cache mit Leerzeichen initialisieren für settext
endwhile
hide(CACHE%)
var shcache%  = create("checkbox", %hWnd,"",450, 684, 17, 17) ' CACHE anzeigen / verbergen
case  htt% : create("Tooltip",%hWnd,shcache%,"Sichtbarkeit des CACHE. ")  
drawtext 400, 684,"CACHE"

'}--------------------------------------------------------------------------------------------
'{--- Oberfläche I/O-System ------------------------------------------
drawtext 500, 1, " I/O-System      Input       MGA-Display      Output " 
drawtext 890, 1, "I/O-Protokoll"                    ' zugehörige Controls siehe unten
usebrush 1, chipc%                        
roundrect 500, 16,877,104,20,20
fill 800,50, black%
textcolor black%, chipc% 
' --- Eingabe ---
drawtext 525,  18,"Eingabe:        ANSI"
drawtext 730,  18,"Ausgabe:  ANSI"
var inp%   = create("Edit", %hWnd, "", 525, 38, 38, 20) ' Eingabe: dezimal/ Zeichen
setfont inp% , font% 
if htt% 
  create("Tooltip",%hWnd,inp%,"Laufende Eingabe eines Tastaturzeichens. Eingabe mit Alt xxxx möglich." \
                              + "\nDie Eingabe erfolgt zu jedem Takt auch ohne in das Eingabefeld zu klicken!"  \
                              + "\nDer binäre ANSI-Code wird bei Adresse hF6 abgelegt." \
                              + "\n" \
                              + "\nBeim Befehl INP alternativ auch Eingabe einer Dezimalzahl im Bereich -128 ... 127 " \
                              + "\noder Eingabe einer Hexadezimalzahl in der Form hxx bzw. Hxx oder $xx." \
                              + "\nHexadezimalziffern 0..9, A..F oder a..f - ungültige Ziffern werden in 0 umgewandelt." \
                              + "\nBei INPut ist die Eingabe mit OK zu quittieren." \
                              + "\nDie Eingabe wird dann im Register und bei Adresse hF6 gespeichert " \
                              + "\nund im Ein-Ausgabeprotokoll angezeigt. Die Darstellung erfolgt dort nach dem" \
                              + "\nInhalt der IO Bits im Status Register: 00 Zeichen, 01 dezimal, 10 hexadezimal, 11 binär." \
                              + "\n " )
endif
hide(inp%)                                              ' nur bei Bedarf anzeigen
var altinp%= create("Text", %hWnd, "", 570, 38, 35, 16) ' alternativ: Zahl/Code | Code/Zahl
setfont altinp% , font% 
var inp_ok%=create("Button",%hWnd,"OK",620, 56, 38, 20) ' Eingabe OK
setfont inp_ok%, xfont% 
case htt% : create("Tooltip",%hWnd,inp_ok%,"Die Eingabe mit Klick auf OK quittieren.")
hide(inp_ok%)                                           ' nur bei Bedarf anzeigen
var ans%   = create("Text", %hWnd, "", 612, 38, 27, 16) ' ANSI-Code bei Zeicheneingabe
setfont ans% , font% 
var binp%  = create("Text", %hWnd, "", 510, 59, 66, 16) ' Eingabe binär
setfont binp% , font% 
var hinp%  = create("Text", %hWnd, "", 585, 59, 32, 16) ' Eingabe hexadezimal
setfont hinp% , font% 
drawtext 506, 82,"Datei" 
var i_ch%  = create("Edit", %hWnd, "input.hcx", 538, 80,118, 18) ' Eingabekanal (Vorgabe Datei)
setfont i_ch% , afont%
if htt% 
  create("Tooltip",%hWnd,i_ch%,"Daten-Datei zum Einlesen mit dem Befehl RCL." \
                               + "\n" \
                               + "\nDateistruktur: Textdatei, ein Wert je Zeile." \
                               + "\nInhalt der Datei - Interpretation nach IO Bits im Statusregister " \
                               + "\n" \
                               + "\n 00 Tastaturzeichen  " \
                               + "\n 01 Dezimalzahlen -128 ... 127" \
                               + "\n 10 Hexadezimalzahlen zweistellig xx   " \
                               + "\n 11 Binärzahlen 8 Bit " \
                               + "\n" \
                               + "\nWurden keine Daten gelesen, wir das Z-Flag gesetzt." \
                               + "\nSind zu viele Daten in der Datei, wird am Ende des RAM abgebrochen und das V-Flag gesetzt. " \
                               + "\nEs wird auch durch Werte die den Bereich nicht beachten gesetzt." \
                               + "\nIst kein Dateiname eingetragen, wird die Dateiauswahl angezeigt." \
                               + "\n " )
endif                             
drawtext 658, 82,"Ein   -"
drawtext 707, 82,"Aus" 
'
' --- MGA Display  -  Micro-Graphic-Adapter 8x8, S/W "Maxipixel"  ---
var Mx%  = 664
var My%  =  20 
var Md%  =   6 
var Mxe% = Mx% + 8*Md% +1
var Mye% = My% + 8*Md% +1
roundrect (Mx%-1),(My%-1),(Mxe%+1),(Mye%+1),Md%,Md%  ' äussere Umrandung
usebrush 1, white%   
fill Mx%+4*Md% ,My%+4*Md%, black%
usepen 0,1,grey%
roundrect Mx%,My%,Mxe%,Mye%,(Md%-2),(Md% -2) 
whileloop Md% , 7*Md% , Md%                     ' Gitternetzlinien, Trennung der "Maxipixel"
  line Mx%+1,My%+&loop,Mxe%-1,My%+&loop
  line Mx%+&loop,My%+1,Mx%+&loop,Mye%-1 
endwhile
usepen 0,1,black%  ' wieder Standard
' --- Ausgabe ---
var boutp% = create("Text", %hWnd, "", 733, 59, 66, 16) ' Ausgabe binär
setfont boutp% , font% 
var houtp% = create("Text", %hWnd, "", 805, 59, 32, 16) ' Ausgabe hexadezimal
setfont houtp% , font% 
var outp%  = create("Text", %hWnd, "", 733, 38, 44, 16) ' Ausgabe dezimal vorzeichenbehaftet
setfont outp% , font% 
var ansout%= create("Text", %hWnd, "", 793, 38, 27, 16) ' Ausgabe ANSI-Code
setfont ansout% , font% 
var coutp% = create("Text", %hWnd, "", 823, 38, 11, 16) ' Ausgabe Zeichen
setfont coutp% , font% 
var o_ch%  = create("Edit", %hWnd, "output.hcx", 733, 80,118, 18) ' Ausgabekanal  (Vorgabe Datei)
setfont o_ch% ,afont%
if htt% 
  create("Tooltip",%hWnd,o_ch%,"Ausgabe in Daten-Datei mit dem Befehl STO."\
                               + "\n" \
                               + "\nDateistruktur: Textdatei, ein Wert je Zeile." \
                               + "\nInhalt der Datei - Interpretation nach IO Bits im Statusregister " \
                               + "\n" \
                               + "\n 00 Tastaturzeichen  " \
                               + "\n 01 Dezimalzahlen -128 ... 127" \
                               + "\n 10 Hexadezimalzahlen zweistellig xx   " \
                               + "\n 11 Binärzahlen 8 Bit " \
                               + "\n" \                               
                               + "\nWurden keine Daten geschrieben, wir das Z-Flag gesetzt." \
                               + "\nIst kein Dateiname eingetragen, wird die Dateiauswahl angezeigt." \
                               + "\n " )
endif                               
' ---  Ein-Ausgabe Protokoll ---
var IO% = create("gridbox", %hwnd, ">Ein;2;48;Aus>;2;52;", 0, 878, 18, 127, 432)  'I/O - Gridbox
setfont IO% , spfont% 
if htt% 
  create("Tooltip",%hWnd,IO%,"Ein- und Ausgabe Protokoll" \
                               + "\nBefehle INP und OUT  - Darstellung der Werte " \
                               + "\n" \  
                               + "\nInterpretation nach IO Bits im Statusregister " \
                               + "\n" \  
                               + "\n 00 Tastaturzeichen  " \
                               + "\n 01 Dezimalzahlen -128 ... 127 " \
                               + "\n 10 Hexadezimalzahlen zweistellig hxx  " \
                               + "\n 11 Binärzahlen 8 Bit (über beide Spalten!)" \
                               + "\n                                    >Eingabe." \
                               + "\n                                    .Ausgabe> " \
                               + "\n " )
endif                               
hide(IO%)                                                ' I/O-Protokoll vorerst verbergen
var shio%  = create("checkbox", %hWnd,"",970, 1, 17, 17) ' für I/O-Protokoll anzeigen / verbergen
case htt% : create("Tooltip",%hWnd,shio%,"Sichtbarkeit des Ein- und Ausgabe Protokolls. ")
var clrio% = create("Button", %hWnd,"X",980, 450, 17, 17)  ' I/O-Protokoll löschen
setfont clrio%, xfont%
case htt% : create("Tooltip",%hWnd,clrio%,"Ein- und Ausgabe Protokoll ohne Nachfrage löschen.")
hide(clrio%) 
'}
'{--- Oberfläche CPU -------------------------------------------------
textcolor black% , backgrdc%
drawtext 500,109,"Prozessor HC680               CPU - Central Processing Unit"
usebrush 1,chipc%
roundrect 500,125,877,450,20,20
fill 650, 130, black%  
'
usefont "Arial", 10,4,0,0,0                    ' kleine Schrift
textcolor grey% , chipc%    '################
drawtext 846,156,               "26.03.14"     ' Datumsstempel Build
'                            ################
usefont "Arial", 16,6,0,0,0                    ' Standardschrift für das Fenster wieder einstellen
' --- Register ---
textcolor black% , chipc% 
drawtext 510,126,"Datenregister       Schattenregister"
drawtext 505,142,"D0                   00             SD0"
R%[0]  =  create("Text", %hWnd, "00000000", 520,158, 66, 16)   ' D0 Register: 00 binär
setfont R%[0], font% 
var r0val% = create("Button", %hWnd, "",    510,173, 86, 8)      ' Hilfsbutton für Tooltipp
var toolr0val% = create("Tooltip",%hWnd,r0val%, "0 = h00")         ' dezimale und hexadezimale Anzeige im Tooltip
S%[0]  = create("Text", %hWnd, "00000000",620,158, 66, 16)     ' SD0 Register - Schattenregister zu D0
setfont S%[0], font% 
var SD0val% = create("Button", %hWnd, "",    610,173, 86, 8)      ' Hilfsbutton für Tooltipp
var toolSD0val% = create("Tooltip",%hWnd,SD0val%, "0 = h00")         ' dezimale und hexadezimale Anzeige im Tooltip
'
drawtext 505,185,"D1                   01             SD1"
R%[1]  =  create("Text", %hWnd, "00000000", 520,201, 66, 16)   ' D1 Register: 01 binär
setfont R%[1] , font% 
var r1val% = create("Button", %hWnd, "",    510,216, 86, 8)      ' Hilfsbutton für Tooltipp
var toolr1val% = create("Tooltip",%hWnd,r1val%, "0 = h00")         ' dezimale und hexadezimale Anzeige im Tooltip
S%[1] = create("Text", %hWnd, "00000000",620,201, 66, 16)      ' SD1 Register - Schattenregister zu D1
setfont S%[1], font% 
var SD1val% = create("Button", %hWnd, "",    610,216, 86, 8)      ' Hilfsbutton für Tooltipp
var toolSD1val% = create("Tooltip",%hWnd,SD1val%, "0 = h00")         ' dezimale und hexadezimale Anzeige im Tooltip
'
drawtext 512,234,"Adressregister" 

drawtext 505,248,"A0                   10             SA0"
R%[2]  =  create("Text", %hWnd, "00000000", 520,264, 66, 16)   ' A0 Register: 10 binär 
setfont R%[2], font% 
var r2val% = create("Button", %hWnd, "",    510,279, 86, 8)      ' Hilfsbutton für Tooltipp
var toolr2val% = create("Tooltip",%hWnd,r2val%, "0 = h00")         ' dezimale und hexadezimale Anzeige im Tooltip
S%[2]  = create("Text", %hWnd, "00000000",620,264, 66, 16)     ' SA0 Register - Schattenregister zu A0
setfont S%[2], font% 
var SA0val% = create("Button", %hWnd, "",    610,279, 86, 8)      ' Hilfsbutton für Tooltipp
var toolSA0val% = create("Tooltip",%hWnd,SA0val%, "0 = h00")         ' dezimale und hexadezimale Anzeige im Tooltip
'
drawtext 505,291,"A1                   11             SA1"
R%[3]  =  create("Text", %hWnd, "00000000", 520,307, 66, 16)   ' A1 Register: 11 binär
setfont R%[3] , font%
var r3val% = create("Button", %hWnd, "",    510,322, 86, 8)      ' Hilfsbutton für Tooltipp
var toolr3val% = create("Tooltip",%hWnd,r3val%, "0 = h00")         ' dezimale und hexadezimale Anzeige im Tooltip
S%[3]  = create("Text", %hWnd, "00000000",620,307, 66, 16)     ' SA1 Register - Schattenregister zu A1
setfont S%[3], font% 
var SA1val% = create("Button", %hWnd, "",    610,322, 86, 8)      ' Hilfsbutton für Tooltipp
var toolSA1val% = create("Tooltip",%hWnd,SA1val%, "0 = h00")         ' dezimale und hexadezimale Anzeige im Tooltip
'
drawtext 565,335,"Instruction Register - IR"
var IR% = create("Text", %hWnd, "00000000", 620,351, 66, 16)   ' Instruction Register
setfont IR%, font% 
'
var set_IC%  = create("Edit", %hWnd,"00", 581, 386, 20, 20)    ' Adresse IC / Startadresse des Programms            
setfont set_IC%, font% 
case htt% : create("Tooltip",%hWnd,set_IC%,"Instruction Counter/ Befehlsadresse neu setzen (hexadezimal).")
'
hide (set_IC% )                    ' vorerst verbergen, nur bei Programmhalt:   show_set_IC  ' Control mit Text anzeigen
'
drawtext 567,370,"Instruction Counter - IC"
var IC% = create("Text", %hWnd, "00000000", 620,386, 66, 16)     ' Instruction Counter  (wird dann auf Startadr gesetzt!)
setfont IC%, font% 
var ICval% = create("Button", %hWnd, "",    610,401, 86, 8)      ' Hilfsbutton für Tooltipp
var toolICval% = create("Tooltip",%hWnd,ICval%, "Adr 0 = h00")   ' Adresse, dezimale,  hexadezimale Anzeige im Tooltip
'
drawtext 565,418,"Startadr."
drawtext 690,418,"- ST"
var ST% = create("Text", %hWnd, "00000000",620,420, 66, 16)      ' Startadresse Register - wird in Ereignisschleife gesetzt
setfont ST%, font% 
var STval% = create("Button", %hWnd, "",   610,435, 86, 8)       ' Hilfsbutton für Tooltipp
var toolSTval% = create("Tooltip",%hWnd,STval%, "Adr 0 = h00")   ' Adresse, dezimale,  hexadezimale Anzeige im Tooltip
'
drawtext 725,335,"Status Register - SR"
usefont "Lucida Console" , 14, 8,0,0,0                           ' Schrift wie font% im Textfeld SR Register
drawtext 755,373,"IOXY"                                          ' SR High Nibble
drawtext 788,373,"NZVC"                                          ' SR Low  Nibble: Flags
usefont "Arial", 16,6,0,0,0                                      ' wieder Standardschrift für das Fenster
drawtext 788,385, "FLAG"
var SR% = create("Text", %hWnd, "00000000", 755,351, 66, 16)     ' Status Register
setfont SR%, font% 
var SRval% = create("Button", %hWnd, "",    745,366, 86, 8)      ' Hilfsbutton für Tooltipp
var IO_SRtxt$ = ""
if htt% 
  var SRhlp$ = "Status Register Bits IOXYNZVC" \
                + "\n " \
                + "\nEin- und Ausgabe Bits IO  " \
                + "\n 00 Tastaturzeichen  " \
                + "\n 01 Dezimalzahlen -128 ... 127" \
                + "\n 10 Hexadezimalzahlen zweistellig xx   " \
                + "\n 11 Binärzahlen 8 Bit " \
                + "\n "  \
                + "\nBits XY vom System nicht genutzt" \
                + "\n- frei verfügbar - " \
                + "\n "  \ 
                + "\nFlags " \
                + "\n N   Negative (Negativ) " \
                + "\n Z   Zero (Null) " \
                + "\n V   oVerflow (Überlauf) " \
                + "\n C   Carry (Übertrag) " \         
                + "\n "
else
  var  SRhlp$ = "00 Tastaturzeichen"+"\n "+"\nN   =  0"+"\nZ   =  0"+"\nV   =  0"+"\nC   =  0"   ' für aktuellen Wert im Tooltipp
endif 
var toolSRval% = create("Tooltip",%hWnd, SRval%, SRhlp$)         ' Anzeige im Tooltip
'
drawtext 735,404,"Stack Pointer - SP"
var SP% = create("Text", %hWnd, "00000000", 755,420, 66, 16)     ' Stack Pointer, Basisadr. wird bei Programmstart gesetzt!
setfont SP%, font% 
var SPval% = create("Button", %hWnd, "",    745,435, 86, 8)      ' Hilfsbutton für Tooltipp
var toolSPval% = create("Tooltip",%hWnd,SPval%, "Adr 0 = h00   (Basis nach Start 245 = hF5)") ' Adresse, dezimale, hexadezimale Anzeige im Tooltip

' --- Arithmetic Logic Unit -----   
drawtext 702,174,"Arithmetic Logic Unit"
line 698,191,750,191                                  ' ALU-Symbol
lineto 760,203
lineto 770,191
lineto 819,191
lineto 799,280
lineto 719,280
lineto 698,191
line 722,259,796,259 ' Ergebnisstrich                  ' Rechenwerk 9 Bit:
var AL1%  = create("Text", %hWnd, "", 722, 210, 74, 15)  ' ALU Speicher 1 / Operand
setfont AL1% , font% 
var AL2%  = create("Text", %hWnd, "", 722, 227, 74, 15)  ' ALU Speicher 2 / Operand
setfont AL2% , font% 
var ALC%  = create("Text", %hWnd, "", 722, 244, 74, 15)  ' ALU Speicher 3 / Übertrag
setfont ALC% , font% 
var ALR%  = create("Text", %hWnd, "", 722, 261, 74, 15)  ' ALU Speicher 4 / Resultat
setfont ALR% , font% 
'
drawtext 730,284,"bitweise"
var alu_bitw% = create("CheckBox", %hWnd, "",782,284,16,16)
setfont alu_bitw% , font% 
case htt% : create("Tooltip",%hWnd,alu_bitw%, "Den Rechenablauf in der ALU bitweise darstellen." \
                                              + "\n " \
                                              + "\nWährend der bitweisen Darstellung in der ALU:" \
                                              + "\n *  keine laufende Tastatureingabe" \
                                              + "\n *  keine Mausbehandlung" \
                                              + "\n *  kein Anhalten mit Startknopf möglich" \
                                              + "\n " )
'
' temporäre Controls für temporäre ALU-Register zur Multiplikation und Division
var booth% = create("Button", %hWnd, chr$(187)+" Booth",804,278,68,15)
setfont booth% , sfont% 
if htt%  
  create("Tooltip",%hWnd,booth%,"--- Multiplikation nach Booth ---" \
                              + "\n " \
                              + "\nDas Register D0 wird im temporären ALU-Register A zwischengespeichert (für Addition)."\
                              + "\nDas Zweierkomplement -D0 wird gebildet und im temporären Register S gespeichert." \
                              + "\nIn der unteren Zeile wird schrittweise das 16Bit Ergebnis errechnet, dazu wird das linke Byte  " \
                              + "\nmit 0 initialisiert und rechts D1 abgelegt und daneben das Hilfsbit x auf 0 gesetzt. " \
                              + "\n " \
                              + "\nDie Ablaufsteuerung erfolgt nach den letzten zwei Bits der Ergebniszeile (mit Hilfsbit x):" \
                              + "\n " \                              
                              + "\n>>  Die Ergebniszeile wird 1 Bit nach rechts geschoben, das Hilfsbit fällt raus," \
                              + "\n       links wird als Vorzeichenerweiterung das zum weggeschobenen Bit identische ergänzt." \
                              + "\n" \
                              + "\n00, 11           >>            nur  >>  " \            
                              + "\n01         add  >>           D0 wird addiert, dann >>  " \
                              + "\n10          sub  >>          -D0 wird addiert, dann >>  " \
                              + "\n " \
                              + "\nDas linke Byte der letzten Zeile wird als Zwischensumme jeweils in die oberste Zeile kopiert." \
                              + "\n(mit Vorzeichenerweiterung)" \
                              + "\nNach 8 Schritten ergibt sich das 16Bit Ergebnis (ohne Hilfsbit x) im unteren Doppelregister." \
                              + "\nDas rechte Byte (Low-Byte) wird nach D0 gebracht. " \
                              + "\nDanach Prüfung auf Darstellbarkeit im Bereich -128 .. 127 und setzen der Flags." \
                              + "\n ")
endif
hide(booth%) ' vorerst verbergen
'
var ASP%  = create("Button", %hWnd, " \ DIV  ", 728, 194, 68, 15) ' Zeiger: Schieben << >> sowie Bitvergleichsstellen | und ! im Dividenden
setfont ASP% , spfont% 
if htt%
  create("Tooltip",%hWnd,ASP%,"--- ganzzahlige Division mit Rest ---" \
                              + "\n " \
                              + "\nDie Vorzeichen von Dividend und Divisor werden in temporären ALU Speicherbits (Vz) abgelegt." \
                              + "\nVom Divisor D1 wird das Zweierkomplement gebildet (temporäre ALU-Register: N negativ, P positiv). " \
                              + "\nIst der Dividend in D0 negativ,  wird erst sein Zweierkomplement gebildet." \
                              + "\nDie Division der positiven Operanden wird mit ALU-Steuerbits über die ALU-Schieberegister S, D realisiert." \
                              + "\nDazu wird der positive Dividend in der ALU 'passend' über den positiven Divisor geschoben." \
                              + "\nErreicht wird das durch Bitvergleich der jeweils übereinander stehenden Bits der Operanden." \
                              + "\nDie Differenzbildung erfolgt dann durch Addition des negativen Devisors." \
                              + "\nDie relevanten Verschiebungen und Additionen erzeugen im temporären Lösungsregister L den Quotienten." \
                              + "\nAnhand der abgelegten Vorzeichen erfolgt nun eventuell die Vorzeichenänderung (Lösung, Rest)." \
                              + "\n " \
                              + "\nDie Steuerbits werden oben rechts in der ALU in folgender Reihenfolge dargestellt:" \
                              + "\n  f (first loop)   t (two)   a (add) " \
                              + "\n  " \
                              + "\n  f: Erster Gesamtdurchlauf im Bitvergleich von Dividend und Divisor (f = 1). " \
                              + "\n         Der Dividend wird bei Bedarf nach rechts in das Hilfsregister D des Dividenden verschoben." \
                              + "\n         Im Schiebezeiger Register S wird von links je eine 1 eingeschoben." \
                              + "\n  t: Im ersten Teilablauf werden von links die Bits verglichen (Symbol | )," \
                              + "\n         eventuell wird geschoben (Symbole <  > ).  Ergibt sich daraus, dass zur Größenbestimung" \
                              + "\n         auch die Folgebits im zweiten Teilablauf geprüft werden müssen (Symbol : ), wird t = 1 gesetzt." \
                              + "\n  a: Lösungsbit 1 wird an den Quotienten angehangen, dann Addition des negativen Devisors (aktueller Rest)," \
                              + "\n         ein Bit aus dem Hilfsregister D des Dividenden wird nachgeschoben (Symbol <- ).  "\                            
                              + "\n         Dies erfolgt nur, wenn im darüberstehenden Schiebezeiger Register S links noch eine 1 steht."\
                              + "\n " \
                              + "\nAnschließend erfolgt je nach Vorzeichenbit in Vz eventuell eine Vorzeichenumkehr. " \
                              + "\nDer Quotient wird nach D0, der Rest nach SD0 gebracht (Vorzeichen Rest wie Vorzeichen Dividend)." \
                              + "\n " )
endif
var ALf%  = create("Text", %hWnd, "", 839, 180,  8, 13)  ' ALU Speicher Division, erster Durchlauf (Schiebeoption >> bei 1 über 0)
setfont ALf% , spfont% 
var ALt%  = create("Text", %hWnd, "", 847, 180,  8, 13)  ' ALU Speicher Division Durchlauf zweite Teeilschleife
setfont ALt% , spfont% 
var ALa%  = create("Text", %hWnd, "", 855, 180,  8, 13)  ' ALU Speicher Division Addition von -abs(Divisor)
setfont ALa% , spfont%                             
var ALS%  = create("Text", %hWnd, "", 798, 195, 65, 13)  ' ALU Speicher für Schiebezähler Dividend
setfont ALS% , spfont% 
var AV1%  = create("Text", %hWnd, "", 712, 210,  8, 15)  ' ALU Speicher / Vorzeichen 1 für Division
setfont AV1% , spfont% 
var AV2%  = create("Text", %hWnd, "", 712, 227,  8, 15)  ' ALU Speicher / Vorzeichen 2 für Division
setfont AV2% , spfont% 
'
var ALBA%  = create("Text", %hWnd, "", 798, 210, 65, 15)  ' ALU Speicher, Multiplikation nach Booth / D0 für Addition
setfont ALBA% , font% 
var ALBS%  = create("Text", %hWnd, "", 798, 227, 65, 15)  ' ALU Speicher, Multiplikation nach Booth / Subtraktion (2er-Komplement)
setfont ALBS% , font% 
'
var ALD%  = create("Text", %hWnd, "", 798, 210, 65, 15)  ' ALU Speicher Dividend für shift >> und shift <<
setfont ALD% , font% 
var ALN%  = create("Text", %hWnd, "", 798, 227, 65, 15)  ' ALU Speicher  Divisor (Summand, 2er-Komplement)
setfont ALN% , font% 
'
var ALP%  = create("Text", %hWnd, "", 798, 244, 65, 15)  ' ALU Speicher positiver Divisor
setfont ALP% , font% 
var ARL%  = create("Text", %hWnd, "", 798, 261, 65, 15)  ' ALU Speicher Resultat/ Low-Byte von 16Bit    
setfont ARL% , font% 
var ALx%  = create("Text", %hWnd, "", 865, 261,  8, 15)  ' ALU Speicher Multiplikation nach Booth (extra Bit hinter Resultat/Low-Byte)
setfont ALx% , font% 
' Controls vorerst verbergen - nur für Multiplikation / Division 
hide(ALf%) : hide(ALt%) : hide(ALa%) : hide(ASP%) : hide(ALS%) : hide(AV1%) : hide(AV2%) 
hide(ALBA%): hide(ALBS%): hide(ALD%) : hide(ALN%) : hide(ALP%) : hide(ARL%) : hide(ALx%)      
'
' ----- Prozessor-Bild einfügen -----
if fileexists("_HC680.bmp") 
 drawpic "_HC680.bmp",786,127,-1, white%
else
 textcolor white% , chipc%
 drawtext 780, 140, "_HC680.bmp"
endif
'
'}
'{--- Oberfläche Programmierung Assembler ----------------------------  
create("GroupBox",%hWnd,"",495, 460, 510, 240) 
textcolor black% , backgrdc% 
usefont "Arial", 16,6,0,0,1         ' Standardschrift unterstrichen
drawtext 500,476,"Assembler /Programmierung"
usefont "Arial", 16,6,0,0,0         ' Standardschrift für das Fenster
drawtext 720,473,            "Programm"
drawtext 786,473,                     "| Daten:"
drawtext 680,489,"Startadr."
drawtext 742,489,            "von bis"
drawtext 786,489,                     "| von bis"
drawtext 714,504,"hex" 
var startadr% = create("Edit", %hWnd,"00", 690, 504, 20, 20) ' Startadresse des Programms ist h00 (Standard)    
setfont startadr%, font%                                     
case htt% : create("Tooltip",%hWnd,startadr%,"Hexadezimale Startadresse HC680 Binärcode.")
var prgvon% = create("Edit", %hWnd,"", 740, 504, 20, 20)    ' Anfangsadresse des Programms zur Speicherung            
setfont prgvon%, font% 
case htt% : create("Tooltip",%hWnd,prgvon%,"Hexadezimale Anfangsadresse des Binärcode zur Speicherung/ Verschiebung in der Assemblerdatei.")
var prgbis% = create("Edit", %hWnd,"", 765, 504, 20, 20)    ' Endadresse des Programms < 80 Hex zur Speicherung
setfont prgbis%, font% 
case htt% : create("Tooltip",%hWnd,prgbis%,"Hexadezimale Endadresse Programm - für Speicherung/ Verschiebung")
var datvon% = create("Edit", %hWnd,"", 790, 504, 20, 20)  ' Adresse Beginn Datenbereich ab 80 Hex
setfont datvon%, font% 
case htt% : create("Tooltip",%hWnd,datvon%,"Hexadezimale Datenadresse Anfang -  für Speicherung/ Verschiebung")
var datbis% = create("Edit", %hWnd,"", 815, 504, 20, 20)  ' Datenbereich bis Adresse zur Speicherung 
setfont datbis%, font% 
case htt% : create("Tooltip",%hWnd,datbis%,"Hexadezimale Datenadresse Ende - für Speicherung/ Verschiebung")
'
'--- Assemblerdatei Programmname, Speichern, Laden, Verschieben
var progname% =  create("Edit", %hWnd,"", 835, 473, 155, 20)
setfont progname%, font% 
var prognametxt$ = ""
var prgn$ = ""                  
if htt%
  prognametxt$ = "Name des Programms zum Speichern bzw. nach dem Laden: \n "
endif 
var toolprogname% = create("Tooltip",%hWnd,progname%, prognametxt$+prgn$)
'
drawtext 877,494,"Speichern"
var store% = create("Button", %hWnd,chr$(174),890,509, 25, 20)
setfont store%, symbolfont%  
if htt% 
  create("Tooltip",%hWnd,store%,"Speichern Sie eine HC680 Assemblerdatei ab." \
                              + "\n " \
                              + "\nDie Startadresse wird gespeichert. "\
                              + "\nEs werden von Anfangs- (min. 00) bis Endadresse (max. 7F) das Programm, " \
                              + "\nund die Daten von (min. 80) bis (max. FF) gespeichert." \
                              + "\nSind keine Werte eingetragen wird (der Teil) nicht gespeichert." \
                              + "\n " )
endif
drawtext 940,494,"Laden"  
var load% = create("Button", %hWnd,chr$(172),937,509, 25,20) 
setfont  load%, symbolfont%  
if htt%
  create("Tooltip",%hWnd,load%,"Laden Sie eine HC680 Assemblerdatei in den Arbeitsspeicher." \
                              + "\n " \
                              + "\nFehlerhafte Assemblerbefehle werden als NOP interpretiert." \
                              + "\nDer Doppelpunkt hinter der Befehlsadresse ist optional, dafür reichen ein oder zwei Leerzeichen." \
                              + "\nAuch die Punkte um die Operanden sind optional, dann ein bis vier Trenn-Leerzeichen setzen." \
                              + "\nIm Datenbereich ab Adresse h80 wird nur der linke Wert bzw. das Zeichen eingelesen." \
                              + "\nZur besseren Übersicht können die Daten rechtsbündig gesetzt werden."\
                              + "\nDer Doppelpunkt nach der Datenadresse kann entfallen, es sind bis zu fünf Leerzeichen gestattet." \
                              + "\nDie 2. Spalte (einheitlich hexadezimal) ist optional. Sie wird neu berechnet." \
                              + "\nAb Spalte 21 wird der Kommentar eingelesen, das Semikolon davor ist optional." \
                              + "\nBitte die in der Datei gespeicherte Startadresse beachten." \
                              + "\n " )
endif
drawtext 834,533,"um"
var verschieb% = create("Edit", %hWnd,"", 855, 532, 36, 17)  '  Verschiebung  
setfont verschieb%, font% 
var verstooltxt$ = ""
var umrech$      = ""  
if htt%
   ' Tooltext (mit aktuellem Wert) für Verschiebung Assembler im RAM
  verstooltxt$ = "  |  Verschiebung von Programm und/oder Daten im Speicher, dezimal oder hexadezimal (-)hxx bzw. Hxx, $xx" 
  umrech$      = " \n   - Umrechnung wird im Tooltip angezeigt -"
               
endif
var toolverschieb% = create("Tooltip",%hWnd,verschieb%, verstooltxt$ +umrech$)
'                            
drawtext 896,533,"Ver"
drawtext 935,533,"schieben"
var relocate% = create("Button", %hWnd,chr$(189),919,529,14,26) 
setfont  relocate% , symbolfont%   
if htt%
  create("Tooltip",%hWnd,relocate%,"Verschieben Sie die Assemblerbefehle und/oder die Daten im RAM." \
                              + "\n " \
                              + "\nDen Versatz dezimal oder hexadezimal hxx mit Vorzeichen angeben. "\
                              + "\nEs wird von den eingetragenen Anfangs- bis zu den Endadressen verschoben." \
                              + "\nDie vorhandenen Inhalte werden überschrieben, freie Zeilen auf Null gesetzt." \
                              + "\nDer RAM-Ausschnitt wird als   asm_tmp.txt   gespeichert." \
                              + "\nDer komplette RAM wird vorher unter   asm_bak.txt   gesichert." \
                              + "\n " )
endif
drawtext 500,510,"ASSEMBLER-BEFEHL "
drawtext 500,530,"Adr   Op Code   Mnemonic"
var codeup% = create("Button", %hWnd, chr$(173),  658, 534, 20, 20)        
setfont codeup%, symbolfont%  
case htt% : create("Tooltip",%hWnd,codeup%,"RAM - Adr. zurück")
drawtext 695,530,"Op. 1        Op. 2"
var codedown% = create("Button", %hWnd, chr$(175),  658, 556, 20, 20)
setfont codedown%, symbolfont% 
case htt% : create("Tooltip",%hWnd,codedown%,"RAM - Adr. vorwärts")
var cadr% = create("Text",%hWnd,"00", 500, 548, 18, 16)
setfont cadr%, font% 
var oc% = create("Text", %hWnd, "", 525, 548, 66, 16)  
setfont oc%, font% 
oc$ = "00000000"  'initialisieren
settext oc%, oc$
' --- Mnemonics ---
mn$[1] ="NOP"
mn$[2] ="CMP" 
mn$[3] ="SWD": mn$[4] ="SWM"
mn$[5] ="MUL": mn$[6] ="DIV"
mn$[7] ="PSA": mn$[8] ="POA"
mn$[9] ="JSR": mn$[10]="RET"
mn$[11]="JIN": mn$[12]="JIZ": mn$[13]="JMP"
mn$[14]="LDC": mn$[15]="## "                  '  ## nur zwei Zeichen + Leerzeichen
mn$[16]="INP": mn$[17]="OUT"
mn$[18]="PSH": mn$[19]="POP"
mn$[20]="SSR": mn$[21]="GSR"
mn$[22]="BTS": mn$[23]="SWN"
mn$[24]="SHL": mn$[25]="SHR"
mn$[26]="ROL": mn$[27]="ROR"
mn$[28]="CLR": mn$[29]="INC": mn$[30]="DEC"
mn$[31]="NOT": mn$[32]="AND": mn$[33]="OR "   ' OR nur zwei Zeichen + Leerzeichen
mn$[34]="ADD": mn$[35]="SUB"
mn$[36]="MOV"
mn$[37]="LOD"
mn$[38]="STO": mn$[39]="RCL": mn$[40]="CPY"
mn$[41]="STP" 
var mn% = create("ChoiceBox", %hWnd, 2, 600,545, 55, 650) : setfont mn%, font% ' Befehlsauswahl
case htt% : create("Tooltip",%hWnd,mn%,"Assembler  Befehls-Mnemonic auswählen oder eintragen")
whileloop 1, sizeof(mn$[])-1
  addstring(mn%,mn$[&loop])   ' Mnemonic-Auswahl füllen
endwhile
settext mn%,"NOP"
' --- Operanden ---
op$[1]= ".IA."  :  op$[2]= ".+A." 
op$[3]= ".D0."  :  op$[4]= ".D1." :  op$[5]= ".A0." :  op$[6]= ".A1." 
op$[7]= ".SR."  :  op$[8]= ".SP."
op$[9]= "[D0]"  : op$[10]= "[D1]" : op$[11]= "[A0]" : op$[12]= "[A1]"
op$[13]= "0000" : op$[14]= "0001" : op$[15]= "0010" : op$[16]= "0011" 
op$[17]= "0100" : op$[18]= "0101" : op$[19]= "0110" : op$[20]= "0111" 
op$[21]= "1000" : op$[22]= "1001" : op$[23]= "1010" : op$[24]= "1011" 
op$[25]= "1100" : op$[26]= "1101" : op$[27]= "1110" : op$[28]= "1111" 
op$[29]= ".00." : op$[30]= ".01." : op$[31]= ".10." : op$[32]= ".11." 
var op1% = create("ChoiceBox", %hWnd, 2, 680,545, 60, 800) : setfont op1%, font%
var op2% = create("ChoiceBox", %hWnd, 2, 745,545, 60, 800) : setfont op2%, font%
case htt% : create("Tooltip",%hWnd,op1%,"Assembler - 1.Operanden auswählen oder eintragen")
case htt% : create("Tooltip",%hWnd,op2%,"Assembler - 2.Operanden auswählen oder eintragen")
whileloop 1, 32                 ' 2Bit nicht im Befehlsbestand - Konformität der Anzeige
    addstring(op1%,op$[&loop])  
endwhile
whileloop 1, 32                 ' mit 2Bit für IO
    addstring(op2%,op$[&loop])  
endwhile
drawtext 520,564,"Flags"
var fl% = create("Text", %hWnd, "", 557, 566, 34, 16)  
setfont fl%, font% 
drawtext 810,562,"Kommentar zum Befehl"
var opcomm% =create("Edit", %hWnd, "", 600,579, 390, 20) : setfont opcomm%, afont% ' Kommentar zum Befehl
var toolopcomm% = create("Tooltip",%hWnd,opcomm%,"") ' wird in Ereignisschleife aktuell gesetzt
var opcommtxt$ = ""
case htt% : opcommtxt$ = "Geben Sie einen Kommentar zum Befehl ein - auch länger als Eingabefeld, wird im Tooltip sichtbar."
whileloop 0,255
 comment$[&loop] = ";"    ' Datenfeld auch für Kommentare zu Konstanten ab Zeile 128!
endwhile
' --- Hilfe ---
drawtext 800,661,"Liste der Assemblerbefehle"
var hlp%     = create("ChoiceBox", %hWnd, 0, 530,679, 460, 742) : setfont hlp%, sfont% 
' Tooltip wird laufend aktualisiert!
var toolhlp% = create("Tooltip",%hWnd,hlp%,"Wählen Sie den interessierenden Befehl zur Darstellung aus.")
' Listbox füllen - Übersicht/Hilfe zu Assemblerbefehlen - Kurzreferenz 
  hlp$[1]  = "Mnem OP OP    - Bedeutung Befehl/Adressierung -         FLAG "
  hlp$[2]  = " NOP          No OPeration                              .... "
  hlp$[3]  = " CMP          CoMPare D0, D1                            NZVC "
  hlp$[4]  = " SWD          SWap D0, D1                               .... "
  hlp$[5]  = " SWM          SWap Memory Adr(D0), Adr(D1)              .... "
  hlp$[6]  = " MUL          MULtiplication D0 <- D0*D1                NZVC "
  hlp$[7]  = " DIV          DIVision D0 <- D0\D1 Rest SD0             NZVC "
  hlp$[8]  = " PSA          PuSh All Stack <- A,D,SR Reg.             .... " 
  hlp$[9]  = " POA          POp All SR,D,A Reg. <- Stack              NZVC "
  hlp$[10] = " JSR          Jump SubR. S<-IC+1,IC<-IC+A1/IC<-A0+A1+ST .... "
  hlp$[11] = " JIN +A       N=1: IC <- IC + A1 Jump If Negative       .... "
  hlp$[12] = " JIZ +A       Z=1: IC <- IC + A1 Jump If Zero           .... "
  hlp$[13] = " JMP +A            IC <- IC + A1 JuMP                   .... "   
  hlp$[14] = " RET          RETturn subroutine IC <-Stack             .... "
  hlp$[15] = " LDC Rg       LoaD Constant   Reg xx <- next Byte ##    NZ.. "
  hlp$[16] = " ##  CCCC CCCC   ## Constant Byte                       .... "
  hlp$[17] = " JIN IA       N=1: IC <- A0 +A1 +ST Jump If Negative    .... " 
  hlp$[18] = " JIZ IA       Z=1: IC <- A0 +A1 +ST Jump If Zero        .... "
  hlp$[19] = " JMP IA            IC <- A0 +A1 +ST JuMP                .... "
  hlp$[20] = " JIN RG       N=1: IC <- Reg xx  Jump If Negative       .... "
  hlp$[21] = " JIZ RG       Z=1: IC <- Reg xx  Jump If Zero           .... "
  hlp$[22] = " JMP RG            IC <- Reg xx  JuMP                   .... "
  hlp$[23] = " INP RG       Reg xx           <- INPut                 NZ.. "
  hlp$[24] = " OUT RG       OUTput           <- Reg xx                .... "
  hlp$[25] = " PSH RG       PuSH Stack       <- Reg xx                NZ.. "  
  hlp$[26] = " POP RG       POP Reg xx       <- Stack                 NZ.. "
  hlp$[27] = " SSR RG       Set Shadow Register    Reg xx -> Sxx      NZ.. "
  hlp$[28] = " GSR RG       Get Shadow Register    Reg xx <- Sxx      NZ.. "
  hlp$[29] = " BTS RG       BitTest  Reg xx with Shadow Register      NZ.. "
  hlp$[30] = " SWN RG       SWap Nibble Reg xx                        NZ.. "
  hlp$[31] = " SHL RG       SHift Left     Reg xx                     NZ.C "
  hlp$[32] = " SHR RG       SHift Right    Reg xx                     .Z.C "
  hlp$[33] = " ROL RG       ROtate Left    Reg xx                     NZ.C "
  hlp$[34] = " ROR RG       ROtate Right   Reg xx                     NZ.C "
  hlp$[35] = " CLR RG       CLear Register Reg xx <- 0                .Z.. "
  hlp$[36] = " INC RG       INCrement      Reg xx                     NZVC "
  hlp$[37] = " DEC RG       DECrement      Reg xx                     NZVC "
  hlp$[38] = " NOT RG       Reg xx <- NOT Reg xx  (bitweise)          NZ.. "
  hlp$[39] = " AND RG  RG   Reg yy <- Reg yy  AND     Reg xx          NZ.. "
  hlp$[40] = " OR  RG  RG   Reg yy <- Reg yy  OR      Reg xx          NZ.. "  
  hlp$[41] = " ADD RG  RG   Reg yy <- Reg yy  +       Reg xx          NZVC "
  hlp$[42] = " ADD RG [RG]  Reg yy <- Reg yy  +   Adr(Reg xx)         NZVC "
  hlp$[43] = " SUB RG  RG   Reg yy <- Reg yy  -       Reg xx          NZVC "
  hlp$[44] = " SUB RG [RG]  Reg yy <- Reg yy  -   Adr(Reg xx)         NZVC "
  hlp$[45] = " MOV[RG] RG   MOVe  Adr(Reg yy)  <-     Reg xx          NZ.. "
  hlp$[46] = " MOV RG [RG]  MOVe      Reg yy   <- Adr(Reg xx)         NZ.. "
  hlp$[47] = " MOV RG  RG   MOVe      Reg yy   <-    Reg xx           NZ.. "
  hlp$[48] = " MOV RG  SR   MOVe      Reg yy   <-    SR               NZ.. "
  hlp$[49] = " MOV RG  SP   MOVe      Reg yy   <-    SP               NZ.. "
  hlp$[50] = " MOV SR  RG   MOVe      SR       <-    Reg xx           NZ.. "
  hlp$[51] = " MOV SP  RG   MOVe      SP       <-    Reg xx           NZ.. "
  hlp$[52] = " MOV SR  CC   MOVe      SR       <-    CC..  (2Bit IO)  .... "
  hlp$[53] = " MOV RG  IA   MOVe      Reg xx   <- Adr(A0+A1+ST)       NZ.. "
  hlp$[54] = " MOV IA  RG   MOVe Adr(A0+A1+ST) <-    Reg xx           NZ.. "
  hlp$[55] = " LOD RG       LOad Data Reg xx  <- Adr(h80+A1+ST)       NZ.. "
  hlp$[56] = " STO (IO)     STOre Datei <- Adr(h80+A1+ST) D0 Byte /D1 .Z.. "
  hlp$[57] = " RCL (IO)     ReCalL Adr(h80+A1+ST) <-Datei /D1  gel.D0 .ZV. "
  hlp$[58] = " CPY          CoPY Adr(A1)<-Adr(A0)  D0 Byte über D1    .ZV. "
  hlp$[59] = " STP          StoP P. anhalten, Flags vom. Vorbefehl    vvvv "
  whileloop 1, 59
    addstring(hlp%,hlp$[&loop])    'Kurzreferenz Hilfe zu Assembler füllen
  endwhile
'--- Dateneingabe ---
drawtext 500,594,"DATEN"
var conup%  = create("Button", %hWnd, chr$(173),  658,615, 20, 20) 
setfont conup%, symbolfont% 
case htt% : create("Tooltip",%hWnd,conup%,"RAM - Adr. zurück")
var condown%= create("Button", %hWnd, chr$(175),  658,637, 20, 20)
setfont condown%, symbolfont% 
case htt% : create("Tooltip",%hWnd,condown%,"RAM - Adr. vorwärts")
drawtext 500,610,"Adr      binär"
var conadr% = create("Text",%hWnd,"80", 500,628, 18, 16) : setfont conadr%, font% 
var conbin% = create("Text",%hWnd,  "", 525,625, 66, 16) : setfont conbin%, font%
drawtext 526,640,"hex"
var conhex% = create("Text",%hWnd,  "", 550,643, 18, 16) : setfont conhex%, font%
var coninp% = create("Edit",%hWnd,  "", 600,625, 56, 20) : setfont coninp%, font%
case htt% : create("Tooltip",%hWnd,coninp%,"Tastaturzeichen oder Dezimalzahl -128 ... 127 oder Hexadezimalzahl hxx (auch Hxx, $xx)")
var conalt% = create("Text",%hWnd,  "", 685,628, 35, 16) : setfont conalt%, font% 
drawtext 725,608,"ANSI"
var conans% = create("Text",%hWnd,  "", 725,628, 27, 16) : setfont conans%, font% 
drawtext 810,609,"Kommentar zu Daten"
var concomm% =create("Edit", %hWnd, "", 760,625,230, 20) : setfont concomm%, afont%
var toolconcomm% =create("Tooltip",%hWnd,concomm%,"") ' wird in Ereignisschleife aktuell gesetzt
var concommtxt$ = ""
case htt% : concommtxt$ = "Geben Sie einen Kommentar zur Konstanten ein - auch länger als Eingabefeld, wird im Tooltip sichtbar."
settext conbin%, "00000000"
settext conhex%, "00"
settext coninp%, "0"
'}
'{--- Oberfläche Anleitung, Programmlauf, Breakpoints, Debug, Takt ---
var shorthlp% = create("Button",%hWnd,"Kurzanleitung" ,387, 1, 109, 17) 
setfont shorthlp%  , spfont% 
var shtbtxt$ = "Bitte die jeweiligen Tooltipps beachten," \
  + "\nKurzanleitung in diesem Tooltip." \
  + "\n " \
  + "\nBild des Prozessors: _HC680.bmp im Programm-Ordner. " \
  + "\n " \
  + "\nIn der INI-Datei im Programm-Ordner einstellbar:" \
  + "\n[RGB Hintergrund] " \
  + "\nR=Wert" \
  + "\nG=Wert" \
  + "\nB=Wert" \
  + "\n " \
  + "\nDie einfachen Hilfe Tooltipps sind in der INI Datei abstellbar:" \
  + "\n[Hilfe Tooltipp]" \ 
  + "\nH=0 " \
  + "\nDie Tooltipps mit variablem Inhalt sind immer verfügbar." \
  + "\n " \
  + "\nNehmen Sie bitte auch die Referenz zum HC680 zur Kenntnis." \
  + "\n "
'  
var shorthlp$ = "Kurzanleitung:" \
            + "\n-------------"  \
  + "\n Beachten Sie bitte die Tooltipps zu den wesentlichen Elementen.                 " \
  + "\n " \
  + "\n Erstellen Sie ein Assembler/Maschinenprogramm durch Auswahl der Mnemonics und Operanden." \
  + "\n Ungültige Assemblerbefehle werden in NOP (00000000) umgewandelt. " \
  + "\n Speichern Sie den leeren RAM als Assembler und öffnen Sie die Datei, um die Struktur zu erkennen." \
  + "\n Assemblerdateien können mit einem Texteditor erstellt und bearbeitet werden." \
  + "\n Dabei sind zur einfacheren Notation Auslassungen möglich. Details siehe Tooltip Laden." \
  + "\n Laden Sie ein oder mehrere Assemblersequenzen unter Beachtung der Speicheradressen." \
  + "\n Obwohl die Darstellung des RAM nur bis Zeile 127 für Assemblerbefehle konzipiert ist, " \
  + "\n wird ein Maschinenrogramm auch darüberhinaus ausgeführt! " \
  + "\n Die RAM-Zeilen ab 128 sind konzeptionell für Daten, den Stack, den Tastatur- und Mauspuffer " \
  + "\n und den Micro-Graphic-Adapter (MGA-Display 8x8 'Maxi'-pixel) vorgesehen." \
  + "\n Läuft das Programm in diesen Bereich, werden die Bytes jedoch als Maschinenbefehle interpretiert!" \
  + "\n Ebenso können Daten in den Bereich bis Zeile 127 geschrieben und ausgeführt werden." \
  + "\n Die RAM-Zeilen 0 und 128 werden jedoch nach Manipulation bei Programmstop aus dem Edit " \
  + "\n im Assemblerbereich rekonstruiert." \
  + "\n " \
  + "\n Starten Sie das Maschinenprogramm mit dem grünen Startknopf. " \
  + "\n " \
  + "\n Das beim Programmlauf erscheinende Eingabefeld ist nicht anzuklicken, Tooltipp dazu beachten." \
  + "\n Als Tastaturpuffer dient das Byte mit der Adresse hF6. Es wird in jedem Takt gefüllt und ermöglicht " \
  + "\n mit dem Micro-Graphic-Adapter sogar elementare ereignisgesteuerte GUI-Programme." \
  + "\n Im RAM-Byte hF7 wird der MGA-Status abgelegt: | schwarz: 1 | Zeile: bbb | klick: 1 | Spalte: bbb |" \
  + "\n d.h. linkes Bit gesetzt: schwarz, drei Bit: Zeile, 1 Bit: klick = 1, drei Bit: Spalte." \
  + "\n Der Inhalt von Byte hF7 wird durch das System in jedem Takt ausgewertet, das adressierte Pixel gesetzt/gelöscht."\
  + "\n Bei Programmen, die auf Tastatur- und/oder Mausereignisse reagieren den Taktbereich experimentell ermitteln." \
  + "\n " \
  + "\n Bei Multiplikation und Division werden weitere ALU-Register und Buttons eigeblendet. Siehe Tooltips dazu." \
  + "\n " \
  + "\n Nehmen Sie bitte auch die Dokumentation der Simulation und das Manual zum HC680 zur Kenntnis." \
  + "\n "
case htt% : var toolshorthlp% =create("Tooltip",%hWnd,shorthlp%, shorthlp$) 
'
textcolor  grey%, backgrdc%     ' graue Schrift
drawtext 885,414,"http://"
drawtext 885,428,"cpusimulation.de"
textcolor black%, backgrdc%     ' Schriftfarbe Standard  
'
create("GroupBox",%hWnd,"",387, 10,109,318) 
drawtext 400,30, "HC680"
drawtext 400,44, "Binärcode"
ellipse  400,70,430,100        ' Startknopf Aussenring
usebrush 1,backgrdc%  
fill 402, 85, black%
ellipse  405,75,425,95         ' Startknopf
usebrush 1,richgreen%          ' Knopf sattgrün
fill 415, 85, black%
drawtext 390,100, "  ausführen       " 
var abbr%  = create("Button",%hWnd,"X",436, 75, 17, 17) ' Bedienerabbruch: X STOP
case htt% : create("Tooltip",%hWnd,abbr% ,"Programm mit x sofort abbrechen, \nsonst gelben Kreis klicken.")
setfont abbr%, xfont% 
hide(abbr%)
'
var bit_stp%  = create("Button",%hWnd," ... Bit ... ",390, 70, 102, 45) ' Startknopf,  x STOP, Takt  überdecken 
hide(bit_stp%)
var wait_inp%  = create("Button",%hWnd," Eingabe ... ",390, 70, 102, 45) ' Startknopf,  x STOP, Takt  überdecken 
hide(wait_inp%)
' 
drawtext 427,125,"Takt:"       ' variable Taktfrequenz des Prozessors

whileloop 0,7
  line 400,142+7*&loop,405,142+7*&loop  ' symbolische Linien - linearer Skalenbereich
endwhile  
var takt_scroll% = Create("VScroll",%hWnd,"",405,125,14,180)
setscrollrange takt_scroll%,0,255  ' siehe Skalenrechnung 
setscrollpos takt_scroll%,10       ' 
if htt%  
  create("Tooltip",%hWnd,takt_scroll%, " --- Frequenzwahl ---"  \
                                      + "\n " \
                                      + "\n Einzelschritt (oben), dann Taktfrequenz von 0,1 bis 255Hz, dann ungebremst." \
                                      + "\n " \
                                      + "\n- Die Frequenz ist auch während des Programmlaufs änderbar." \
                                      + "\n   Im Einzelschritt sind die Breakpoints bearbeitbar." \
                                      + "\n   Bei höherer Frequenz eventuell schnell hintereinander klicken, um Halt zu erreichen " \
                                      + "\n   bzw. 'bitweise' zu ändern. Eventuell Frequenz vorher stark verringern." \
                                      + "\n   Ein Halt ist stets durch Klick auf den Schieber im Scrollbalken des RAM erreichbar." \
                                      + "\n " \
                                      + "\n- ab 10Hz nichtlineare Skale." \
                                      + "\n " \
                                      + "\n- Über 255Hz ungebremst: " \  
                                      + "\n   * Keine laufende Tastatureingabe, keine Mausbehandlung -'volle' Geschwindigkeit." \
                                      + "\n   * Keine Detaildarstellungen des Ablaufs." \
                                      + "\n " )
endif
var takthz%=create("Text",%hWnd,"", 422,145, 42, 16) : setfont takthz%, font% 
drawtext 465,145,"Hz"
var nextstep%  = create("Button",%hWnd,"weiter", 420, 160, 60, 22)
setfont nextstep%, font% 
'
drawtext 423,185,"Breakpoints"
var breakpt1%  = create("Edit",%hWnd,"", 440, 202, 20, 20)
setfont breakpt1%, font% 
if htt% 
  create("Tooltip",%hWnd,breakpt1%,"Breakpoint 1" \
                                      + "\nHexadezimale Adresse, ein Einzelschritt." \
                                      + "\nWird bei Takt >255Hz nicht berücksichtigt." )
endif
var breakpt2%  = create("Edit",%hWnd,"", 440, 224, 20, 20)
setfont breakpt2%, font% 
if htt% 
  create("Tooltip",%hWnd,breakpt2%,"Breakpoint 2" \
                                      + "\nHexadezimale Adresse, ein Einzelschritt." \
                                      + "\nWird bei Takt >255Hz nicht berücksichtigt." )
endif
var breakpt3%  = create("Edit",%hWnd,"7F", 440, 246, 20, 20)
setfont breakpt3%, font% 
if htt% 
  create("Tooltip",%hWnd,breakpt3%,"Breakpoint 3   (Voreinstellung RAM Zeile  127)" \
                                      + "\nHexadezimale Adresse, ein Einzelschritt." \
                                      + "\nWird bei Takt >255Hz nicht berücksichtigt." )
endif
drawtext 440,266,"hex"
'
var debug%  = create("Checkbox",%hWnd,"", 432, 290, 17, 17)
drawtext 450,290,"debug"
if htt% 
  create("Tooltip",%hWnd,debug%,"In Debug-Datei schreiben. " \
                                      + "\n " \
                                      + "\nIC, Binärcode, Assembler, SR/Flags, alle Register," \
                                      + "\nSP mit Inhalt, Tastaturbyte und MGA-Pixelzeile werden protokolliert." \
                                      + "\n " \
                                      + "\nWährend des Programmlaufs zu- und abschaltbar." \
                                      + "\nWird bei Takt >255Hz nicht berücksichtigt." \
                                      + "\n " )
endif
var debugfn%  = create("Edit",%hWnd,"debug.txt", 389, 308, 104, 18)
setfont debugfn%, afont% 
if htt% 
  create("Tooltip",%hWnd,debugfn%,"Debug-Datei eintragen. " \
                                      + "\nIst kein Dateiname eingetragen, wird die Dateiauswahl angezeigt." \
                                      + "\n " \
                                      + "\n --- ACHTUNG --- " \
                                      + "\nDie Datei wird immer mit der Kopfzeile überschrieben! (Auch wenn debug nicht gewählt wird.)" \
                                      + "\nBei Takt >255Hz erfolgt kein Eintrag in die Datei." \
                                      + "\n " )
endif
'
mgapix$  = "0000m000"                  ' MGA Adresse Pixel/Status initialisieren (m: Mausbit, wird nicht geprüft) 
mga_display                            ' MGA-Display initialisieren (mga$[ ] füllen)
' 
usefont "Wingdings", 22,20,0,0,0   
drawtext 620,450, Chr$(184)            ' Wingdings Uhr
usefont "Arial", 16,6,0,0,0            ' Standardschrift für das Fenster
var clock% = create("TEXT",%hWnd,"",648,455,129,13) 
setfont clock%, spfont% 
t0% = 65536                            ' Basiswert CPU-Zeit 2^16 ...
settext clock%,right$(bin$(t0%),16)    ' ... nur rechte 16 Bits mit 0 werden angezeigt
t%=t0%                                 ' CPU-Zeit initialisieren
dec t%                                 ' da in clock_pulse sofort inc i%
clock_pulse(1)                         ' Takt mit Faktor 1 (wichtig für Einzelschritt/ Normaltakt 1Hz)
'
'}
'{>>> Ereignisschleife  >>>
' <<<<<<<<<<<<<<<<<<<<<<<<<
repeat     
  '-------   Einlesen aus ChoiceBox und Edit  ------
  mn$                 = gettext$(mn%)              ' Mnemonic    
  case mn$ = "" : mn$ = "NOP" 
  op1$                = gettext$(op1%)             ' Operand 1
  op2$                = gettext$(op2%)             ' Operand 2
  opcomm$             = trim$(gettext$(opcomm%))   ' Kommentar zu Befehl
  coninp$             = gettext$(coninp%)          ' Konstante 
  concomm$            = trim$(gettext$(concomm%))  ' Kommentar zu Konstante
  '-------  Tooltip aktueller Programmname -------
  prgn$ = gettext$(progname%)
  settext toolprogname%, %hwnd, progname%, prognametxt$ + " * " + prgn$ + " * "
  '-------  Tooltip aktuell zu Kommentar  (volle Länge lesbar!)  -------
  tooltip_comment                           
  '--------   Befehle codieren/ im RAM ablegen --------
  assembler_to_binary_code                   
  '--------   Konstanten analysieren/ im RAM ablegen --------
  define_constant                    
  '-------   Startadresse in ST und IC eintragen  ------
  sta$ = gettext$(startadr%)                       ' Startadresse hexadezimal
  sta% = val("$"+sta$)                             ' Startadresse dezimal
  settext IC%, hex2_to_bin8(sta$)                  ' binär eintagen IC
  settext ST%, hex2_to_bin8(sta$)                  ' binär eintagen StIC (Start Instruction Counter)
   '--- Tooltips aktualisieren ---
  settext toolICval%, %hwnd, ICval%, "Adr  "+str$(val("%"+gettext$(IC%))) + " = h"+ bin8_to_hex2(gettext$(IC%)) 
  settext toolSTval%, %hwnd, STval%, "Adr  "+str$(val("%"+gettext$(ST%))) + " = h"+ bin8_to_hex2(gettext$(ST%)) 
  '
  settimer 200  ' 0,2 Sekunden ...
  '
  waitinput                                          ' <---  Ereignisabfrage 
  '
  if %wmTimer  ' Timer abfragen
    ' NICHTS                   ... 0,2 Sekunden warten, sonst flackert die Anzeige
  endif
 
  '-----   8 Bit Binärcode/Maschinenprogramm starten   -----
  x% = 415 - %mousex
  y% =  85 - %mousey
  if  (x%*x% + y%*y% < 100) and (%mousekey = 1) ' Klick auf runden Knopf
    coderow% = 0                                ' auf Anfang setzen
    restore_instruction                         ' Mnemonic Op1,2 und Kommentar in Eingabe-Edits setzen
    conrow%  = 128                              ' auf Anfang setzen
    restore_const                               ' Konstante (Eingabe) mit Kommentar setzen
   '
    run_binary_code           ' <--- Start Maschinenprogramm (Binärcode HC680)
   '===============
    selectstring(RAM%, -1, "00000000")          ' Markierung RAM Adr 0
   '
  endif
  '---  Takt - Einzelschritt ---
   get_pulse                     '  aktuellen Takt ermitteln und darstellen (nichtlineare Skale)
  ' ------   Buttons Programmierung Assembler  ------
  ' Befehl/Mnemonic Assembler
  if clicked(codeup%)             ' Programmzeile hoch
    if  coderow% > 0              ' mit Randprüfung Befehlszeile >= 0 
      dec coderow% 
      selectstring(RAM%, -1, d255_to_bin8(coderow%)) ' aktuelle Befehlszeile im RAM markieren
      restore_instruction         ' Mnemonic Op1,2 und Kommentar in Eingabe-Edits setzen
    endif  
  endif
  if clicked(codedown%)           ' Programmzeile runter
    if  coderow% < 127            ' mit Randprüfung Befehlszeile < h80
      inc coderow% 
      selectstring(RAM%, -1, d255_to_bin8(coderow%)) ' aktuelle Befehlszeile im RAM markieren
      restore_instruction         ' Mnemonic Op1,2 und Kommentar in Eingabe-Edits setzen
    endif  
  endif 
  '  Konstante Daten
  if clicked(conup%)             ' Konstantenzeile hoch
    if  conrow% > 128            ' mit Randprüfung
      dec conrow%
      selectstring(RAM%, -1, d255_to_bin8(conrow%)) ' aktuelle Befehlszeile im RAM markieren
      restore_const              ' Konstante (Eingabe) mit Kommentar setzen
    endif  
  endif  
  if clicked(condown%)
    if  conrow% < 255            ' mit Randprüfung
      inc conrow%
      selectstring(RAM%, -1, d255_to_bin8(conrow%)) ' aktuelle Befehlszeile im RAM markieren
      restore_const              ' Konstante (Eingabe) mit Kommentar setzen
    endif  
  endif    
  '------  in RAM geklickt  ----
  if clicked(RAM%)            
    ramrow% = getcursel(RAM%)  ' (Zeilencursor)
    restore_from_RAM           ' Befehl oder Konstante aus RAM mit Kommentar wiederherstellen
    setfocus(%hWnd)
  endif   
  ' ------   RAM löschen  ------ 
  if clicked(xram%) 
    RAM_delete                 ' RAM, Kommentare und aktuelle Flags löschen
  endif
  if clicked(xflag%) 
    flag_delete                 ' aktuelle Flags löschen
  endif
  ' ------   CACHE anzeigen, verbergen  ------ 
   if getcheck(shcache%) = 0 
    hide(CACHE%) 
  endif
  if getcheck(shcache%) = 1 
    show(CACHE%)
  endif
  ' ---  Ein-Ausgabeprotokoll anzeigen, verbergen, löschen  ---
  if getcheck(shio%) = 0 
    hide(IO%) 
    hide(clrio%)
    textcolor backgrdc% , backgrdc% 
    drawtext 880, 450, "I/O-Prot. löschen"
  endif
  if getcheck(shio%) = 1 
    show(IO%)
    show(clrio%)
    textcolor black%, backgrdc% 
    drawtext 880, 450, "I/O-Prot. löschen"
  endif
  if clicked(clrio%)  
    clearlist IO%                          
  endif 
   ' --- Verschiebungswert ---
  rel_value                    ' Focus auf Verschiebungswert Assembler - wird bearbeitet
  '-------------   Assembler : Laden Speichern Verschieben   --------------- 
  case  clicked(load%)       : load_asm
  case  clicked(store%)      : store_asm
  case  clicked(relocate%)   : reloc_asm
  ' ------------  Kurzanleitung und Hilfe zu Assemblerbefehlen  ----------------
  if clicked(shorthlp%)
    messagebox(shtbtxt$ , "HINWEIS",48)
  endif
  if clicked(hlp%)
    settext toolhlp%, %hwnd, hlp%, " Befehl: "+ gettext$(hlp%) +"  "
  endif
  ' 
  taste% = %key                 ' gedrückte Taste (Scancode)
until taste% = 27               ' Simulationsprogramm beenden mit ESC-taste
'} //end Ereignisschleife 
' <<<<<<<<<<<<<<<<<<<<<<<<< 
'{--- Aufräumarbeiten ------------------------------------------------
killtimer                       ' Timer freigeben
deleteobject sfont%             ' Objektspeicher freigeben
deleteobject font%
deleteobject spfont% 
deleteobject xfont%  
deleteobject afont%
deleteobject symbolfont%
endproc     ' Ende der Hauptprozedur main
'} 
' --- Takt / Ereignisbehandlung ------
proc get_pulse    ' aktuellen Takt ermitteln (nichtlineare Skale)
  takt! = getscrollpos(takt_scroll%)  ' scrollrange  - noch ohne Skalenrechnung
  if takt! = 0                        ' Skalenanfang  
     takt! = 2 ' sonst Div durch 0 bei STEP und bitweise in clock_pulse, so 0,5 Sek Pause
     settext takthz%,"Step"
     nospeed% = 1                     ' Einzelschritt
     afterstep% = 1                   ' merken für Wiederherstellung Status Startknopf
  else  
    if takt!< 101
      takt!=takt!/10                       ' Skalenrechnung bis 10Hz linear
    else
      takt!=10+(takt!-98)*(takt!-98)/100   ' Skalenechnung ab 10Hz quadratisch
    endif 
    if takt!< 256
      set("Decimals",1)
      settext takthz%, str$(takt!)
      set("Decimals",0)
    else
      settext takthz%, "Speed"
    endif
    nospeed% = 0                      ' variabler Takt  
    halt%    = 0                      ' nach Einzelschritt zurückstellen! 
  endif
endproc
proc clock_pulse  ' Takt/ EREIGNISBEHANDLUNG: Halt/Weiter/Einzelschritt/Tastatur/Maus  
 parameters faktor%
  var btmp$ = ""                      ' temporär, nicht global, da Prozedur in Befehlsausführung benutzt wird
  get_pulse                           ' aktuellen Takt ermitteln (nichtlineare Skale)
  '                                                 
  if (takt! < 256)  or (stop% = 1)    ' nur bei Takt < 256Hz 
    '
    if (fullspeed% = 1) and (stop% = 0)  ' bei fliegendem Wechsel von ungebremst zu kleinerem Takt  
      usebrush   1, grey%                ' Knopf grau
      fill 415, 85, black%
      textcolor darkred%, backgrdc%      ' dunkelrote Schrift
      drawtext 390,100, "wieder anhalten   "
      show(AL1%)                         ' ALU einblenden
      show(AL2%)
      show(ALC%)
      show(ALR%)
      show(alu_bitw%)                    ' Checkbox ALU bitweise einblenden
      show(breakpt1%)                    ' Kontrollkästchen Breakpoints anzeigen
      show(breakpt2%)
      show(breakpt3%)
      show(debug%)                       ' Kontrollkästchen Debugging anzeigen 
      show(debugfn%)                     ' Dateiname Debug anzeigen 
      show(CACHE%)                       ' CACHE einblenden
      show(opcomm%)                      ' Befehlskommentar darstellen
      fullspeed% = 0
    endif
    '
    if getcheck(shio%) = 1               ' I/O Protokoll anzeigen/verbergen
      show(IO%) 
    else
      hide(IO%) 
    endif
    '
    break1$ = gettext$(breakpt1%)          ' Breakpoint 1 ermitteln
    break2$ = gettext$(breakpt2%)          ' Breakpoint 2 ermitteln
    break3$ = gettext$(breakpt3%)          ' Breakpoint 3 ermitteln
    breakp$ = bin8_to_hex2(gettext$(IC%))  ' IC hexadezimal
    if (break1$ = breakp$)  or ( break2$ = breakp$) or ( break3$ = breakp$) ' Breakpoints -> ein Einzelschritt 
      break123% = 1
      nospeed%  = 1 
    endif 
    '
    if (takt! < 1.1) or (nospeed% = 1)     ' Hilfe zu Assembler bei kleinem Takt sinnvoll
      show(hlp%)                           
    else
      hide(hlp%)
    endif
    '
    if nospeed% = 1
      show(nextstep%) 
      ms% = 10                            ' ein ganz klein wenig Zeit für settimer (bei Start im Einzelschritt wichtig)
    else 
      hide(nextstep%)                     ' Einzelschritt [weiter] verbergen
    endif 
    '
    if nospeed% = 0
      ms% = 10000 \(faktor%*10*takt!)     ' variabler Takt Timer in Millisekunden
      if afterstep% = 1
        hide(nextstep%) 
        usebrush 1, grey%                 ' Knopf grau
        fill 415,85, black%
        textcolor darkred%, backgrdc%     ' dunkelrote Schrift
        drawtext 390,100, "wieder anhalten   "
        afterstep% = 0
      endif
    endif  
    '
    setfocus(%hwnd)                      ' für laufende Tastaturabfrage
    settimer ms%                         ' Taktfrequenz einstellen (in Milisekunden)   
    '=======================================
    repeat        ' >>>>>>  Ereignisschleife  Halt/Weiter/Einzelschritt und MGA-Display >>>>>>>
      '-------                              (äussere Ereignisschleife)
      waitinput     
      '-------
      '
      ' laufende Tastatureingabe
      if  (%key>5) and (%key<>13) and (%key<>255)  ' Tastatur betätigt - kein Code für ein Ereignis ...
        key$ = chr$(%key)    
        if key$<>""
          settext inp% , key$                         ' ... Zeichen in Eingabe-Edit eintragen
          btmp$ = d255_to_bin8(%key)
          if %key > 127
           settext altinp%, str$(bin8_to_dez(btmp$)) ' Wert des Zeichens darstellen 
          else
           settext altinp%, ""
          endif  
          settext binp% ,  btmp$                     ' binär anzeigen
          settext hinp%, "h" + bin8_to_hex2(btmp$)   ' hexadezimal anzeigen
          settext ans% , str$(%key)                  ' ANSI anzeigen
          settext RAM%, 246, 2, btmp$                ' RAM Adr 246 = hF6 binär eintragen ...
          settext RAM%, 246, 3, key$  + "    h" + bin8_to_hex2(btmp$)  ' ... Zeichen und Wert hexadezimal eintragen 
        endif 
      endif
      ' Ereignisse zum MGA Display  
      mk$    = "0"           ' Standard: keine Maustaste wurde gedrückt (Status)
      x%     = %mousex
      y%     = %mousey
      mk%    = %mousekey   
      if (x%>Mx%) and (x%<Mxe%) and (y%>My%) and (y%<Mye%) and (mk%>0)  ' Mausklick im MGA-Display
        mk$  = "1"        ' eine Maustaste wurde gedrückt (Status)
        ip%  = (y%-My%)\Md% +1                ' MGA Zeile  (Nr. 1 bis 8)
        jp%  = (x%-Mx%)\Md% +1                ' MGA Spalte (Nr. 1 bis 8)
        click_mga
      endif  
      refresh_mga        ' MGA aktualisieren
      '
      ' runder Knopf:  x%, y%  bereits ermittelt
      if (  ((415-x%)*(415-x%)+(85-y%)*(85-y%) < 100) and (mk%=1) and (halt%=0)  ) or (nospeed%=1) or (stop%=1)  
        '
        halt% = 1    ' zurücksetzen, siehe Schleifenabbruch mögliche Aktionen
        '
        if nospeed% = 1                     ' im Einzelschritt  
          usebrush 1 , backgrdc%            ' Knopf wie Ring - "ausgeblendet"
          fill 415, 85, black%
          textcolor black% , backgrdc%
          drawtext 390,100,"   Step ...           "     
        else                                ' nicht im Einzelschritt  
          usebrush 1,yellow%                ' Knopf gelb
          fill 415,85,black% 
          textcolor darkgreen%, backgrdc%   ' dunkelgrüne Schrift
          drawtext 390,100," weiter ausführen "
        endif 
        '
        if stop% = 1
          usebrush 1,red%                   ' Knopf rot
          fill 415,85, black%
          drawtext 390,100, " gestoppt            "
          sleep 2000                        ' verzögerte Anzeige [x] STOP und weiter
          usebrush 1,yellow%                ' Knopf gelb
          fill 415,85,black%
          textcolor darkgreen%, backgrdc%   ' dunkelgrüne Schrift
          drawtext 390,100," weiter ausführen "
          stop% = 0                         ' zurücksetzen, falls Weiterausführung
        endif
        '
        show(abbr%)
        textcolor darkred%, backgrdc%       ' dunkelrote Schrift
        drawtext 456, 77,"STOP"
        hide(inp%)  
        show_set_IC                                    ' anzeigen, um IC bei Bedarf neu zu setzen, "manuelle" Befehlsabfolge
        settext set_IC%, bin8_to_hex2(gettext$(IC%))   ' aktuellen Wert in Edit als Vorgabe eintragen
        '-----------------------------------------------
        repeat      ' innere Ereignisschleife
          '........
          waitinput      ' EREIGNISABFRAGE  für mögliche Aktionen:  X STOP Programm / weiter ausführen / einen Befehl weiter
          '........
          '
          settext IC%, hex2_to_bin8(gettext$(set_IC%)) ' IC  mit eventuell geändertem Wert setzen
          '--- Tooltip  dezimal, hexadezimal aktualisieren ---
          settext toolICval%, %hwnd, ICval%,"Adr  "+str$(val("%"+gettext$(IC%))) + " = h"+ bin8_to_hex2(gettext$(IC%)) 
          '
          if nospeed% = 0     ' nicht im Einzelschritt
            x% = 415 - %mousex
            y% =  85 - %mousey
            case (x%*x% + y%*y% < 100) and (%mousekey = 1) : halt% = 0   ' weiter ausführen
          endif
          '
          if clicked(abbr%) 
            break% = 1        ' Bedienerabbruch: X STOP
            nospeed% = 0      ' kein Einzelschritt mehr    - REIHENFOLGE zu ' weiter ausführen  - WICHTIG -
          endif 
          '
          case clicked(nextstep%)  : onestep% = 1   ' einen Befehl weiter
          '
        until  (halt% = 0) or (break% = 1) or (onestep% = 1)   ' ... bis Aktion ausgewählt
        '----------------------------------------------------
        hide_set_IC
        show(inp%)
        hide(abbr%)
        textcolor backgrdc%, backgrdc%
        drawtext 456, 77,"STOP"               ' STOP mit Hintergrundfarbe unsichtbar machen 
        '
        if (nospeed% = 0)
          usebrush 1,grey%                    ' Knopf grau
          fill 415,85,black%
          textcolor darkred%, backgrdc%       ' dunkelrote Schrift
          drawtext 390,100, "wieder anhalten   "
        endif 
        '
      endif
    until (halt% = 0) or (break% = 1)  or (onestep% = 1)  ' <<<<<<<<<<<<<<  bis Halt/Weiter/Einzelschritt <<<<<<<<<<<<<<<<
    '===================================================== 
     if nospeed% = 0      ' eingestellten Takt benutzen
       timeover% = 0
       repeat
         case  %wmTimer   : timeover% = 1
       until timeover%  
     endif
     if nospeed% = 1      ' bei Einzelschritt nach [weiter]
       timeover% = 0
       settimer 200         
       repeat 
         case  %wmTimer   : timeover% = 1 
       until  (timeover%  = 1) and (onestep% = 1)  
      onestep% = 0                    ' zurücksetzen
     endif
     if break123% = 1     ' nach Breakpoint
       break123% = 0
       nospeed%  = 0 
       hide(nextstep%) 
       usebrush 1,grey%                    ' Knopf grau
       fill 415,85,black%
       textcolor darkred%, backgrdc%       ' dunkelrote Schrift
       drawtext 390,100, "wieder anhalten   "
     endif
  else ' bei Takt > 255Hz ungebremst
    if fullspeed% = 0   ' bei Wechsel Takt über 255Hz
      hide(AL1%)        ' ALU ausblenden
      hide(AL2%)
      hide(ALC%)
      hide(ALR%)
      hide(alu_bitw%)   ' Checkbox ALU bitweise ausblenden
      hide(breakpt1%)   ' Kontrollkästchen Breakpoints verbergen
      hide(breakpt2%)
      hide(breakpt3%)
      hide(debug%)      ' Kontrollkästchen Debugging verbergen
      hide(debugfn%)    ' Dateiname Debug verbergen
      hide(CACHE%)      ' CACHE ausblenden
      hide(opcomm%)
      hide(hlp%)        ' Assemblerhilfe ausblenden (nur bei kleinem Takt)
    endif  
    if afterstep% = 1 
      hide(nextstep%) 
      afterstep% = 0
    endif  
    usebrush 1, backgrdc%                ' Knopf wie Ring - "ausgeblendet"
    fill 415,85,black%
    textcolor darkgreen%, backgrdc%      ' dunkelgrüne Schrift
    drawtext 390,100, "Takt > 255        "  
    fullspeed% = 1
  endif // Takt < 255
  '
  '------  clock - CPU-Zeit ------
  set_clock  
  '-------------------------------
endproc
proc bit_pulse    ' Takt bitweise 
 parameters faktor% 
  show(bit_stp%)
  get_pulse                           ' aktuellen Takt ermitteln (nichtlineare Skale)
  if nospeed%  = 0
    hide(nextstep%)                     ' Einzelschritt [weiter] verbergen
    ms% = 10000 \(faktor%*10*takt!)     ' variabler Takt Timer in Millisekunden
  else //    = 1                     
    show(nextstep%) 
    ms% = 10          ' ein ganz klein wenig Zeit für settimer (bei Start im Einzelschritt wichtig)
  endif 
  settimer ms%                         ' Taktfrequenz einstellen (in Milisekunden)   
  timeover% = 0
  repeat          ' >>>>>> Ereignisschleife  >>>>>>>         
    if nospeed%  = 0
      waitinput 
      case  %wmTimer   : timeover% = 1 
    else //    = 1 
      waitinput 
      case clicked(nextstep%)  : onestep% = 1   ' einen Befehl weiter  
    endif  
  until timeover% or onestep%   ' <<<<<<<<<<<<<<<
  '
  if nospeed% = 1      ' bei Einzelschritt nach [weiter]
     timeover% = 0
     settimer 200         
     repeat 
       case  %wmTimer   : timeover% = 1 
     until  timeover% and onestep%   
    onestep% = 0                    ' zurücksetzen
  endif
  ' 
  hide(bit_stp%)
endproc
proc set_clock    ' CPU-Zeit setzen
  if t% = 131072                       ' Überlauf bei 2^17 ... 
    t% = t0%                           ' t0% = 65536  (Basiswert CPU-Zeit 2^16 --> right 16 nur Nullen)
  else 
    inc t% ' CPU-Zeit incrementieren
  endif 
  settext clock%,right$(bin$(t%) ,16)   ' 16 Bit CPU-Zeit setzen
endproc
'{--- Anzeige/ aufräumen/ Control ----
proc show                             ' Control zeigen
  ShowWindow(&(1), 1)
endproc
proc hide                             ' Control verbergen
  ShowWindow(&(1), 0)
endproc
proc hide_assembler_controls          ' Controls für Assembler-Programmierung verbergen 
  hide(startadr%) ' Controls verbergen
  hide(prgvon%)                  
  hide(prgbis%)
  hide(datvon%)
  hide(datbis%)
  hide(verschieb%) 
  hide(cadr%)                  
  hide(oc%)
  hide(mn%)
  hide(op1%)
  hide(op2%)
  hide(codeup%)
  hide(codedown%)
  hide(fl%)
  hide(conadr%)
  hide(conbin%)
  hide(conhex%)
  hide(coninp%)
  hide(conup%)
  hide(condown%)
  hide(conalt%)
  hide(conans%)
  hide(concomm%)
  hide(hlp%)    
  hide(load%)
  hide(store%)
  hide(relocate%)  
endproc
proc show_assembler_controls          ' Controls für Assembler-Programmierung anzeigen  
  show(startadr%) ' Controls anzeigen
  show(prgvon%)                  
  show(prgbis%)
  show(datvon%)
  show(datbis%)
  show(verschieb%) 
  show(cadr%)                 
  show(oc%)
  show(mn%)
  show(op1%)
  show(op2%)
  show(codeup%)
  show(codedown%)
  show(fl%)
  show(conadr%)
  show(conbin%)
  show(conhex%)
  show(coninp%)
  show(conup%)
  show(condown%)  
  show(conalt%)
  show(conans%)
  show(opcomm%)
  show(concomm%)
  show(hlp%)
  show(load%)  
  show(store%)
  show(relocate%)
endproc
proc clr_hide12                       ' Operandenedits 1 und 2 löschen, verbergen
  op1$="" 
  hide(op1%)
  op2$="" 
  hide(op2%)
endproc
proc RAM_delete                       ' RAM, Kommentare und aktuelle Flags mit Nachfrage löschen
    textcolor darkred%, backgrdc%   ' dunkelrote Schrift
    drawtext 50, 684,"löschen................."
    drawtext 390,100, " wird gelöscht    "
    usebrush 1 , backgrdc%          ' Knopf wie Ring - "ausgeblendet"
    fill 415, 85, black%
    msg% = messagebox("Sind Sie wirklich sicher?\n  \nHaben Sie das Programm gespeichert? \n "  \
                      + "\nWollen Sie den 256Byte-RAM (Speicher/Programm/Daten)"                \
                      + "\nund die letzten Flags und Kommentare wirklich vollständig löschen?","  VORSICHT! ",276)
    if msg% = 6  ' Message return ja: 6 
      row% = 0 
      repeat
        settext RAM%, row%, 2,"00000000" 
        if row% < 128
          settext RAM%, row%, 3,"NOP"
        else  
          settext RAM%, row%, 3,"0    h00" ' dezimal: Vorzeichen, 4 Stellen / 1 Leerz. / hexadez. zweistellig
        endif  
        case row% < 245 : settext RAM%, row%, 4,"    "       '  4 Leerzeichen bis vor SP Basisadresse
        comment$[row%] = ";"
        inc row%
      until row% = 256 
    endif
    textcolor black%, backgrdc%
    drawtext 50, 684,"RAM/Flags löschen"
    drawtext 390,100, "  ausführen       "
    usebrush 1,richgreen%                 ' Knopf sattgrün
    fill 415, 85, black%
    coderow% =   0
    restore_instruction                   ' Mnemonic Op1,2 und Kommentar in Eingabe-Edits setzen
    conrow%  = 128
    restore_const                         ' Konstante (Eingabe) mit Kommentar setzen
endproc  ' 
proc flag_delete                      ' aktuelle Flags ohne Nachfrage löschen       
  row% = 0 
  repeat
   settext RAM%, row%, 4,"    "         '  4 Leerzeichen
   inc row%
  until row% = 127 
endproc
'}
'{--- Flags---------------------------
proc flags_b_res_N_Z_0_0              ' Flags N$ und Z$ aus Ergebnis in b_res$ ermitteln, V$=0 C$=0   
  N$ = left$(b_res$,1)    ' linkes Bit Vorzeichen    
  if b_res$ = "00000000"        
    Z$= "1"
  else
    Z$ = "0"
  endif   
  V$ = "0"
  C$ = "0"   
  settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$  ' Statusregister mit Flags setzen  
endproc
proc flags_0_0_0_0                    ' alle Flags auf Nullsetzen
  N$ = "0" 
  Z$ = "0" 
  V$ = "0" 
  C$ = "0" 
  settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$  ' Statusregister mit Flags setzen  
endproc
proc flags_latest                     ' zuletzt gesetzte Flags nach Befehlsausführung hinter Assembler anzeigen
  case N$ = "1" :  N_$ = "N"
  case N$ = "0" :  N_$ = " "
  case Z$ = "1" :  Z_$ = "Z"
  case Z$ = "0" :  Z_$ = " "
  case V$ = "1" :  V_$ = "V"
  case V$ = "0" :  V_$ = " "
  case C$ = "1" :  C_$ = "C"
  case C$ = "0" :  C_$ = " "
  settext RAM%,  ic_dez_fl% , 4, N_$+Z_$+V_$+C_$     ' gesetzte Flags nach Befehlsausführung darstellen
endproc  
'}
'{--- Hilfe Tooltip ------------------
proc tooltip_comment                  ' Tooltip aktuell zu Kommentar (volle Länge lesbar!)
  if len(trim$(opcomm$)) = 0
    settext toolopcomm%, %hwnd, opcomm%, opcommtxt$ 
  else 
    settext toolopcomm%, %hwnd, opcomm%, "; "+opcomm$
  endif 
  if len(trim$(concomm$)) = 0
    settext toolconcomm%, %hwnd,concomm%, concommtxt$
  else 
    settext toolconcomm%, %hwnd, concomm%, "; "+concomm$
  endif 
endproc
proc register_tooltip                 ' Tooltips dezimalen und hexadezimal aktualisieren
  ' dezimale und hexadezimale Anzeige der Register im Tooltip 
  settext toolr0val% , %hwnd, r0val%, str$(bin8_to_dez(gettext$(R%[0]))) + " = h"+bin8_to_hex2(gettext$(R%[0]))
  settext toolr1val% , %hwnd, r1val%, str$(bin8_to_dez(gettext$(R%[1]))) + " = h"+bin8_to_hex2(gettext$(R%[1]))
  settext toolr2val% , %hwnd, r2val%, str$(bin8_to_dez(gettext$(R%[2]))) + " = h"+bin8_to_hex2(gettext$(R%[2]))
  settext toolr3val% , %hwnd, r3val%, str$(bin8_to_dez(gettext$(R%[3]))) + " = h"+bin8_to_hex2(gettext$(R%[3]))
  ' 
  settext toolSD0val%, %hwnd, SD0val%, str$(bin8_to_dez(gettext$(S%[0]))) + " = h"+bin8_to_hex2(gettext$(S%[0])) 
  settext toolSD1val%, %hwnd, SD1val%, str$(bin8_to_dez(gettext$(S%[1]))) + " = h"+bin8_to_hex2(gettext$(S%[1])) 
  settext toolSA0val%, %hwnd, SA0val%, str$(bin8_to_dez(gettext$(S%[2]))) + " = h"+bin8_to_hex2(gettext$(S%[2])) 
  settext toolSA1val%, %hwnd, SA1val%, str$(bin8_to_dez(gettext$(S%[3]))) + " = h"+bin8_to_hex2(gettext$(S%[3])) 
  ' Adresse dezimal und hxadezimal im Tooltip anzeigen 
  settext toolICval%,  %hwnd, ICval%,"Adr  "+str$(val("%"+gettext$(IC%)))+ " = h"+bin8_to_hex2(gettext$(IC%))
  settext toolSPval%,  %hwnd, SPval%,"Adr  "+str$(val("%"+gettext$(SP%)))+ " = h"+bin8_to_hex2(gettext$(SP%))
  ' IO Bits und Flags
  IO_SR$ = left$(gettext$(SR%),2)         ' Art Daten IO, linke zwei Bit in SR
  select IO_SR$     ' Art der Speicherung: 
    caseof "00" 
      IO_SRtxt$ = "00 Tastaturzeichen" 
    caseof "01" 
      IO_SRtxt$ = "01 dezimal -128..127" 
    caseof "10"
      IO_SRtxt$ = "10 hexadezimal xx" 
    caseof "11" 
      IO_SRtxt$ = "11 binär"
  endselect 
  XY_SR$ = mid$(gettext$(SR%),3,2) + " Bits XY "
  settext toolSRval%,  %hwnd, SRval%,  IO_SRtxt$+"\n"+XY_SR$+"\nN   = "+N$+"\nZ   = "+Z$+"\nV   = "+V$+"\nC   = "+C$
endproc
'}
'{--- Ein- Ausgabesystem -------------
proc input_system                     ' Eingabesystem - Nutzereingabe beim Programmlauf  
  show(IO%)                     ' Ein-Ausgabeprotokoll anzeigen 
  show(wait_inp%)               ' Startknopf überdecken 
  setcheck shio%, 1
  setfocus(inp%)  
  repeat   
    inp$  = gettext$(inp%)      ' Eingabe Dezimalzahl -128 bis 127 oder Hexadezimalzahl oder Tastaturzeichen
    if inp$ = ""
      hide(inp_ok%)
      binp$ = ""                    ' "" nicht automatisch in 00000000 umwandeln 
      settext altinp%,""
      settext ans%,""
    else  
      ansi%   = ord(inp$)           ' ANSI-Code erstes Zeichen     
      if ( (ansi%>47) and (ansi%<58) ) or ( (ansi%=45) and (len(inp$)>1) ) ' Dezimalziffer oder Minuszeichen am Anfang  
        inpval% = val(inp$)             ' Dezimalwert der Eingabe
        binp$ = dez_to_bin8(inpval%)    ' Zahl in Binärzahl (negativ: Zweierkomplement) wandeln
        if (inpval% > -129) and (inpval% < 128) 
          if inpval% < 0 
            settext altinp%, str$( val("%"+ dez_to_bin8(inpval%)) )  ' alternative Darstellung der Eingabe Zeichen/Zahl
          else
            settext altinp%,""
          endif  
          settext ans%, chr$(inpval%) ' Zeichen darstellen
          show(inp_ok%)
        else                  ' ungültige Dezimalzahl:     < -128   oder   > 127           -> OVERFLOW
          hide(inp_ok%)
          binp$ = "OVERFLOW"
          settext altinp%,""
          settext ans%,""
        endif // Dezimal
      elseif ( (ansi%=36) or (ansi%=72) or (ansi%=104) ) and (len(inp$)=3)  ' $ oder H oder h am Anfang: Hexadezimalzahl
         binp$ = hex2_to_bin8(mid$(inp$,2,2))      ' Hexadezimalzahl in Binärzahl 
         inpval% = val("%"+ binp$)                 ' korrigierter Eingabewert (Buchstabe über F, f zu 0)
         settext altinp%,str$(inpval%)
         settext ans%, chr$(inpval%)               ' Zeichen darstellen zu   
         show(inp_ok%)
      else                                    ' Eingabe eines Tastaturzeichens
        if len(inp$)=1              
          binp$ = d255_to_bin8(ansi%)                       ' ANSI-Code des Zeichens binär
          if ansi% > 127
            settext altinp%, str$(bin8_to_dez(binp$)) ' Wert des Zeichens darstellen    
          else
            settext altinp%,""
          endif
          settext ans%, str$(ansi%)                 ' ANSI-Code des Zeichens dezimal anzeigen
          show(inp_ok%)
        else
          hide(inp_ok%) 
          binp$ = "ERROR"     ' fehlerhafte Eingabe: mehrere Zeichen, aber keine gültige Dezimalzahl -> ERROR
          hide(inp_ok%) 
          settext altinp%,""
          settext ans%,""
        endif    
      endif // Tastaturzeichen 
    endif // nichtleere Eingabe
    settext binp%, binp$                            ' Input binär anzeigen 
    if (binp$="") or (binp$="OVERFLOW") or (binp$="ERROR") ' ungültig, keine Anzeige
      settext hinp%, ""
    else  
      hinp$ = bin8_to_hex2(binp$)
      settext hinp%, "h" + hinp$        ' Input hexadezimal anzeigen
    endif
    waitinput  
  until clicked(inp_ok%) 
  '
  'IO_SR$ = left$(gettext$(SR%),2)          ' Art Daten IO  linke 2 Bit SR 
  select IO_SR$
      caseof "00"                       ' --- Tastaturzeichen --- 
        addstring(IO%, chr$(val("%"+binp$)) +"|"+"")             ' Zeichen in Eingabeliste schreiben
      ' ---
      caseof "01"                       ' --- dezimal ---
        addstring(IO%, str$(bin8_to_dez(binp$)) +"|"+"")         ' Dezimalzahl in Eingabeliste schreiben
      ' ---
      caseof "10"                       ' --- hexadezimal xx ---
        addstring(IO%,"h" + hinp$+"|"+"")                        ' hxx in Eingabeliste schreiben
     ' ---
      caseof "11"                       ' --- 8 Bit binär --- 
       addstring(IO%,">"+left$(binp$,4)+"|"+right$(binp$,4)+".") ' binär in Ein/Ausgabeliste schreiben
  endselect // Art Daten IO_SR
  hide(inp_ok%)
  hide(wait_inp%)
endproc
proc output_system                    ' Ausgabesystem - beim Programmlauf
  show(IO%)                      ' Ein-Ausgabeprotokoll anzeigen
  setcheck shio%, 1
  settext boutp%, boutp$                                            ' Ausgabe binär
  settext houtp%, "h" + bin8_to_hex2(boutp$)                        ' Ausgabe hexadezimal
  settext outp%, str$(bin8_to_dez(gettext$(boutp%)))                ' Ausgabe dezimal mit Vorzeichen
 
  if left$(boutp$,1)="1"                                            ' Ausgabe ist negativ ...
    settext ansout%, str$( val("%"+ gettext$(boutp%)))              ' ... Ausgabe ANSI-Code    
  else
    settext ansout%,""                                              ' Ausgabe dezimal ist bereits ANSI-Code  
  endif
  settext  coutp%, chr$( val("%"+ gettext$(boutp%)))                ' Ausgabe als Zeichen nach ANSI-Code
  '
  'IO_SR$ = left$(gettext$(SR%),2)          ' Art Daten IO  linke 2 Bit SR 
  select IO_SR$
      caseof "00"                       ' --- Tastaturzeichen --- 
        addstring(IO%,""+"|"+ gettext$(coutp%))                     ' Ausgabeliste Zeichen
      ' ---
      caseof "01"                       ' --- dezimal ---
        addstring(IO%,""+"|"+ gettext$(outp%))                      ' Ausgabeliste Dezimalzahl
        
      ' ---
      caseof "10"                       ' --- hexadezimal xx ---
        addstring(IO%,""+"|"+gettext$(houtp%))                      ' Ausgabeliste hexadezimal: xx        
        ' ---
      caseof "11"                       ' --- 8 Bit binär --- 
        addstring(IO%,"."+left$(boutp$,4)+"|"+right$(boutp$,4)+">") ' Ein/Ausgabeliste 8 Bit binär  
  endselect // Art Daten IO_SR
endproc 
'}
'{--- Zahlensysteme / Arithmetik -----
proc dez_to_bin3                      ' dezimal 0..7    -> 3 Bit binär 
parameters d%
  var b$ =  bin$(d%) 
  return mkstr$("0", 3-len(b$)) + b$ 
endproc
proc d255_to_bin8                     ' dez    0..255 (ohne Vorzeichen)              -> binär 8-stellig 
 parameters d%
  var b$ =  bin$(d%)
  return mkstr$("0", 8-len(b$)) + b$ 
endproc
proc dez_to_bin8                      ' dez -128..127 (Vorzeichen: Zweierkomplement) -> binär 8-stellig 
 parameters d%
    if     ( d% > -1) and (d% < 128) ' positiver Bereich mit Null
      return d255_to_bin8(d%)        ' mit vorlaufenden Nullen
    elseif (d% > -129) and (d% < 0)  ' negativer Bereich - Zweierkomplement
      return bin$(256 + d%)          ' 1 ist erstes Bit
    elseif (d% < -128) or (d% > 127) ' nicht in 8 Bit vorzeichenbehaftet darstellbar
      return "OVERFLOW"
    endif    
endproc  
proc bin8_to_dez                      ' binär 8-stellig                              -> dez -128..127 (Vorzeichen: Zweierkomplement)
 parameters b$ 
  case left$(b$,1)="0" : return val("%"+b$)                     '    0 bis 127
  case left$(b$,1)="1" : return -128 + val("%"+ right$(b$,7))   ' -128 bis -1
endproc 
proc dez_to_hex2                      ' dezimal (positiv) zu Hexadezimal 2-stellig
 parameters d%
  var h$ = hex$(d%)                   ' vorlaufende Null erzeugen     
  return mkstr$("0", 2-len(h$)) + h$ 
endproc
proc hex2_to_bin8                     ' hexadezimal 2-stellig zu binär 8-stellig
 parameters h$
  h$ = bin$(val("$"+trim$(h$)))
  return mkstr$("0", 8-len(h$) ) + h$      '
endproc
proc bin8_to_hex2                     ' binär 8-stellig zu hexadezimal 2-stellig 
  parameters Byte$
  return hex$(val("%"+left$(Byte$,4)))+hex$(val("%"+right$(Byte$,4)))
endproc
proc bit_add                          ' Addition von 3 Bits mit Übertrag
  var bz%= 0                          ' initialisieren
  case b1$ = "1" : inc bz%            ' gesetzte Bits zählen
  case b2$ = "1" : inc bz%
  case b3$ = "1" : inc bz%
  select bz%                       ' Bitanzahl -> Egebnis (dezimal=):
    caseof 0
      bc$ = "0" : r$ = "0"                        ' 00    (0)   
    caseof 1
      bc$ = "0" : r$ = "1"                        ' 01    (1)
    caseof 2
      bc$ = "1" : r$ = "0"                        ' 10    (2)
    caseof 3
      bc$ = "1" : r$ = "1"                        ' 11    (3)
  endselect
endproc
'}
proc add_ALU_9                 ' Addition im 9 Bit-Rechenwerk in der ALU  mit Flags
  var bit% = 0  ' mit Bitwert 0 (rechts) beginnen
  ' 9-Bit Addierwerk, 8 Bit und Vorzeichenerweiterung zur Überlaufprüfung 
  ' Bitstellen (C Carry): 	C 7 6 5 4 3 2 1 0  - höchstwertiges Bit 7 in C duplizieren, dez. -128 bis +127
  settext AL1%, left$(gettext$(AL1%),1) + gettext$(AL1%) ' höchstwertiges Bit 1. Operand duplizieren
  settext AL2%, left$(gettext$(AL2%),1) + gettext$(AL2%) ' höchstwertiges Bit 2. Operand duplizieren
  C9$ = "         "           ' Übertrag leeren
  settext ALC%, C9$   
  R9$ = "         "           ' 9 Bit Ergebnis leeren
  settext ALR%, R9$
  ALU_step
  C9$ = "        0"           ' niederwertigster Übertrag wird 0 gesetzt
  settext ALC%, C9$           ' ... und in die ALU setzen 
  '
  repeat                      ' bitweise Addition mit Übertrag   
    ALU_bitstep
    b1$ = mid$(gettext$(AL1%),9-bit%, 1)  ' Bit auslesen
    b2$ = mid$(gettext$(AL2%),9-bit%, 1)
    b3$ = mid$(gettext$(ALC%),9-bit%, 1)
    bit_add                   ' Addition der Bits 
    if bit% < 8               ' letzter Übertrag links passt nicht mehr in C9$
      C9$ = space$(7-bit%) + bc$ + right$(C9$, bit%+1)   ' Übertrag-Bit eins weiter links ...     
    endif 
    if bit% = 7   ' letzter Übertrag aus 8 Bit-Breite links 
      C$ = bc$               ' Carry-Flag setzen
    endif
    R9$ =   space$(8-bit%) + r$  + right$(R9$, bit%)      ' ... als das Resultat-Bit
    settext ALC%,C9$
    settext ALR%,R9$ 
    inc bit%                 ' vorheriges, höherwertiges Bit
  until bit% = 9 
  '
  b_res$ = right$(R9$,8)     ' Ergebnis rechte 8 Bit
  N$ = left$(b_res$,1)       ' linkes Bit ist Vorzeichenbit 
  if b_res$ = "00000000" 
    Z$ = "1"                 ' Zero-Flag setzen
  else
    Z$ = "0"
  endif
  if left$(R9$,1)= mid$(R9$,2,1)  'linke zwei Bit gleich 
     V$ =  "0"                       ' ok -> Resultat im Bereich -128 bis 127
   else                           ' linke zwei Bit verschieden
     V$ =  "1"                       ' oVerflow -Flag setzen 
  endif
  '  C$ wird in der Schleife gesetzt!
   settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$  ' Statusregister mit Flags setzen
  ALU_step 
endproc
proc complement1_ALU           ' Einerkomplement in der ALU bilden
  var bit% = 9
  settext AL1%, " " + gettext$(AL1%)               ' rechtsbündig setzen
  settext AL2%, "         "                        ' unbenutzt
  settext ALC%, "         "                        ' unbenutzt
  R9$ = "         "                                ' 9 Bit Ergebnis leeren ...                             
  settext ALR%, R9$                                ' ... und in die ALU setzen 
  bit% = 9
  repeat
    ALU_bitstep
    b1$ = mid$(gettext$(AL1%),bit%, 1)  ' Bit auslesen ...
    if b1$ = "0"
       r$ = "1"                         ' ... komplementieren
    else 
       r$ = "0"
    endif   
    R9$ =   space$(bit%-1) + r$  + right$(R9$, 9-bit%)   
    settext ALR%,R9$           
    dec bit%
  until bit% = 1                         ' ohne linkes Bit (8 von 9) 
  b_res$ = right$(gettext$(ALR%), 8)
  ALU_step 
endproc  
proc complement2_ALU           ' Zweierkomplement in der ALU bilden (Vorzeichenumkehr)
  complement1_ALU
  settext AL1%,"00000001"      ' 1 addieren ... 
  settext AL2%, b_res$         ' ... zu Einerkomplement
  add_ALU_9                           ' Addition im 9 Bit-Rechenwerk in der ALU  mit Flags  
endproc
proc div_ALU                   ' Division mit Rest in der ALU 9Bit/8Bit
  var btmp1$ = ""   ' lokal für Daten-Register  D0 D1       
  var btmp2$ = ""
  var special% = 0  ' keine Sonderbehandlung
  var bit% = 0      ' Bitzähler
  settext AL1%, space$(9)
  settext AL2%, space$(9)
  settext ALC%, space$(9)
  settext ALR%, space$(9)
  show(ASP%) : show(ALN%) : show(ALP%) : show(AV1%) : show(AV2%)  ' temporär für DIV anzeigen
  textcolor darkgreen%, chipc% 
  drawtext 704, 192, "Vz"
  drawtext 865, 227, "N"
  drawtext 865, 244, "P"
  '
  btmp1$ = gettext$(R%[0])         'Daten-Register auslesen 
  btmp2$ = gettext$(R%[1])
  settext AV1% , left$(btmp1$,1)   ' Vorzeichenerweiterung in Vorzeichenbit schieben
  settext AV2% , left$(btmp2$,1)   ' Vorzeichenerweiterung in Vorzeichenbit schieben
  ALU_step
  '
  if btmp1$ = "00000000"         ' Dividend 0  -->  Quotient 0, Rest: 0
    '---Dividend----
    settext ASP%, "   D0   "
    settext AL1% , "0"+ btmp1$
    ALU_step
    settext ALR%, "000000000"    ' Quotient  und Rest 0 (Ergebnis)
    settext S%[0], "00000000"    '  
    b_res$ = btmp1$              ' D0 bleibt unverändert 0, b_res$ für Z-Flag
    flags_b_res_N_Z_0_0          ' Flags setzen
    special% = 1                 ' Sonderbehandlung  (Lösung, keine weiteren Berechnungen)
  else // Dividend nicht 0
    '-----2---Divisor-----
    settext ASP%, "   D1   "
    settext AL1%, btmp2$           ' Divisor in ALU
    if gettext$(AV2%) = "1"        ' negativer Divisor
      settext ALN%, btmp2$         ' negativen Divisor ablegen 
      if btmp2$ ="11111111"        ' x \ (-1) = - x  Rest 0
        settext ASP%, "   D0   "
        settext AL1% , btmp1$      ' Dividend nach AL1
        complement2_ALU            ' 2er-Komplement berechnen mit Flags (b_res$ ist -D0 ) 
        settext R%[0], b_res$      ' Quotient nach D0
        settext S%[0], "00000000"  ' Rest 0
        special% = 1               ' Sonderbehandlung  (Lösung, keine weiteren Berechnungen)
      elseif btmp2$ ="10000000"    ' abs(-128) = 128 nicht im Zahlenbereich 
        complement2_ALU            ' 2er-Komplement berechnen mit Flags --> ergibt  OVERFLOW 
        '                          ' D0, SD0 bleiben unverändert 
        special% = 1               ' Sonderbehandlung  (Lösung, keine weiteren Berechnungen)
      else 
        complement2_ALU            ' 2er-Komplement berechnen ... 
        settext ALP%, b_res$       ' ... positiven Divisor ablegen 
      endif  
    else             // "0"        ' positiver Divisor
      settext ALP%, btmp2$         ' Divisor ablegen 
      if btmp2$  = "00000001"      ' x \ 1 = x Rest 0                (interne Prüfung: linke 8 Bit in AL1 Null) 
        settext AL1%, "0"+btmp2$   ' Vorzeichenerweiterung darstellen /
        b_res$ =  btmp1$           ' D0 bleibt unverändert 
        flags_b_res_N_Z_0_0        ' Flags setzen
        settext S%[0], "00000000"  ' Rest 0
        special% = 1               ' Sonderbehandlung  (Lösung, keine weiteren Berechnungen)
      else
        complement2_ALU            ' 2er-Komplement berechnen ...
        settext ALN%, b_res$       ' ... negativen Divisor ablegen
      endif
    endif // Divisor Vorzeichen
  endif //  Dividend   0  -  nicht 0
  ALU_step
  '
  if special% = 0 
    '-----1---Dividend----
    settext ASP%, "   D0   "
    
    if gettext$(AV1%) = "1"      ' negativer Dividend 
      settext AL1% , btmp1$      ' Dividend nach AL1
      if btmp1$ ="10000000"      ' abs(-128) = 128 nicht im Zahlenbereich
        complement2_ALU          ' 2er-Komplement berechnen  --> ergibt  OVERFLOW
        '                        ' D0, SD0 bleiben unverändert 
        special% = 1             ' Sonderbehandlung  (Lösung, keine weiteren Berechnungen)
      else 
        complement2_ALU            ' 2er-Komplement berechnen ...
        settext AL1% , "0"+b_res$  ' ... positiver Dividend nach AL1
      endif
    else            // "0"
      settext AL1% , "0"+btmp1$ ' positiver Dividend nach AL1
    endif
  endif // special  
  '---------------------'
  if special% = 0  ' wenn keine Sonderbehandlung 
    settext AL2%,  space$(9)     ' für einzusetzenden Divisor optisch 'freimachen'
    settext ALC%,  space$(9)     ' für Bit-Vergleiche nicht benutzt ...
    settext ALR%,  space$(9)     ' ... Resultat leeren (zur besseren Übersicht bei den vielen temporären Registern)
    ALU_step
    settext AL2% , "0"+ gettext$(ALP%) ' positiver Divisor
    settext ALf%,  space$(1) 
    settext ALt%,  space$(1)  
    settext ALa%,  space$(1) 
    settext ALS%,  space$(8)  ' temporäres Hilfsregister für shift-Status 
    settext ALD%,  space$(8)  ' temporäres Register für shift >> und shift << (Dividend)
    settext ARL%,  space$(8)  ' temporäres Register für Resultat (Quotient) 
    show(ALf%) : show(ALt%) : show(ALa%)  ' temporär für DIV anzeigen
    show(ALS%) : show(ALD%) : show(ARL%) 
    '
    settext ASP%, " D0 \D1 "  
    textcolor darkgreen%, chipc% 
    drawtext 839, 165, "f"
    drawtext 847, 165, "t"
    drawtext 855, 165, "a"
    drawtext 865, 193, "S"
    drawtext 865, 210, "D"
    drawtext 865, 261, "L"
    ALU_step
    settext ALf%,  "1"           ' Vorbelegung  erster Durchlauf äußere schleife
    settext ALt%,  "0"           ' Vorbelegung keine zweite Schleife 
    settext ALa%,  "0"           ' Vorbelegung keine Addition von -abs(Devisor) 
    settext ALS%,  "00000000"    ' temporäres Hilfsregister für shift-Status auf 0
    settext ALD%,  "00000000"    ' temporäres Register für shift >> und shift << (Dividend)
    settext ARL%,  "00000000"    ' temporäres Register für Resultat (Quotient) 
    '
    ' Berechnung des Quotienten der Beträge von D0 und D1
    while 1  ' Abbruch nur mit breaks,  Teil-Dividend über Divisor platzieren
      ALU_step
      bit% = 3        ' von links prüfen, ohne Vorzeichenerweiterung 1 und Vorzeichenbit 2  (0 da immer positiv)
      settext ASP%, space$(bit%-2)+"|"+ space$(9-bit%)   ' ASP wird ab Bit 2 dargestellt!
    ' erste Teilschleife
      while 1  ' Abbruch nur mit breaks, Bits von links prüfen
        b1$ = mid$(gettext$(AL1%),bit%,1)   ' Bit auslesen
        b2$ = mid$(gettext$(AL2%),bit%,1)
        b3$ = left$(gettext$(ALS%),1)       ' Schiebezähler linkes Bit: "1" left shift möglich
        ' --------------- 
        if b1$+b2$ = "00"
        settext ASP%, space$(bit%-2)+"|"+ space$(9-bit%) 
          if bit% = 9
            ' bei bit% = 9  ist 0\0 nicht definiert,   0 vorher abgefangen
          else
            inc bit%          ' vorlaufende Nullen übergehen
            ALU_bitstep
          endif  
        endif
        ' ---------------
        if b1$+b2$ = "01" 
          if b3$ = "1"   ' shift möglich,  links schieben,  ALS mitschieben (AL1 9 Bit beachten) 
            settext ASP%, space$(bit%-2)+"<"+ space$(9-bit%) 
            settext AL1%, right$(gettext$(AL1%),8)+left$(gettext$(ALD%),1)  ' << AL1_ALD(1)  (Bitzähler nicht erhöhen!)
            settext ALD%, right$(gettext$(ALD%),7)+"0"                      ' << ALD(2..8)_0   
            settext ALS%, right$(gettext$(ALS%),7)+"0"                      ' Schiebezähler links schieben, 0 anhängen
            settext ARL%, right$(gettext$(ARL%),7)+"0"                      ' Lösungs-Bit 0 anhängen (für Stelle << schieben)
            ALU_bitstep
          else //  kein << shift mehr möglich,  Dividend < Divisor 
            settext ASP%, space$(bit%-2)+"|"+ space$(9-bit%) 
            settext ALt%, "0"                               ' keine zweite Schleife, 
            settext ALa%, "0"                               ' keine Addition von -abs(Devisor)   
            case gettext$(ALf%) = "1" : settext ALf%, "0"   ' damit keine Addition mehr
            settext ALR%, gettext$(AL1%)                                   ' Rest nach ALR%
            settext ARL%, right$(gettext$(ARL%),7)+"0"                     ' Lösungs-Bit 0 anhängen 
            break                                                
          endif 
        endif 
        ' ---------------
        if b1$+b2$ = "10" 
          if bit% = 9
            ' bei bit% = 9  ist 1\0 nicht definiert,    0 vorher abgefangen 
          else
            if gettext$(ALf%) = "1"     ' nur beim ersten Durchlauf in äußerer Schleife: linke Position Dividend zu Divisor
              settext ASP%, space$(bit%-2)+">"+ space$(9-bit%) 
              settext ALD%, right$(gettext$(AL1%),1)+left$(gettext$(ALD%),7)  ' >> AL1(9)_ALD 
              settext AL1%, "0" + left$(gettext$(AL1%),8)                     ' >> 0_AL1(1..8)
              settext ALS%, "1" + left$(gettext$(ALS%),7)                     ' Schiebezähler mit 1 von links füllen
              inc bit%
              ALU_bitstep
            else
              settext ALt%, "0"                ' keine zweite Schleife 
              settext ALa%, "1"                ' Addition von -abs(Devisor)        
              settext ARL%, right$(gettext$(ARL%),7)+"1"                     ' Lösungs-Bit 1 anhängen
              break
            endif
          endif  
        endif 
        ' ---------------
        if b1$+b2$ = "11" 
          settext ASP%, space$(bit%-2)+"|"+ space$(9-bit%)  
          if bit% = 9  
           ' bei bit% = 9  ist 1\1 = 1 Rest 0   Division durch 1 vorher abgefangen, sonst Algorithmus fehlerhaft
          else  
            settext ALt%, "1"                                   ' zweite Schleife (da 1 über 1 gefunden)
            inc bit%                                            ' ... ab Folgebit
            break                                               '    
          endif
        endif
        '----------------
      endwhile // erste Teilschleife 
      ALU_bitstep
      '
      if gettext$(ALt%) = "1"                             '  <---  Teilschleife zwei durchlaufen
        settext ASP%, space$(bit%-2)+":"+ space$(9-bit%) 
        while 1  ' Abbruch nur mit breaks     'zweite Teilschleife: weitere Bits nach rechts prüfen
          b1$ = mid$(gettext$(AL1%),bit%,1)   ' Bit auslesen
          b2$ = mid$(gettext$(AL2%),bit%,1)
          b3$ = left$(gettext$(ALS%),1)       ' Schiebezähler linkes Bit: "1" left shift möglich
          ' ---------------
          if b1$+b2$ = "00"  
            if bit% = 9 
              if b3$ = "1"                    ' nur Zwischenergebnis weiterhin noch shift möglich
                settext ALa%, "1"                                   ' Addition von -abs(Devisor)
              else //   letzte Teilrechnung
                settext ALa%, "0"                                   ' keine Addition von -abs(Devisor)  
                settext ALR%, "000000000"                           ' Rest 0 nach ALR
              endif 
              settext ARL%, right$(gettext$(ARL%),7)+"1"            ' Lösungs-Bit  anhängen 
              break 
            else
               inc bit%
               settext ASP%, space$(bit%-2)+":"+ space$(9-bit%)
              ALU_bitstep
            endif
          endif
          ' ---------------
          if b1$+b2$ = "01"
            if b3$ = "1"   ' shift möglich, ALS mitschieben, (AL1 9 Bit beachten) 
              settext ASP%, space$(bit%-2)+"<"+ space$(9-bit%) 
              settext AL1%, right$(gettext$(AL1%),8) + left$(gettext$(ALD%),1)  ' << AL1_ALD(1) (Bitzähler nicht erhöhen!)
              settext ALD%, right$(gettext$(ALD%),7) + "0"                      ' << ALD(2..8)_0
              settext ALS%, right$(gettext$(ALS%),7) + "0"                      ' Schiebezähler links schieben, 0 anhängen 
              settext ARL%, right$(gettext$(ARL%),7)+"0"                        ' Lösungs-Bit 0 anhängen (für Stelle << schieben)
              settext ARL%, right$(gettext$(ARL%),7)+"1"                        ' Lösungs-Bit 1 anhängen (für 'Division')
              settext ALa%, "1"                                                 ' Addition von -abs(Devisor), Position erreicht
              break                                                             
            else
              settext ALa%, "0"                                                 ' kein shift möglich ,keine Addition von -abs(Devisor)
              settext ARL%, right$(gettext$(ARL%),7)+"0"                        ' Lösungs-Bit 0 anhängen
              settext ALR%, gettext$(AL1%)                                      ' Rest nach ALR%
              break 
            endif 
          endif  
          ' ---------------
          if b1$+b2$ = "10"
            settext ARL%, right$(gettext$(ARL%),7)+"1"          ' Lösungs-Bit 1 anhängen 
            settext ALa%, "1"                                   ' Addition von -abs(Devisor), Position erreicht 
            break                                               ' Dividend größer Divisor
          endif
          ' ---------------
          if b1$+b2$ = "11"   
            if bit% = 9 
              if b3$ = "1"                    ' nur Zwischenergebnis weiterhin noch shift möglich
                settext ALa%, "1"                                   ' Addition von -abs(Devisor)
              else //   letzte Teilrechnung
                settext ALa%, "0"                                   ' keine Addition von -abs(Devisor) 
                settext ALR%, "000000000"                           ' Rest 0 nach ALR
              endif 
              settext ARL%, right$(gettext$(ARL%),7)+"1"            ' Lösungs-Bit  anhängen  
              break 
            else
              inc bit%
              settext ASP%, space$(bit%-2)+":"+ space$(9-bit%)
              ALU_bitstep
            endif
          endif 
          ' ---------------
        endwhile // zweite Teilschleife 
      endif 
      settext ASP%, space$(8)
      ALU_step
      '-------
      if gettext$(ALa%) = "1"              ' Addition negativer Divisor
        settext AL1%  , right$(gettext$(AL1%),8)          ' ohne Vorzeichenerweiterung, wir in add_ALU_9 davorgesetzt
        settext AL2%  , gettext$(ALN%)                    ' -abs(D1) nach AL2 zur Addition
        settext ASP%, " add N  "
        ' -------
        add_ALU_9                          ' <---  Addition im 9 Bit-Rechenwerk in der ALU  mit Flags
        ' -------
        b3$ = left$(gettext$(ALS%),1)                     ' Schiebezähler linkes Bit
        settext ASP%, space$(8)                           ' leeren
        ALU_step
        if b3$ ="1"                                       ' Schiebezähler linkes Bit = 1, Bit des Dividenden nachschieben
          settext AL1%, "0"+b_res$                        ' Differenz in b_res ist Rest,  wieder in AL1 setzen
          settext AL2%, "0"+gettext$(ALP%)                ' positiven Divisor mit Vorzeichenerw. in AL2 setzen
          settext ALC%, space$(9)
          settext ALR%, space$(9) 
          ALU_bitstep
          ' weiteres Bit des Dividenden nachschieben
          settext ASP%, space$(bit%-3)+"<-"+ space$(9-bit%) 
          settext AL1%, right$(gettext$(AL1%),8)+left$(gettext$(ALD%),1)  ' << AL1_ALD(1)  (Bitzähler nicht erhöhen!)
          settext ALD%, right$(gettext$(ALD%),7)+"0"                      ' << ALD(2..8)_0   
          settext ALS%, right$(gettext$(ALS%),7)+"0"                      ' Schiebezähler links schieben, 0 anhängen 
          ALU_step
        else
          break   ' fertig, in ALR ist Rest
        endif
      else //  keine Addition von -abs(D1)
        break     ' Rest in ALR
      endif
      case gettext$(ALf%) = "1" : settext ALf%, "0"     ' weitere Durchläufe der äußerer Schleife
    endwhile // äußere Schleife
    ALU_step
    '-------
    ' AV1, AV2 -> Vorzeichen von Quotient und Rest
    if gettext$(AV1%) = "0"                           ' Dividend positiv ...
      settext S%[0], right$(gettext$(ALR%),8)         ' ... Rest positiv
      if gettext$(AV2%) =  "0"                        ' Divisor positiv ...
        b_res$ = gettext$(ARL%)                       ' ... Quotient positiv
        ALU_step
      else     // (AV2%) = "1"                        ' Divisor negativ ... 
        settext AL1%, gettext$(ARL%)                  ' ... Quotient negativ
        settext ASP%, " Qu (-) "
        complement2_ALU                               ' 2er-Komplement (in b_res)
      endif
    elseif gettext$(AV1%) = "1"                       ' Dividend negativ ...
      settext AL1% , right$(gettext$(ALR%),8)         ' ... Rest negativ
      settext ASP%, " Re (-) "
      complement2_ALU                                 ' 2er-Komplement (in b_res)
      settext S%[0], b_res$                                              
      if gettext$(AV2%) = "0"                         ' Divisor positiv ...
        settext AL1%, gettext$(ARL%)                  ' ... Quotient negativ
        settext ASP%, " Qu (-) "
        complement2_ALU                               ' 2er-Komplement (in b_res)
      else    // (AV2%) = "1"                         ' Divisor negativ ... 
        b_res$ = gettext$(ARL%)                       ' ... Quotient positiv 
        ALU_step
      endif
    endif
    settext R%[0], b_res$                             ' Quotient nach D0
    flags_b_res_N_Z_0_0                               ' Flags (ohne Sonderfälle)
    ' -----                    
    settext ALS%,  space$(8)   ' temporäre ALU-Register leeren
    settext ALf%,  " " 
    settext ALt%,  " " 
    settext ALa%,  " "  
    settext ALD%,  space$(8) 
    settext ARL%,  space$(8)  
    hide(ALS%) : hide(ALf%) : hide(ALt%) : hide(ALa%) : hide(ALD%) :  hide(ARL%)  ' wieder verbergen
    textcolor chipc% , chipc% 
    drawtext 839, 165, "f"     ' mit Hintergrundfarbe der CPU überschreiben
    drawtext 847, 165, "t"
    drawtext 855, 165, "a"
    drawtext 865, 193, "S"
    drawtext 865, 210, "D"
    drawtext 865, 261, "L"
  endif // special = 0 (keine Sonderbehandlung)
  '
  ' nach Sonderbehandlung
  settext ASP%,  space$(8)   ' temporäre ALU-Register leeren   
  settext AV1%,  " " 
  settext AV2%,  " " 
  settext ALN%,  space$(8)                
  settext ALP%,  space$(8)
  hide(ASP%) : hide(AV1%) : hide(AV2%) : hide(ALN%) : hide(ALP%) 
  textcolor chipc% , chipc% 
  drawtext 704, 192, "Vz"        ' mit Hintergrundfarbe der CPU überschreiben
  drawtext 865, 227, "N"
  drawtext 865, 244, "P"
endproc
proc mul_Booth_ALU             ' Multiplikation nach Booth in der ALU 9Bit/8Bit
  var btmp1$ = gettext$(R%[0])         'Daten-Register lokal auslesen
  var btmp2$ = gettext$(R%[1])
  settext AL1%, space$(9)
  settext AL2%, space$(9)
  settext ALC%, space$(9)
  settext ALR%, space$(9)
  show(booth%) : show(ALBA%)     ' temporäre Register der ALU anzeigen
  settext AL1%, btmp1$          ' Register D0 nach AL1 ...
  ALU_step
  textcolor darkgreen%, chipc% 
  drawtext 865, 210, "A"
  settext ALBA%, btmp1$         ' D0 für Addition in temporäres Register A
  complement2_ALU                ' ... Zweierkomplement bilden
  show(ALBS%)
  textcolor darkgreen%, chipc%
  drawtext 865, 227, "S"
  settext ALBS% , b_res$         ' -D0  für Subtraktion (Zweierkomplement) in S darstellen
  ALU_step 
  show(ARL%) : show(ALx%)        ' temporäre Register der ALU 
  textcolor darkgreen%, chipc% 
  drawtext 865, 244, "x"
  settext ALR%  , "000000000"    ' 9 Bit: Anfangswert für fortlaufende Summenbildung  +/-, >> mit D0 (Vorzeichenerweiterung)
  settext ARL%  , btmp2$        ' 8 Bit: Register für Lösung, D1 einsetzen
  settext ALx% , "0"             ' 1 Bit  Anfangswert
  btmp2$ = b_res$               ' für Subtraktion +(-D0) umspeichern
  '
  whileloop 8
    settext AL1%, space$(9)       ' \                
    settext AL2%, space$(9)       '  -  ALU-Register leeren
    settext ALC%, space$(9)       ' /
    ALU_step 
    b1$ = right$(gettext$(ARL%),1)
    b2$ = gettext$(ALx%)
    if b1$ = b2$                  ' 00 und 11          
      shift_ALRx                  ' nur schieben (shift  >>)  mit Vorzeichenerweiterung
    else
      if (b1$="0") and (b2$="1")  
        settext AL2%, btmp1$     ' D0 zur Addition nach AL2   
      endif
      if (b1$="1") and (b2$="0") 
        settext AL2%, btmp2$     ' -D0 zur Addition nach AL2    
      endif  
      settext AL1%, right$(gettext$(ALR%),8)   ' laufende Summe nach AL1 umspeichern
      add_ALU_9                                ' Addition im 9 Bit-Rechenwerk in der ALU  mit Flags
      ALU_step 
      shift_ALRx                  ' schieben (shift  >>)  mit Vorzeichenerweiterung
    endif    
    ALU_step 
  endwhile
  '
  settext ALR%, " "+ right$(gettext$(ALR%),8) ' >> Zeichen entfernen
  settext ALBA%, space$(8)                    ' \
  settext ALBS%, space$(8)                    '  - temporäre ALU-Register leeren
  settext ARL%,  space$(8)                    ' /
  settext ALx%,  " "                          ' 
  textcolor chipc%, chipc%          ' mit Hintergrundfarbe überschreiben
  drawtext 865, 210, "A"
  drawtext 865, 227, "S"
  drawtext 865, 244, "x"
  settext booth%, chr$(187)+" Booth"
  hide(booth%) : hide(ALBA%) : hide(ALBS%) : hide(ARL%) : hide(ALx%)
endproc
'{--- Hilfsprozeduren Assembler ------
proc restore_instruction              ' Befehl (Eingabe)  mit Kommentar wiederherstellen
  settext mn% , left$( gettext$(RAM%, coderow%,3) , 3)     ' Mnemonic setzen
  settext op1%,  mid$( gettext$(RAM%, coderow%,3) , 5, 4)  ' Op 1 setzen
  settext op2%,  mid$( gettext$(RAM%, coderow%,3) ,10, 4)  ' Op 2 setzen
  settext opcomm%, trim$(mid$(comment$[coderow%],2,255))   ' Kommentar zum Befehlsetzen
endproc
proc restore_const                    ' Konstante (Eingabe) mit Kommentar wiederherstellen
  settext coninp%, trim$( left$( gettext$(RAM%, conrow%,3) ,4) )
  settext concomm%, trim$(mid$(comment$[conrow%],2,255))                      
endproc
proc restore_from_RAM                 ' Befehl oder Konstante aus RAM mit Kommentar wiederherstellen
    if (ramrow% > -1) AND (ramrow% < 128)  ' ramrow% ist -1 wenn auf "Teilzeile" am Ende der Gridbox geklickt wird!
      coderow% = ramrow%                  
      restore_instruction      ' Mnemonic Op1,2 und Kommentar in Eingabe-Edits setzen
    endif
    if (ramrow% > 127)  AND (ramrow% < 256) 
      conrow%  = ramrow%
      restore_const            ' Konstante (Eingabe) mit Kommentar setzen
    endif
 endproc 
proc rc                               ' Register-Code zuweisen
 parameters rg$
  case rg$= ".IA." : return ""
  case rg$= ".+A." : return ""
  case len(rg$)= 0 : return ""
  rg$ = mid$(rg$ ,2,2)             ' Register ohne Adressierung . . bzw. [  ]
  case rg$="D0" : return "00"  
  case rg$="D1" : return "01"
  case rg$="A0" : return "10"
  case rg$="A1" : return "11"
endproc   
proc load_asm                         ' HC680 Assembler-Datei laden (*.txt) 
  asmfile$ = ""
  row%  = -1                       ' Vorbelegung zur Prüfung ob gelesen wurde
  asmfile$ = loadfile$("Assembler-Datei laden","HC680 Assembler (*.txt)|*.txt")
  if len(asmfile$) > 0
    load_ram(0)                    ' ohne Verschiebung in den RAM laden
    initial_r0_r128                ' Edits und Variablen Zeile 0 und 128 initialisieren
  endif  
endproc
proc isnot_hex2                       ' Prüfung auf nicht korrekte Hexadezimaladresse
 parameters h1$
  var h2$ = right$(h1$,1)
  var ord1% = ord(h1$)    ' ord( ) benutzt linkes Zeichen der zweistelligen Adresse 
  var ord2% = ord(h2$) 
  if len(h1$) > 2          'Länge von h1$ prüfen
    messagebox("falsche Adresslänge - Adresse: "+ h1$  +"\n \nAdresse 00  bis FF   bzw. ff  beachten.","--- Adressfehler ---",16)
    return 1
  endif  
  if   (ord1% < 48) or ((ord1% > 57) and (ord1% < 65)) or ((ord1% > 70) and (ord1% < 97))  or (ord1% > 102) \
    or (ord2% < 48) or ((ord2% > 57) and (ord2% < 65)) or ((ord2% > 70) and (ord2% < 97))  or (ord2% > 102) 
        messagebox("falsche Adresse: "+ h1$  +"\n \nAdresse 00  bis FF   bzw. ff  beachten.","--- Adressfehler ---",16)  
    return 1
  else 
    return 0
  endif 
endproc
proc rel_value                        ' Verschiebungswert für Assembler im RAM bearbeiten
  if getfocus(verschieb%) 
    ansi% = ord(trim$(gettext$(verschieb%)))                     ' ANSI 1. Zeichen
    if ( (ansi%=36) or (ansi%=72) or (ansi%=104) )  '  $ ,H ,h  1.Zeichen  positive Hexadezimalzahl
      verschbg%  = val("$"+ mid$(gettext$(verschieb%),2,3))      ' in dez umrechnen  
      settext toolverschieb%, %hwnd, verschieb%, "dez +"+ str$(verschbg%) + verstooltxt$
    elseif ansi% = 45     
      ansi% = ord(mid$(trim$(gettext$(verschieb%)),2,4))         ' ANSI 2. Zeichen wenn Minuszeichen am Anfang
      if   ( (ansi%=36) or (ansi%=72) or (ansi%=104) )    ' - und $ ,H ,h  2.Zeichen  negative Hexadezimalzahl
        verschbg%  =  -val("$"+ mid$(trim$(gettext$(verschieb%)),3,3))    ' in dez umrechnen - negativ
        settext toolverschieb%, %hwnd, verschieb%, "dez "+ str$(verschbg%) + verstooltxt$
      else ' negativ dezimal
        verschbg%  = val(gettext$(verschieb%))
        settext toolverschieb%, %hwnd, verschieb%, "-h"+ hex$(-verschbg%) + verstooltxt$
      endif
    else  ' also positiv dezimal
        verschbg%  = val(gettext$(verschieb%)) 
        settext toolverschieb%, %hwnd, verschieb%, "h"+ hex$( verschbg%) + verstooltxt$
    endif  
    if ((verschbg%<-255) or (verschbg%>255))     ' Tooltip überschreiben
     settext toolverschieb%, %hwnd, verschieb%, " Dezimalwert nicht möglich! "  + verstooltxt$
    endif  
  endif  
endproc
proc store_asm                        ' HC680 Assembler-Datei speichern (*.txt)  
  asmfile$ = ""
  asmfile$ = savefile$("Assembler-Datei speichern","HC680 Assembler (*.txt)| *.txt")
  if len(asmfile$) > 0
    pv$ = gettext$(prgvon%)  ' Programm von  (hexadezimal)
    pb$ = gettext$(prgbis%)  ' Programm bis  (hexadezimal)
    dv$ = gettext$(datvon%)  ' Daten    von  (hexadezimal)
    db$ = gettext$(datbis%)  ' Daten    bis  (hexadezimal)
    row% = -1       ' Vorbelegung zur Fehlerprüfung
    case ( len(pv$)=0 ) and ( len(pb$) = 0 ) and ( len(dv$)=0 ) and ( len(db$)=0 ) : dec row% ' kein Bereich
    if ( len(pv$)>0 ) and ( len(pb$)>0 )
      if isnot_hex2(pv$) or isnot_hex2(pb$) 
        dec row%   '  Fehler: Eingaben nicht korrekt hexadezimal ein oder zweistellig
      endif
    endif  
    if ( len(dv$)>0 ) and ( len(db$)>0 )   
      if isnot_hex2(dv$) or isnot_hex2(db$)  'logische Funktionen mit Fehlermeldung ...
         dec row%   '  Fehler: Eingaben nicht korrekt hexadezimal ein oder zweistellig  
      endif
    endif 
    ' 
    case row%  = -1 :  store_ram   ' abspeichern der RAM-Zeilen mit Adressen xx  (xx hexadezimal )
    '  
    if row%  < 0       ' keine Speicherung erfolgt
      messagebox("Es erfolgte keine Speicherung."," --- Fehler beim Speichern ---",48)
    endif 
  endif // Datei 
endproc 
proc reloc_asm                        ' Assembler im RAM verschieben
  var msgprg$ = ""                 ' Text  für Fehlermeldung     
  var msgdat$ = ""
  var msgver$ = ""
  pv$ = gettext$(prgvon%)          ' Programm von  (hexadezimal)
  pb$ = gettext$(prgbis%)          ' Programm bis  (hexadezimal)
  dv$ = gettext$(datvon%)          ' Daten    von  (hexadezimal)
  db$ = gettext$(datbis%)          ' Daten    bis  (hexadezimal)
  '
  if ( len(pv$)>0 ) and ( len(pb$)>0 )             ' Verschiebung im Programmbereich
    if isnot_hex2(pv$) or isnot_hex2(pb$)
      msgver$ = ""  ' als Fehlerkennung, Abbruch (Eingaben nicht korrekt hexadezimal ein oder zweistellig)
      '
    else
      msgprg$ = "\n   Befehlsbereich  h" + pv$+" bis  h" + pb$ 
    endif  
  endif
  '
  if ( len(dv$)>0 ) and ( len(db$)>0 )             ' Verschiebung im Datenbereich
    if isnot_hex2(dv$) or isnot_hex2(db$)  'logische Funktionen mit Fehlermeldung ...
      msgver$ = ""  ' als Fehlerkennung, Abbruch  (Eingaben nicht korrekt hexadezimal ein oder zweistellig)
      '
    else  
      msgdat$ = "\n     Datenbereich  h" + dv$+" bis  h" + db$  
    endif
  endif
  '
  if verschbg% <> 0  ' nicht: leer oder 0
    msgver$ =   + "\nim RAM um dezimal "+ str$(verschbg%) +" verschieben? "
  endif 
  '
  if msgprg$ <> ""           ' Verschiebung im Programmbereich
    if    ( (val("$"+pv$)  + verschbg%) <  0 )    \
       or ( (val("$"+pb$)  + verschbg%) > 127 )          
      messagebox("Alter oder neuer Programmbereich fehlerhaft. ","--- Fehler beim Verschieben! ---",48) 
      msgver$ = ""  ' als Abbruchkennung
      msgprg$ = "b_fehler"
    endif
  endif
  '
  if msgdat$ <> ""           ' Verschiebung im Datenbereich
    if    ( (val("$"+dv$)+verschbg%) < 128 )    \
       or ( (val("$"+db$)+verschbg%) > 255 )    
      messagebox("Alter oder neuer Datenbereich fehlerhaft. "  ,"--- Fehler beim Verschieben! ---",48) 
      msgver$ = ""  ' als Abbruchkennung
      msgdat$  = "b_fehler"
    endif
  endif 
  '
  if  (msgver$ = "") or ( (msgver$ <>"") and (msgprg$ = "") and (msgdat$ = "")  ) ' fehlerhafte Werte
    if  (( msgprg$ <> "b_fehler" ) and ( msgdat$ <> "b_fehler" ))                 ' noch keine Fehlermeldung erfolgt
    '  
      messagebox("Fehler! \n\nBitte die Werte der Verschiebung überprüfen.  "," --- Verschiebung im RAM ---", 48)  
    endif
  else    '   
    if ( messagebox("Wollen Sie den    " + msgprg$ + msgdat$ + msgver$," --- Verschiebung im RAM ---", 289) = 1 )  
      asmfile$ = "asm_tmp.txt"       ' asm_tmp.txt als
      store_ram                      ' Zwischenspeicher ablegen (mit Prüfung von < bis, sonst Fehlermeldung)
      if row% > -1                   ' Speicherung temporäre Datei erfolgreich, weitere Schritte möglich
        pv$ = "00"                   ' kompletten RAM 
        pb$ = "7F"
        dv$ = "80"
        db$ = "FF"
        asmfile$ = "asm_bak.txt"     ' als Backup asm_bak.txt
        store_ram                    ' sichern 
        '
        asmfile$ = "asm_tmp.txt"     ' Zwischenspeicher nutzen ...
        clear_source_ram             ' ... RAM-Zeilen, Kommentare der alten Adressen des Verschiebebereichs löschen ... 
        load_ram(verschbg%)          ' ... mit Verschiebung in den RAM laden
        initial_r0_r128              ' Initialzustand Assembler herstellen
      endif
    endif // Message verschieben ok
  endif // Message fehlerhafte Werte  
endproc
proc clear_source_ram                 ' RAM-Quellbereich der Verschiebung auf Null setzen
assign #1,asmfile$ 
  reset #1
  input #1, asm$                    ' Titelzeile - verwerfen
  input #1, asm$                    ' Startadresse ohne Belang
  input #1, asm$                    ' Zwischenzeile Überschrift Befehle - verwerfen
  ' --- Assemblerbefehle und Daten einlesen
  whilenot ( eof(#1) )  
    input #1, asm$
    asm$   = trim$(asm$)                ' umgebende Leerzeichen verwerfen
    row%   = val("$"+left$(asm$,2))     ' dezimale RAM-Adresse
    ' Inhalte auf NOP, Null, leer setzen
    if row% < 128                       ' Befehle:
      coderow% = row%                     ' dezimale RAM-Adresse
      mn$ ="00000000"                     ' zurücksetzen!
      opcomm$ = ""                        ' Komentarleeren
      assembler_to_binary_code            ' Befehl, Operanden und Kommentar setzen
    endif
    if row% > 127                       ' Daten 
      conrow% = row%                      ' dezimale RAM-Adresse
      coninp$ = ""                        ' zurücksetzen
      concomm$ = ""                       ' Komentarleeren
      define_constant                     ' Konstante und Kommentar setzen
    endif
  endwhile // Dateiende erreicht  
  close #1  
endproc
proc load_ram                         ' laden der RAM-Zeilen aus Datei (Adressen vor Befehlen/Daten)
 parameters rel%        ' Parameter zur Verschiebung beim Einlesen, dann alte Adressen auf NOP, Null setzen
  var ts% = 0           ' Nr. Teilstring, Trennung verschiedene Anzahl Leerzeichen zwischen Adr., Mnemonik, Operanden
  assign #1,asmfile$ 
  reset #1
  input #1, asm$                    ' Programmname aus Titelzeile 
  prgn$ =  trim$(substr$(asm$,2,";"))
  settext progname%, prgn$
  input #1, asm$
  settext startadr%,left$(asm$,2)   ' 2-stellige Hexadezimaladresse Startadresse
  input #1, asm$                    ' Zwischenzeile Überschrift Befehle - verwerfen
  ' --- Assemblerbefehle und Daten einlesen
  whilenot ( eof(#1) )  
    input #1, asm$
    asm$   = trim$(asm$)                ' umgebende Leerzeichen verwerfen
    '
    hex2$  = left$(asm$,2)              ' ord( ) benutzt linkes Zeichen der zweistelligen Adresse
    hex1$  = right$(hex2$,1)            ' rechte Ziffer
    if rel% = 0                         ' beim laden Assembler Dateieinträge prüfen
      if   (ord(hex2$)< 48) or ((ord(hex2$)>57) and (ord(hex2$)< 65)) or ((ord(hex2$)>70) and (ord(hex2$)< 97))  or (ord(hex2$)>102) \
        or (ord(hex1$)< 48) or ((ord(hex1$)>57) and (ord(hex1$)< 65)) or ((ord(hex1$)>70) and (ord(hex1$)< 97))  or (ord(hex1$)>102) 
        messagebox("Abbruch, falsche Adresse: "+ hex2$  +"\n \nAdresse 00  bis FF   bzw. ff  beachten.","--- Fehler beim Laden der Datei! ---",48)
        break                            ' Abbruch
      endif
    endif
    '
    l_asm% = len(asm$)                  ' Länge der Assemblerzeile
    row%   = val("$"+left$(asm$,2))     ' dezimale RAM-Adresse
    '
    row% = row% + rel%                  '  neue Adesse (rel% nur bei Verschiebung , sonst Aufruf mit 0)  
    '
    if row% < 128                     ' Befehle 
      coderow% = row%                     ' dezimale RAM-Adresse
      mn$ ="" : op1$="" : op2$=""         ' zurücksetzen, da von input#1 sonst alter Inhalt bleibt!
      ts% = 2                             ' ts% =2 --> zweiter Teilstring ist Mnemonic des Befehls
      mn$ = substr$(asm$,ts%," ")         
      if mn$ = ""                         ' Leerzeichen statt :
        inc ts%  
        mn$ = substr$(asm$,ts%," ")  
      endif  
      case len(mn$) = 2 : mn$ = mn$ + " " ' Leerzeichen zufügen bei OR, ##
      if l_asm% >  11 
        inc ts%
        op1$ =  substr$(asm$,ts%," ")     ' Operand nach einem Leerzeichen
        if op1$ = ""
          inc ts%                         ' weitere Leerzeichen als Trennung vorhanden ...
          op1$ = substr$(asm$,ts%," ")  
        endif  
        if op1$ = "" 
          inc ts%
          op1$ = substr$(asm$,ts%," ")
        endif  
        if op1$ = ""
          inc ts%
          op1$ = substr$(asm$,ts%," ")
        endif  
        case len(op1$) = 2 : op1$ = "."+op1$+"."  ' Punkte ergänzen
      else
        op1$ = ""
      endif // Operand 1
     '
      if len(op1$) > 0                   ' erster Operand vorhanden
        inc ts%
        op2$ =  substr$(asm$,ts%," ")    ' Zweiter Operand nach einem Leerzeichen
        if op2$ = ""
          inc ts%                        ' weitere Leerzeichen als Trennung vorhanden ...
          op2$ = substr$(asm$,ts%," ") 
        endif 
        if op2$ = ""
          inc ts%
          op2$ = substr$(asm$,ts%," ") 
        endif  
        if op2$ = ""
          inc ts%
          op2$ = substr$(asm$,ts%," ") 
        endif  
        case len(op2$) = 2 : op2$ = "."+op2$+"."  ' Punkte ergänzen
      else  
        op2$ = ""
      endif // Operand 2
      '
      if l_asm%  > 19                     ' Kommentar vorhanden (mit ; Position 20 ab Position 21 beginnend)
        opcomm$ = mid$(asm$,21,l_asm%-20) ' ohne ; einlesen, wird intern wieder zugefügt!
      endif   
      assembler_to_binary_code            ' Befehl, Operanden und Kommentar setzen
    endif 
    '
    if row% > 127                     ' Daten 
      conrow% = row%                      ' dezimale RAM-Adresse
      coninp$ = ""                        ' zurücksetzen, da bei input#1 sonst alter Inhalt bleibt!
      coninp$ = substr$(asm$,2," ")       ' zweiter Teilstring ist Wert der Konstanten
      case coninp$="" : coninp$ = substr$(asm$,3," ")   'falls zwei Leerzeichen als Trennung
      case coninp$="" : coninp$ = substr$(asm$,4," ")   'falls drei Leerzeichen als Trennung
      case coninp$="" : coninp$ = substr$(asm$,5," ")   'falls vier Leerzeichen als Trennung
      case coninp$="" : coninp$ = substr$(asm$,6," ")   'falls fünf Leerzeichen als Trennung
      if l_asm%  > 19                      ' Kommentar vorhanden (ab Position 20 mit ; beginnend)
        concomm$ = mid$(asm$,21,l_asm%-20) ' ohne Semikolon einlesen, wird intern wieder zugefügt 
      endif
      define_constant                     ' Konstante und Kommentar setzen
    endif
  endwhile // Dateiende erreicht
  close #1
endproc
proc initial_r0_r128                  ' initialisieren Adr. 0 und 128
  coderow% = 0                            ' wieder auf Standard Startadr. 00 setzen
  restore_instruction                     ' Mnemonic Op1,2 Kommentar in Eingabe-Edits setzen
  mn$      = gettext$(mn%)                ' Mnemonic  wieder auslesen 
  op1$     = gettext$(op1%)               ' Operand 1 wieder auslesen 
  op2$     = gettext$(op2%)               ' Operand 2 wieder auslesen 
  opcomm$  = gettext$(opcomm%)            ' Kommentar Befehl wieder auslesen 
  hide(op1%)                              ' Operandeneingaben verbergen 
  hide(op2%)
  conrow% = 128                           ' wieder auf Anfang Konstanten setzen
  restore_const                           ' Konstante und Kommentar dazu in Eingabe-Edits setzen
  coninp$  = gettext$(coninp%)            ' Konstante wieder auslesen
  concomm$ = gettext$(concomm%)           ' Kommentar Konstante wieder auslesen 
endproc
proc store_ram                        ' abspeichern Assembler in den gegebenen Grenzen
   if    ( val("$"+pv$) < val("$"+pb$) +1 ) \
     and ( val("$"+dv$) < val("$"+db$) +1 )  ' Anfangsadresse < = Endadresse prüfen
    assign #1,asmfile$
    rewrite #1              ' vorhandene überchreiben 
    asm$ = "HC680 Assembler    ;"+prgn$
    print #1, asm$
    asm$ = right$(gettext$(startadr%),2) + ": ST             ; Startadr."
    print #1, asm$
    asm$ = "Adr Mnm _Op_ _Op_  ;  - Kommentar -"
    print #1, asm$                                                               
    ' --- Programm --- 
    if (len(pv$)>0) and (len(pb$)>0)         ' keine Angabe - keine Speicherung des Programmbereichs
      row% = val("$"+pv$)                    ' ab Anfangsadresse Programm speichern  
        while row% < val("$"+pb$) +1           ' bis Endadresse Programm 
          asm$ = gettext$(RAM%, row%, 1) + ": "+trim$(gettext$(RAM%, row%, 3))
          asm$ = asm$ + space$( 19 - len(asm$) ) + comment$[row%]   
          print #1, asm$ 
          inc row% 
        endwhile 
    endif  
   ' --- Daten ---
    if (len(dv$)>0) and (len(db$)>0)         ' keine Angabe - keine Speicherung des Datenbereichs
      row% = val("$"+dv$)                    ' ab Datenadresse Anfang speichern  
      while row% < val("$"+db$) + 1          ' bis Endadresse Daten
        asm$ = gettext$(RAM%, row%, 1) + ": "+  trim$(gettext$(RAM%, row%, 3)) 
        asm$ = asm$ + space$(7) + comment$[row%] 
        print #1, asm$
        inc row%    
      endwhile 
    endif
    close #1
  else
    messagebox("Programm oder Daten \n   'bis' < 'von' \nSpeicherung nicht möglich  "  ,"--- Fehler beim Speichern! ---",48) 
    row% = -1   ' als Kennung "nicht gespeichert" 
  endif  
endproc
'}
proc assembler_to_binary_code  ' Assembler   -->   Binärcode
  select mn$              ' Opcode binär (gegliedert)   /  Bedeutung/Wirkung
  
                          '      Gruppe Bit  yy   xx    / yy, xx z.T. Operanden (Register)
                          '        ---   -   --   --
     caseof ""                                               ' Anzeige der betroffenen Flags
                           oc$ =  ""                           
       clr_hide12:                                            fl$ = "    "
    caseof "NOP"
                           oc$ =  "000"+"0"+"00"+"00"   
      clr_hide12:                                             fl$ = "    "
    caseof "CMP"
                           oc$ =  "000"+"0"+"00"+"01"   
      clr_hide12:                                             fl$ = "NZVC"
    caseof "SWD"
                           oc$ =  "000"+"0"+"00"+"10"    
      clr_hide12:                                             fl$ = "    "  
    caseof "SWM" 
                           oc$ =  "000"+"0"+"00"+"11"   
      clr_hide12:                                             fl$ = "    "
    caseof "MUL"  
                           oc$ =  "000"+"0"+"01"+"00"    
      clr_hide12:                                             fl$ = "NZVC"
    caseof "DIV" 
                           oc$ =  "000"+"0"+"01"+"01"   	 
      clr_hide12:                                             fl$ = "NZVC"
    caseof "PSA" 
                           oc$ =  "000"+"0"+"01"+"10"    
      clr_hide12:                                             fl$ = "    "
    caseof "POA" 
                           oc$ =  "000"+"0"+"01"+"11"    
      clr_hide12:                                             fl$ = "NZVC"
    caseof "JSR"  
                           oc$ =  "000"+"0"+"10"+"00"     
      clr_hide12:                                             fl$ = "    "
    caseof "RET"                            ' Achtung: Reihenfolge Code
                           oc$ =  "000"+"0"+"11"+"00"    ' 
      clr_hide12:                                             fl$ = "NZVC"
    caseof  "JIN", "JIZ" , "JMP"  
      show(op1%)
      select op1$
        caseof ".+A."   
          case mn$="JIN" : oc$ =  "000"+"0"+"10"+"01"    
          case mn$="JIZ" : oc$ =  "000"+"0"+"10"+"10"    
          case mn$="JMP" : oc$ =  "000"+"0"+"10"+"11"    
                                                              fl$ = "    "
        caseof ".IA."
          case mn$="JIN" : oc$ =  "000"+"0"+"11"+"01"
          case mn$="JIZ" : oc$ =  "000"+"0"+"11"+"10"
          case mn$="JMP" : oc$ =  "000"+"0"+"11"+"11"
                                                              fl$ = "    "
        caseof ".D0.",".D1.",".A0.",".A1."  ' Achtung: Reihenfolge Code               
          case mn$="JIN" : oc$ =  "000"+"1"+"01" + rc(op1$) 
          case mn$="JIZ" : oc$ =  "000"+"1"+"10" + rc(op1$) 
          case mn$="JMP" : oc$ =  "000"+"1"+"11" + rc(op1$) 
                                                              fl$ = "    "
        otherwise
          oc$ = "00000000"
          fl$ = "    "
      endselect 
      op2$ = "" : hide(op2%) 
    caseof "LDC"                            
      show(op1%)
      select op1$
        caseof ".D0.",".D1.",".A0.",".A1."   ' Achtung: Reihenfolge Code
                           oc$ =  "000"+"1"+"00" + rc(op1$) : fl$ = "NZ  "         
        otherwise
          oc$ = "00000000"
          fl$ = "    " 
        endselect
        op2$ = "" : hide(op2%) 
    caseof  "## "
      show(op1%): show(op2%)    
      op1$ = trim$(op1$) : op2$ = trim$(op2$)
      '
      if   (    ( len(op1$) = 4 ) and ( len(op2$) = 4 )    )      \
        and \ 
           (    ( (left$(op1$,1) ="0") or (left$(op1$,1) ="1") )  \ 
            and ( (mid$(op1$,2,1)="0") or (mid$(op1$,2,1)="1") )  \                                  
            and ( (mid$(op1$,3,1)="0") or (mid$(op1$,3,1)="1") )  \ 
            and ( (right$(op1$,1)="0") or (right$(op1$,1)="1") )  \ 
            and ( (left$(op2$,1) ="0") or (left$(op2$,1) ="1") )  \ 
            and ( (mid$(op2$,2,1)="0") or (mid$(op2$,2,1)="1") )  \                                  
            and ( (mid$(op2$,3,1)="0") or (mid$(op2$,3,1)="1") )  \ 
            and ( (right$(op2$,1)="0") or (right$(op2$,1)="1") )  \ 
           )  
                                                               '  Prüfung der Konstanten    
       '------------------------------------------------------        
                           oc$ =  op1$ + op2$            :  fl$ = "    "   
      else
        oc$ = "00000000"  
        fl$ = "    "
      endif 
    caseof "INP", "OUT" , "PSH", "POP" , "SSR" ,  "GSR" , "BTS" , "SWN"    
      show(op1%)
      select op1$
        caseof ".D0.",".D1.",".A0.",".A1."
          if mn$="INP" 
                           oc$ =  "001"+"0"+"00" + rc(op1$) : fl$ = "NZ  " 
          endif
          if mn$="OUT" 
                           oc$ =  "001"+"0"+"01" + rc(op1$) : fl$ = "    "
          endif 
          if mn$="PSH" 
                           oc$ =  "001"+"0"+"10" + rc(op1$) : fl$ = "NZ  "
          endif                 
          if mn$="POP" 
                           oc$ =  "001"+"0"+"11" + rc(op1$) : fl$ = "NZ  " 
          endif   
          if mn$="SSR" 
                           oc$ =  "001"+"1"+"00" + rc(op1$) : fl$ = "NZ  " 
          endif   
          if mn$="GSR" 
                           oc$ =  "001"+"1"+"01" + rc(op1$) : fl$ = "NZ  " 
          endif   
          if mn$="BTS"
                           oc$ =  "001"+"1"+"10" + rc(op1$) : fl$ = "NZ  "
          endif                 
          if mn$="SWN"                 
                           oc$ =  "001"+"1"+"11" + rc(op1$) : fl$ = "NZ  "
          endif                    
        otherwise
          oc$ = "00000000"  
          fl$ = "    "  
      endselect 
      op2$ = "" : hide(op2%)  
    caseof "SHL" ,"SHR", "ROL", "ROR", "CLR", "INC","DEC", "NOT"     
      show(op1%)
      select op1$
        caseof ".D0.",".D1.",".A0.",".A1."
          if mn$="SHL"
                           oc$ =  "010"+"0"+"00" + rc(op1$)  : fl$ = "NZ C"
          endif                 
          if mn$="SHR"
                           oc$ =  "010"+"0"+"01" + rc(op1$)  : fl$ = " Z C"
          endif                 
          if mn$="ROL"
                           oc$ =  "010"+"0"+"10" + rc(op1$)  : fl$ = "NZ C"
          endif                 
          if mn$="ROR" 
                           oc$ =  "010"+"0"+"11" + rc(op1$)  : fl$ = "NZ C"
          endif 
          if mn$="CLR" 
                           oc$ =  "010"+"1"+"00" + rc(op1$)  : fl$ = " Z  "
          endif
          if mn$="INC"
                           oc$ =  "010"+"1"+"01" + rc(op1$)  : fl$ = "NZVC"
          endif  
          if mn$="DEC" 
                           oc$ =  "010"+"1"+"10" + rc(op1$)  : fl$ = "NZVC"
          endif  
          if mn$="NOT" 
                           oc$ =  "010"+"1"+"11" + rc(op1$)  : fl$ = "NZ  "
          endif
        otherwise
          oc$ = "00000000"
          fl$ = "    "
      endselect 
      op2$ = "" : hide(op2%)       
    caseof  "AND" , "OR "
      show(op1%) : show(op2%)
      select op1$              
        caseof ".D0.",".D1.",".A0.",".A1."
          select op2$
            caseof ".D0.",".D1.",".A0.",".A1."
              if op1$ = op2$                 '  Gleichheit ausschließen, Code für MOV mit SR, SP
                oc$ = "00000000"  
                fl$ = "    "
              else
                case mn$="AND": oc$= "011"+"0" + rc(op1$) + rc(op2$)          ' mit op1<>op2
                case mn$="OR ": oc$= "011"+"1" + rc(op1$) + rc(op2$)          ' mit op1<>op2
                                                                fl$ = "NZ  "
              endif 
            otherwise
              oc$ = "00000000"  
              fl$ = "    "
          endselect  
        otherwise
          oc$ = "00000000"
          fl$ = "    "
      endselect 
    caseof  "ADD", "SUB"
      show(op1%): show(op2%)
      select op1$              
        caseof ".D0.",".D1.",".A0.",".A1."  
          select op2$                   
            caseof ".D0.",".D1.",".A0.",".A1."   
              if op1$ = op2$                 '  Gleichheit ausschließen, Code für MOV mit SR, SP
                oc$ = "00000000"  
                fl$ = "    "
              else                              'ACHTUNG:  Reihenfolge Code:
                case mn$="ADD": oc$= "100"+"0" + rc(op1$) + rc(op2$) ' 1.     ' mit op1<>op2
                case mn$="SUB": oc$= "101"+"0" + rc(op1$) + rc(op2$) ' 3.     ' mit op1<>op2
                                                                fl$ = "NZVC"   
              endif
            caseof "[D0]","[D1]","[A0]","[A1]"   '4. Bit Adressierungsart Op.2
              case mn$="ADD": oc$= "100"+"1" + rc(op1$) + rc(op2$)   ' 2.
              case mn$="SUB": oc$= "101"+"1" + rc(op1$) + rc(op2$)   ' 4.
                                                              fl$ = "NZVC" 
            otherwise
              oc$ = "00000000"
              fl$ = "    "
          endselect 
        otherwise
          oc$ = "00000000" 
          fl$ = "    "
      endselect 
    caseof  "MOV"                                                    
      show(op1%): show(op2%)  
      select op1$ 
        caseof "[D0]","[D1]","[A0]","[A1]"
          select op2$ 
            caseof ".D0.",".D1.",".A0.",".A1."  
                          oc$ = "110"+"0" + rc(op1$) + rc(op2$) 
                                                            fl$ = "NZ  "
            otherwise                              
              oc$ = "00000000" 
              fl$ = "    "
          endselect         
        caseof ".D0.",".D1.",".A0.",".A1."  
          select op2$  
       
            caseof "[D0]","[D1]","[A0]","[A1]"
                          oc$ = "110"+"1" + rc(op1$) + rc(op2$)
                                                            fl$ = "NZ  "
            caseof ".D0.",".D1.",".A0.",".A1."
              if op1$ = op2$                 '  Gleichheit ausschließen, Code für MOV SR <- CC
                oc$ = "00000000"  
                fl$ = "    "
              else     
                          oc$ = "111"+"0" + rc(op1$) + rc(op2$)              ' mit op1<>op2
                                                            fl$ = "NZ  "
              endif                                              
      ' !!! von !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                              'ACHTUNG:  Reihenfolge Code:
            caseof ".SR."
                          oc$= "011"+"0" + rc(op1$) + rc(op1$)     ' Code wie AND mit doppeltem op1 !
                                                            fl$ = "NZ  "
            caseof ".SP."
                          oc$= "011"+"1" + rc(op1$) + rc(op1$)     ' Code wie OR  mit doppeltem op1 !
                                                            fl$ = "NZ  "
      ' !!! bis !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                                                   
            caseof ".IA."                               
                          oc$ = "111"+"1"+"00" + rc(op1$) : fl$ = "NZ  "   ' op1 ist Register
            otherwise
              oc$ = "00000000" 
              fl$ = "    "
          endselect  
          
      '!!! von !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        caseof ".SR."
          select op2$ 
            caseof ".D0.",".D1.",".A0.",".A1."
                          oc$= "100"+"0" + rc(op2$) + rc(op2$)     ' Code wie ADD mit doppeltem op2 !
                                                            fl$ = "NZ  "
            caseof ".00.",".01.",".10.",".11."                     ' IO Bits in SR setzen
                          oc$ = "111"+"0" +  mid$(op2$,2,2) + mid$(op2$,2,2) ' Code statt MOV Rg=Rg 
                                                            fl$ = "    "    ' keine Flags bei IO
            otherwise                              
              oc$ = "00000000" 
              fl$ = "    "
            endselect  
        caseof ".SP."  
          select op2$ 
            caseof ".D0.",".D1.",".A0.",".A1."
                          oc$= "101"+"0" + rc(op2$) + rc(op2$)     ' Code wie SUB mit doppeltem op2 ! 
                                                            fl$ = "NZ  "
            otherwise                              
              oc$ = "00000000" 
              fl$ = "    "
            endselect 
      '!!! bis !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
          
        caseof ".IA."                                ' IA 1. Operand
          select op2$ 
            caseof ".D0.",".D1.",".A0.",".A1."      
                          oc$ = "111"+"1"+"01" + rc(op2$) : fl$ = "NZ  "   ' op2 ist Register
            otherwise
              oc$ = "00000000"  
              fl$ = "    "
          endselect
        otherwise
          oc$ = "00000000" 
          fl$ = "    "
      endselect      
    caseof "LOD"                                                            
      show(op1%)
      select op1$
        caseof ".D0.",".D1.",".A0.",".A1."
                          oc$ = "111"+"1"+"10" + rc(op1$) : fl$ = "NZ  "   ' op1  ist Register   
        otherwise
          oc$ = "00000000" 
          fl$ = "    "
      endselect 
      op2$ = "" : hide(op2%)
    caseof "STO"                                                               
                          oc$ = "111"+"1"+"11"+"00"       : fl$ = " Z  "
      clr_hide12
    caseof "RCL"                                                    
                          oc$ = "111"+"1"+"11"+"01"       : fl$ = " ZV "
      clr_hide12  
    caseof "CPY"                                                  
                          oc$ = "111"+"1"+"11"+"10"       : fl$ = " ZV "
      clr_hide12
    caseof "STP"                                                   
                          oc$ = "111"+"1"+"11"+"11"       : fl$ = "vvvv"
      clr_hide12                                        'Flags vom Vorbefehl werden erhalten!
    otherwise // Mnemonics
     oc$ = "00000000"
     fl$ = "    "
  endselect
  settext RAM%, coderow%, 2, oc$                            ' Op Code in RAM eintragen
  settext RAM%, coderow%, 3, mn$ +" "+ op1$ +" " + op2$     ' Befehl/ Wert in RAM eintragen
  case (oc$ = "00000000") AND (mn$<>"## "): settext RAM%, coderow%, 3, "NOP"           ' Standard setzen
  case (oc$ = "00000000") AND (mn$="## ") : settext RAM%, coderow%, 3, "##  0000 0000" ' Null setzen
  settext cadr%, dez_to_hex2(coderow%)                      ' Codeadresse hexadezimal eintragen
  settext oc%  , oc$                                        ' Op Code eintragen
  settext fl%, fl$                                          ' Flags eintragen
  comment$[coderow%]  = ";"+ opcomm$                        ' Kommentar in Kommentarfeld speichern
endproc
proc define_constant           ' Assembler   -->   Datendefinition
  settext conadr%, dez_to_hex2(conrow%)  
  ansi%   = ord(coninp$)
  if ((ansi%>47) and (ansi%<58)) or ((ansi%=45) and (len(coninp$)>1)) ' Dezimalziffer oder Minuszeichen am Anfang
    conval% = val(coninp$)
    conbin$ = dez_to_bin8(conval%)     ' in Binärzahl (negativ: Zweierkomplement) wandeln 
    if (conval% > -129) and (conval% < 128) 
      settext conalt%, str$( val("%"+ dez_to_bin8(conval%)) )  ' alternative Darstellung der Eingabe Zeichen/Zahl
      settext conans%, chr$(conval%) ' Zeichen darstellen
    else      ' --- Zahleneingabe:  < -128  oder  > 127    -> OVERFLOW -> auf Null setzen ---
      coninp$ = "0"
      conbin$ = "00000000"
      settext coninp%,coninp$  
      settext conalt%,""
      settext conans%,""   
    endif
  elseif ( (ansi%=36) or (ansi%=72) or (ansi%=104) ) and (len(coninp$)=3)  ' $ oder H oder h am Anfang: Hexadezimalzahl
    conbin$ = hex2_to_bin8(mid$(coninp$,2,2))                ' Hexadezimalzahl in Binärzahl 
    conval% = val("%"+ conbin$)                              ' korrigierter Eingabewert (Buchstabe über F, f zu 0)
    settext conalt%, str$( val("%"+ dez_to_bin8(conval%)) )  ' alternative Darstellung der Eingabe Zeichen/Zahl
    settext conans%, chr$(conval%)                           ' Zeichen darstellen
  else                ' Eingabe eines Tastaturzeichens 
    if len(coninp$)=1        
      conbin$ = d255_to_bin8(ansi%)                      ' ANSI-Code des Zeichens binär
      settext conalt%, str$(bin8_to_dez(conbin$ ))       ' Wert des Zeichens
      settext conans%, str$(ansi%)                       ' ANSI-Code des Zeichens dezimal
    else   ' mehr als ein Zeichen
      coninp$ = "0"
      conbin$ = "00000000"
      settext conalt%,""
      settext conans%,""
    endif 
  endif  
  settext conbin%, conbin$                               ' binär anzeigen 
  settext conhex%, bin8_to_hex2(conbin$)                 ' hexadezimal anzeigen
  settext RAM%, conrow%, 2, conbin$                      ' binär im RAM ablegen
  sp_h$ = space$(5-len(coninp$)) +"h"                    ' variable Leerzeichen vor h für hexadezimalen Wert 
  settext RAM%,conrow%,3,coninp$+sp_h$+gettext$(conhex%) ' Wert im RAM darstellen
  comment$[conrow%]  = ";"+concomm$                      ' Konstanten-Kommentar in Kommentarfeld speichern
endproc
'{--- Hilfsprozeduren Programmlauf ---
proc ram_adr_cykl                     ' RAM-Bereichsüberschreitung abfangen, Adresse zyklisch im RAM
    case (row% > 255) : row% = row% - 256    
    case (row% <   0) : row% = row% + 256    
endproc    
proc set_IC                           ' Instruction Counter/ Befehlszähler setzen (zyklisch)
  ' Sprungfehler/RAM-Bereichsüberschreitung abfangen:
  case (ic_dez% > 255) : ic_dez% = ic_dez% - 256  ' Programmausführung zyklisch im RAM
  case (ic_dez% <   0) : ic_dez% = ic_dez% + 256  ' Programmausführung zyklisch im RAM                  ' 
  settext IC%, d255_to_bin8(ic_dez%)              ' Befehlszähler setzen
endproc
proc show_set_IC                      ' anzeigen: IC manuelle Eingabe 
  textcolor black% , chipc%   
  drawtext 540,386,"setzen" 
  show(set_IC%)
  drawtext 581,402,"hex"
endproc
proc hide_set_IC                      ' verbergen: IC manuelle Eingabe 
  textcolor black% , chipc%      
  drawtext 540,386,"            " 
  hide(set_IC%)
  drawtext 581,402,"      "
endproc
proc set_D1                           ' Eintrag in D1 bei Speicher/Kopierbefehlen sichtbar machen (clock)
  parameters bytewert$
    settext R%[1], bytewert$                                                ' in D1 ablegen 
  '.............................. Darstellung ................. 
    if fullspeed% = 0                                
      ms% = 10000 \(2*10*takt!)    ' 2- fach Zwischentakt in Millisekunden zur Darstellung in D1 
      settimer ms% 
      timeover% = 0
      repeat
         case  %wmTimer   : timeover% = 1
      until timeover% 
      set_clock            ' CPU Zeit setzen
    endif ' ...................................................
endproc
proc push_b_res                       ' Resultat-Byte auf Stack legen
  temp%  = bin8_to_dez(b_res$)
  settext RAM%, starow% , 2, b_res$                                         '  binär
  sp_h$ = space$(5-len(str$(temp%))) +"h"  ' variable Leerzeichen vor h für hexadezimalen Wert 
  settext RAM%, starow% , 3, str$(temp%) + sp_h$ + bin8_to_hex2(b_res$)     '  dezimal  hexadezimal
endproc
proc shift_ALRx                       ' ALU-Multiplikation nach Booth: ALR_ARL_ALx >> um 1 Bit verschieben
  settext booth%, str$(&loop)+chr$(187)+" Booth"
  settext ALx%  , right$(gettext$(ARL%),1)
  settext ARL% , right$(gettext$(ALR%),1) + left$(gettext$(ARL%),7)
  settext ALR%  , chr$(187)+mid$(gettext$(ALR%),2,1) + mid$(gettext$(ALR%),2,7)   ' >> um 1 Bit verschieben
endproc 
proc ALU_bitstep                      ' Zwischenschritt (Takt) ALU bitweise
  if fullspeed% = 0 
    if  getcheck(alu_bitw%) 
      bit_pulse(2)
    endif
  endif  
endproc 
proc ALU_step                         ' Zwischenschritt (Takt) ALU
  case fullspeed% = 0 : clock_pulse(2)
endproc 
'}
'{--- Micro Graphic Adapter (MGA) ----

proc mga_display                      ' Micro-Graphic-Adapter: Display aus RAM darstellen
  declare x%, y%, i%, j%
  x% = Mx%-Md%\2
  y% = My%-Md%\2
  i% = 1
  repeat
    mga$[i%] = gettext$(RAM%, 247 + i% , 2)
    j% = 1
    repeat
      if mid$(mga$[i%], j%, 1) = "0"
        usebrush 1, white%
      else
        usebrush 1, black%
      endif
      fill x% + j%*Md% ,  y% + i%*Md% , grey%   ' Maxipixel mit weiß/schwarz füllen 
      inc j%
    until j% = 9 
    inc i%
  until i% = 9
endproc
proc click_mga                        ' Klick im MGA Display
  var btmp1$ = ""
  var btmp2$ = ""
  var tmp% = 0
 ' Pixeladresse und Status in RAM-Byte 247 = hF7 eintragen (BEACHTE! -1  ->  als Werte 0 bis 7 ablegen)
  mgarow$ = gettext$(RAM%, 247 + ip% , 2) '  ' MGA-Zeile aus RAM holen ...
  pix$  = mid$(mgarow$,jp%,1)             ' ... darin Pixel in Spalte jp (1 bis 8)
  btmp1$ = pix$ +  dez_to_bin3(ip%-1) + mk$  +  dez_to_bin3(jp%-1) ' MGA Adress/Pixelzeile generieren ...
  settext RAM%, 247, 2, btmp1$ '                                   ' ... im RAM (Adr hF7) binär eintragen
  tmp% = bin8_to_dez(btmp1$)
  btmp2$ = str$(tmp%) 
  sp_h$ = space$(5-len(btmp2$ )) +"h"                           ' variable Leerzeichen vor h für hexadezimalen Wert 
  settext RAM%, 247, 3, btmp2$ + sp_h$ + bin8_to_hex2(btmp1$)  ' Wert dezimal, hexadezimal eintragen 
endproc 
proc refresh_mga                      ' MGA-Display nach Änderung aktualisieren
  var btmp1$ = ""
  var btmp2$ = ""
  var tmp% = 0
  if mgapix$ <> left$(gettext$(RAM%, 247,2) ,4)+"m"+right$(gettext$(RAM%, 247,2), 3)
   ' Pixel-Adresszeile in RAM-Byte 247 = hF7 hat sich (ohne Maus!) verändert
    mgapix$ = gettext$(RAM%, 247,2)   ' neu übernehmen
    ip%     = val("%"+ mid$(mgapix$,2,3)) + 1    ' Zeile  (Nr. 1 bis 8)
    jp%     = val("%"+ mid$(mgapix$,6,3)) + 1    ' Spalte (Nr. 1 bis 8)
    pix$    = left$(mgapix$, 1, 1)               ' 
    mgarow$   = gettext$(RAM%, 247 + ip% , 2)      ' MGA-Zeile aus RAM holen
    mgarow$   = left$(mgarow$,jp%-1) + pix$ + right$(mgarow$,8-jp%) ' neue MGA-Zeile generieren  ... 
    settext RAM%, 247 + ip%, 2, mgarow$                         ' ... im RAM binär eintragen  
    tmp% = bin8_to_dez(mgarow$)
    btmp1$ = str$(tmp%) 
    sp_h$ = space$(5-len(btmp1$ )) +"h"                      ' variable Leerzeichen vor h für hexadezimalen Wert 
    settext RAM%, 247 + ip%, 3, btmp1$ + sp_h$ + bin8_to_hex2(mgarow$) ' Wert dezimal, hexadezimal eintragen 
  endif
  whileloop 1, 8                        
    if mga$[ &loop] <> gettext$(RAM%, 247 + &loop , 2) ' bei Änderung einer Displayzeile
      mga_display      ' Micro-Graphic-Adapter: gesamtes Display aus RAM darstellen ...
      break            ' ... dann abbrechen
    endif 
  endwhile
endproc 
'}
proc run_binary_code           ' Programmlauf des Maschinenprogramms (8 Bit Binärcode)
' --- Initialisierung Programmlauf ---
  debugfile$ = gettext$(debugfn%)           ' Debug Dateiname
  if len(debugfn%) = 0
    debugfile$ = savefile$("Debug speichern","HC680 Debug  (*.txt)| *.txt")
  endif  
  assign #8,debugfile$
  rewrite #8                                ' eventuell vorhandene Datei überschreiben
  debug$ = "IC; Bin.Code; Assembler    ; SR/Flags; D0;SD0; D1;SD1; A0;SA0; A1;SA1; SP;[SP; Ta; Pix"
  print #8,debug$                           ' Kopfzeile immer schreiben
  '
  hide_assembler_controls                   ' Assembler-Controls verbergen  
  '
  hide(clrio%)                              ' Button IO-Protokoll löschen verbergen
  'hide(shio%)                               ' Checkbox IO-Protokoll  - verbergen 
  hide(shcache%)                            ' Checkbox CACHE  - verbergen 
  hide(xram%)                               ' Löschbutton RAM verbergen
  hide(xflag%) 
  '
  if htt%
    settext toolRAM%, %hwnd, RAM%, ""       ' Tooltip für RAM leeren (störend beim Programmlauf)
  endif
  show(CACHE%)                              ' CACHE anzeigen
  show(inp%)                                ' Tastatureingabe anzeigen
  textcolor darkred%, backgrdc%             ' dunkelrote Schrift
  drawtext 390,100, "  anhalten      "
  usebrush 1,grey%                          ' Run-Knopf grau
  fill 415,85,black%
  halt%     = 0                             ' Programm anhalten durch Bediener:  1
  stop%     = 0                             ' nach STP-Befehl: 1
  break%    = 0                             ' Bedienerabbruch mit X STOP:  1
  break123% = 0                             ' nach einem der drei Breakpoints: 1
  onestep%  = 0                             ' ersteinmal keinen Schritt weiter bei Einzelschritt                   
  whileloop 0,3   
    settext R%[&loop],"00000000"            '  D, A-Register mit 0 initialisieren
    settext S%[&loop],"00000000"            ' SD,SA-Register mit 0 initialisieren
  endwhile  
  settext IR%, "00000000"                   ' No Operation im IR
  hide_set_IC                               ' setze IC  mit Text verbergen
  ' --- IC wird vorab (in der Ereignisschleife) gesetzt ---
  ic_dez% = val("%"+gettext$(IC%))          ' dezimale Start-Adresse (Binärcode) im RAM aus IC bestimmen
  settext SP%,"11110101"                    ' Stackpointer setzen: Adr. 245 = hF5 ...
  starow% = 245                             ' ... und dezimal in Hintergrundvariable des SP
  settext RAM%, 245,4,"<-SP"                ' ... und Markierung im RAM
  settext SR%, "00000000"                   ' Statusregister beide Nibble auf 0
  flags_0_0_0_0    ' alle Einzelflags Null  ' N-Flag (negativ),
  '                                         ' Z-Flag (zero/ Null)
  '                                         ' V-Flag (overflow/ Überlauf) 
  '                                         ' C-Flag (carry)
 '------------
  repeat ' ---  8 Bit-Maschinenbefehle aus RAM decodieren und ausführen  ---
    ' ---  Befehlsausführung vorbereiten  ---
    ' Takt mit Faktor 1, Ereignisabfrage für Halt/Weiter/Einzelschritt/ Breakpoints/ Debug/ MGA-Display
    clock_pulse(1)  ' auch bei fullspeed = 1  wichtig um Takt zu verringern  
    if break% = 1 
      break
    endif 
    ' ------------
    ic_dez% = val("%"+gettext$(IC%))        ' dezimale Adresse des Befehls im RAM aus IC bestimmen
    ic_dez_fl% = ic_dez%                    ' Adresse für Eintrag der vom Befehl gesetzten Flags merken
    settext set_IC%, bin8_to_hex2(gettext$(IC%))  ' aktueller IC hexadezimal im Edit-Control
    selectstring(RAM%, -1, gettext$(IC%))   ' aktuelle Befehlszeile im RAM markieren
    '-------------
     if getcheck(debug%)    ' ' in debug-Datei schreiben
      debug$ = gettext$(RAM%,ic_dez%,1)+"; " + gettext$(RAM%,ic_dez%,2)+"; "                     ' Adresse (IC)  hex; ' Binärcode                                          
      debug$ = debug$ + gettext$(RAM%,ic_dez%,3)+ space$(13-len(gettext$(RAM%,ic_dez%,3)))+"; "  ' Assembler  
      debug$ = debug$ + gettext$(SR%)+ "; "                                                      ' Statusregister (Flags)
      '
      debug$ = debug$ + bin8_to_hex2(gettext$(R%[0]))+"; "+ bin8_to_hex2(gettext$(S%[0]))+"; "   ' Register und Schattenregister
      debug$ = debug$ + bin8_to_hex2(gettext$(R%[1]))+"; "+ bin8_to_hex2(gettext$(S%[1]))+"; "
      debug$ = debug$ + bin8_to_hex2(gettext$(R%[2]))+"; "+ bin8_to_hex2(gettext$(S%[2]))+"; " 
      debug$ = debug$ + bin8_to_hex2(gettext$(R%[3]))+"; "+ bin8_to_hex2(gettext$(S%[3]))+"; "
      '
      debug$ = debug$ + bin8_to_hex2(gettext$(SP%))+ "; " + bin8_to_hex2(gettext$(RAM%,val("%"+gettext$(SP%)),2))+"; " ' Stackpointer und Inhalt
      debug$ = debug$ + bin8_to_hex2(gettext$(RAM%,246,2))+"; "+ gettext$(RAM%,247 ,2)            ' Tastaturbyte hex; MGA-Pixel binär      
      print #8,debug$
    endif
    ' ------------
    if comment$[ic_dez%] = ";"              ' wenn kein Befehlskommentar vorhanden 
      settext opcomm%, "; "                 ' nur Kommentarzeichen mit Lerzeichen anzeigen
    else                                    '  sonst
      settext opcomm%, mid$(comment$[ic_dez%],2,254)          ' aktuellen Befehlkommentar ohne ; eintragen 
    endif
    settext toolopcomm%, %hwnd, opcomm%, comment$[ic_dez%]    ' Tooltip aktuell zu Kommentar (volle Länge lesbar!)
    ' -----------
    IO_SR$ = left$(gettext$(SR%),2)         ' Art Daten IO, linke zwei Bit in Status Register
    N$     = mid$(gettext$(SR%),5,1)        ' Flags aus dem Status Register auslesen
    Z$     = mid$(gettext$(SR%),6,1)  
    V$     = mid$(gettext$(SR%),7,1)  
    C$     = mid$(gettext$(SR%),8,1) 
    ' ------------
    oc$ = gettext$(RAM%,ic_dez%,2)          ' 8 Bit-Befehl (Operationscode/Maschinenbefehl mit Operanden) auslesen ...
    whileloop 0,15                          '  ... 16 umgebende Befehle in de Cache übertragen
      settext CACHE%,&loop ,1,gettext$(RAM%,ic_dez% + &loop - 7 ,2)               
    endwhile
    settext CACHE%,7,0,">"                  ' aktuellen Befehl markieren:  >
    settext IR%, oc$                        ' Opcode/Maschinenbefehl/Instruction in das Instruction Register eintragen  
    ' --------------
    ' Operationscode gliedern:
    ocg$   =  left$(oc$,3)                  ' Opcode Bit 1|2|3 (Code-Gruppe)
    ocb$   =   mid$(oc$,4,1)                ' Opcode Bit 4    (Adressierungsart/ Befehlsvarianten)
    ocyy$  =   mid$(oc$,5,2)                ' Opcode Bit 5|6  (teils Ziel-Register)
    ocxx$  = right$(oc$,2)                  ' Opcode Bit 7|8  (teils Quell-Register)
    ry%    = val("%"+ocyy$)                 ' yy dezimal      (z.T. Index des Registerfeldes)  
    rx%    = val("%"+ocxx$)                 ' xx dezimal      (z.T. Index des Registerfeldes)
    ' ---  Opcode analysieren --- Befehl decodieren/ausführen  ---
    select ocg$        ' 3-stellige Gruppen               
      caseof "000"                     
        select ocb$    ' Bit
          caseof    "0" ' = ocb$         ' Code rechte 4 Bit fest - ohne Operand/Registerangabe
            ocyyxx$ = ocyy$+" "+ocxx$    '       Leerzeichen zur Gruppierung - bessere Übersicht
            select ocyyxx$ 
                                         '         ocg b yy xx   <-- Gruppierung Operationscode/ 8 Bit Maschinenbefehl
                                         '         --- - -- --   '   _XXX  Befehlsausführung Maschinenbefehl in Befehlsprozedur  
              caseof "00 00"                    
                _NOP              ' NOP          ' 000 0 00 00	   No OPeration          
              caseof "00 01"                                                               
                _CMP              ' CMP          ' 000 0 00 01	   CoMPare D0, D1 (D0-D1)
              caseof "00 10"                   
                _SWD              ' SWD          ' 000 0 00 10	   SWap D0, D1
              caseof "00 11"               
                _SWM              ' SWM          ' 000 0 00 11	   SWap Memory Adr(D0), Adr(D1)
              caseof "01 00"                    
                _MUL              ' MUL          ' 000 0 01 00	   MULtiplication D0 <- D0*D1
              caseof "01 01"                     
                _DIV              ' DIV          ' 000 0 01 01	   DIVision D0 <- D0\D1	ganzzahlig
              caseof "01 10"                     
                _PSA              ' PSA          ' 000 0 01 10	   PuSh All Stack <- A,D,SR Reg.	
              caseof "01 11"                     
                _POA              ' POA          ' 000 0 01 11	   POp All SR,D,A  Reg. <- Stack
              caseof "10 00"                
                _JSR              ' JSR          ' 000 0 10 00	   Jump SubRoutine Stack<-IC+1, A0=0: IC<-IC+A1 sonst IC<-A0+A1+ST
                                       ' ACHTUNG!        Reihenfolge des Opcode beachten! 
              caseof "11 00"      ' RET          ' 000 0 11 00  	 RETturn subroutine IC <-Stack                     
                _RET                            
              caseof "10 01" , "11 01"           
                _JIN              ' JIN +A   	   ' 000 0 10 01	   N=1: IC <- IC + A1	      Jump If Negative    
                                  ' JIN IA	     ' 000 0 11 01     N=1: IC <- A0 + A1 + ST  Jump If Negative
              caseof "10 10" , "11 10"            
                _JIZ              ' JIZ +A       ' 000 0 10 10     Z=1: IC <- IC + A1	      Jump If Zero
                                  ' JIZ IA       ' 000 0 11 10     Z=1: IC <- A0 + A1	+ ST  Jump If Zero
              caseof "10 11" , "11 11"                                       
                _JMP              ' JMP +A       ' 000 0 10 11	        IC <- IC + A1	      JuMP
                                  ' JMP IA       ' 000 0 11 11	        IC <- A0 + A1	+ ST  JuMP  
            endselect ' ocyyxx$            
          caseof    "1"   ' = ocb$                        ' Code rechte 2 Bit Operand Register xx 
          
            if  ocyy$ = "00"                                        
              _LDC                ' LDC RG       ' 000 1 00 xx     LoaD Constant Register   Reg xx <- next Byte ##        
            else ' ocyy$ 
              _JIN_JIZ_JUMP_Reg   ' JIN RG 	     ' 000 1 01 xx 	   N=1: IC <- Reg xx	  Jump If Negative
                                  ' JIZ RG	     ' 000 1 10 xx  	 Z=1: IC <- Reg xx	  Jump If Zero
                                  ' JMP RG 	     ' 000 1 11 xx          IC <- Reg xx	  JuMP
            endif
        endselect ' ocb$
      caseof "001"   
        select ocb$
          caseof "0"
            select ocyy$                   
              caseof "00"    
                _INP               ' INP RG      ' 001 0 00 xx     Reg xx      <- INPut
              caseof "01"                       
                _OUT               ' OUT RG      ' 001 0 01 xx     OUTput      <- Reg xx
              caseof "10"                    
                _PSH               ' PSH RG	     ' 001 0 10 xx     PuSH  Stack <- Reg xx 
              caseof "11"                      
                _POP               ' POP RG	     ' 001 0 11 xx     POP  Reg xx <- Stack  
            endselect ' ocyy$ 
          caseof "1"
            select ocyy$                   
              caseof "00" 
                _SSR               ' SSR RG      ' 001 1 00 xx    Set Shadow Register  Reg xx -> Sxx  (SDx, SAx)
              caseof "01"   
                _GSR               ' GSR RG      ' 001 1 01 xx    Get Shadow Register  Reg xx <- Sxx  (SDx, SAx)
              caseof "10"
                _BTS               ' BTS RG      ' 001 1 10 xx    BitTest Reg xx with Shadowregister
              caseof "11"
                _SWN               ' SWN RG      ' 001 1 11 xx    SWap Nibble  Reg xx
            endselect ' ocyy$     
        endselect  'ocb$ 
      caseof "010"
        select ocb$
          caseof "0"
            select ocyy$
              caseof "00"                         
                _SHL              ' SHL RG	     ' 010 0 00 xx   SHift Left   Reg xx
              caseof "01"                         
                _SHR              ' SHR RG	     ' 010 0 01 xx   SHift Right  Reg xx
              caseof "10"                         
                _ROL              ' ROL RG       ' 010 0 10 xx   ROtate Left  Reg xx
              caseof "11"                         
                _ROR              ' ROR RG	     ' 010 0 11 xx   ROtate Right Reg xx
            endselect ' ocyy$ 
          caseof "1"
            select ocyy$
              caseof "00"                         
                _CLR              ' CLR RG	     ' 010 1 00 xx   CLear Register Reg xx <- 0
              caseof "01" , "10"                  
                _INC_DEC          ' INC RG	     ' 010 1 01 xx   INCrement Reg xx  
                                  ' DEC RG	     ' 010 1 10 xx   DECrement Reg xx   
              caseof "11"                         
                _NOT              ' NOT RG	     ' 010 1 11 xx   Reg xx <- NOT Reg xx (bitweise)
            endselect ' ocyy$
        endselect ' ocb$
      caseof "011"   
        if ocyy$ = ocxx$
          _MOV_SRSP               ' MOV RG  SR   ' 011 0 yy yy   MOVe      Reg yy <-  SR    *1) xx=yy
                                  ' MOV RG  SP   ' 011 1 yy yy   MOVe      Reg yy <-  SP    *2) xx=yy
        else
          _AND_OR                 ' AND RG  RG	 ' 011 0 yy xx   Reg yy <- Reg yy AND Reg xx,  xx<>yy
                                  ' OR  RG  RG	 ' 011 1 yy xx   Reg yy <- Reg yy OR  Reg xx,  xx<>yy
        endif                          
      caseof "100"  
        if ocyy$ = ocxx$
          _MOV_SRSP               ' MOV SR  RG 	 ' 100 0 xx xx	 MOVe      SR <- Reg xx     *3) xx=yy
        else
          _ADD                    ' ADD RG  RG	 ' 100 0 yy xx   Reg yy <- Reg yy + Reg xx,    xx<>yy
                                  ' ADD RG  [RG] ' 100 1 yy xx   Reg yy <- Reg yy + Adr(Reg xx)
        endif                          
      caseof "101"
        if ocyy$ = ocxx$
          _MOV_SRSP               ' MOV SP  RG 	 ' 101 0 xx xx   MOVe      SP <- Reg xx     *4) xx=yy 
        else  
          _SUB                    ' SUB RG  RG	 ' 101 0 yy xx   Reg yy <- Reg yy - Reg xx,    xx<>yy
                                  ' SUB RG  [RG] ' 101 1 yy xx   Reg yy <- Reg yy - Adr(Reg xx)
        endif                          
      caseof "110"     
        _MOV_RAM                  ' MOV [RG] RG	 ' 110 0 yy xx   MOVe Adr(Reg yy) <- Reg xx, 
                                  ' MOV RG  [RG] ' 110 1 yy xx   MOVe     Reg yy  <- Adr(Reg xx)
      caseof "111"              
        if ocb$ = "0" 
          if ocyy$ = ocxx$
            _MOV_SRCC
                                   ' MOV SR  CC	 ' 111 0 CC CC	 MOVe      SR <- CC..       *5) xx=yy 2Bit IO        
          else
            _MOV_REG               ' MOV RG  RG  ' 111 0 yy xx   MOVe     Reg yy  <- Reg xx,    xx<>yy 
          endif
        endif ' ocb$ = "0"     
        if ocb$ = "1"     
          select ocyy$
            caseof "00" , "01"                            
              _MOV_IA              ' MOV RG  IA  ' 111 1 00 xx   MOVe     Reg xx   <- Adr(A0+A1+ST)
                                   ' MOV IA  RG  ' 111 1 01 xx   MOVe Adr(A0+A1+ST)<- Reg xx  
            caseof "10"                                
              _LOD                 ' LOD RG	     ' 111 1 10 xx   LOad Data Reg xx  <- Adr(h80+A1+ST)
            caseof "11"      ' Code rechte 2 Bit fest: 4 Einzelbefehle (ohne Registerangabe)
              select ocxx$
                caseof "00"                       
                  _STO	           ' STO (IO)    ' 111 1 11 00   STOre   Datei <- Adr(h80+A1+ST) D0 Byte, über D1 (Art: IO) 
                caseof "01"       
                  _RCL             ' RCL (IO)    ' 111 1 11 01   ReCalL  Adr(h80+A1+ST) <- Datei   über D1 (Art: IO)  /D0 Byte gelesen
                caseof "10"                      
                  _CPY	           ' CPY	       ' 111 1 11 10   CoPY Adr(A1)<-Adr(A0)    D0 Byte über D1
                caseof "11"                         
                  _STP             ' STP         ' 111 1 11 11   StoP   Programm anhalten
              endselect ' ocxx$
          endselect ' ocyy$
        endif ' ocb$ = "1"         
      otherwise ' ocg$             ' Fehler/ kein Befehl
        stop% = 1                          ' Programm abbrechen
        usebrush 1,red%            ' Run-Knopf rot
        fill 415,85,black%
        messagebox("Kein gültiger Befehl","Fehler",48)
        inc ic_dez%
    endselect ' ocg$
    flags_latest                 ' zuletzt gesetzte Flags nach Befehlsausführung hinter Assembler anzeigen
    register_tooltip             ' Tooltips mit dezimalen und hexadezimalen Inhalten der Register aktualisieren  
  until 0                        ' Abbruch mit [X] STOP:  break% = 1 --> break    
  ' ----------  Finalisierung Programmlauf   -------------------------------------------------------
  whileloop 0,3   
    settext R%[&loop],"00000000"            ' D,A-Register mit 0 initialisieren
    settext S%[&loop],"00000000"            ' SD,SA-Register mit 0 initialisieren
  endwhile  
  settext IR%, "00000000"                   ' No Operation im Instruction Register
        ' IC  -->    wird in Ereignisschleife gesetzt                               
  settext opcomm%, mid$(comment$[0],2,254)  ' Kommentar für oberste Programmzeile eintragen
  settext SR%, "00000000"                   ' Statusregister beide Nibble auf 0
  flags_0_0_0_0    ' alle Einzelflags Null  ' N-Flag (negativ),
  settext RAM%, starow%, 4,"    "           ' Stackpointer aktuelle  Markierung löschen
  settext SP%,"11110101"                    ' Stackpointer auf Basisadresse setzen: Adr. 245 = hF5 ...
  starow% = 245                             ' ... und dezimal in Hintergrundvariable des SP
  settext RAM%, 245,4,"<-SP"                ' ... und neue Markierung im RAM
  register_tooltip                          ' Tooltips der Register aktualisieren 
  if htt%
    settext toolRAM%, %hwnd, RAM%, toolRAM$   ' Tooltip für RAM wieder füllen
    settext toolSRval%, %hwnd, SRval%, SRhlp$ ' Tooltip für Status Register zurücksetzen
  endif  
  'setcheck shio%, 1                         ' Status:  IO-Protokoll sichtbar
  show(xram%)                               ' Löschbutton RAM wieder anzeigen
  show(xflag%)                              ' Löschbutton Flags wieder anzeigen
  show(clrio%)                              ' Button IO-Protokoll löschen anzeigen
  'show(shio%)                               ' Checkbox IO-Protokoll  - anzeigen
  show(shcache%)                            ' Checkbox CACHE  - anzeigen
  '
  hide(inp%)                                ' Tastatureingabe ausblenden
  ' nach fullspeed > 255HZ wieder einblenden
  show(AL1%)                                ' ALU einblenden
  show(AL2%)
  show(ALC%)
  show(ALR%)
  show(alu_bitw%)                           ' ALU bitweise anzeigen 
  show(breakpt1%)                           ' Breakpoints anzeigen                         
  show(breakpt2%) 
  show(breakpt3%) 
  show(debug%)                              ' Debug einblenden
  show(debugfn%)                            ' Dateiname Debug anzeigen 
  show(CACHE%)                              ' CACHE anzeigen
  show_assembler_controls                   ' Assembler-Controls anzeigen
  usebrush 1,richgreen%                     ' Run-Knopf sattgrün
  fill 415,85,black%
  textcolor black%,backgrdc%
  drawtext 390,100, "  ausführen        "
  hide(nextstep%)                           ' verbergen nach STOP bei Einzelschritt 
  close #8                                  ' Debug-Datei schließen
endproc
'{*** Ausführung HC680-Binärcode - Maschinenbefehle ***
 '
         ' Mnem Op1 Op2    Maschinenbef. Wirkung/Bedeutung
         '                   ocg b yy xx
           '                 --- - -- --
proc _NOP  ' NOP           ' 000 0 00 00	 No OPeration
  flags_0_0_0_0 
  inc ic_dez%                                  
  set_IC                                      ' nur einen Befehl weiter
endproc  
proc _CMP  ' CMP           ' 000 0 00 01	 CoMPare D0, D1 (D0-D1)
  settext AL1%, gettext$(R%[1])                ' D1 in ALU setzen
  complement1_ALU                              ' Einerkomplement von AL1 bilden
  settext AL1%, "00000001"                     ' 1 zur Addition in 1. Operanden
  settext AL2%,  b_res$                        ' Ergebnis in 2. Operanden setzen
  add_ALU_9                                    ' Zweierkomplement durch Addition bilden
  settext AL1%, gettext$(R%[0])                ' D0
  settext AL2%, b_res$                         '    -D1  für Vergleich (unterer Wert in der ALU wird abgezogen)                        
  add_ALU_9                                    ' Vergleich D0+(-D1) in der ALU ausführen (mit Flags)
  inc ic_dez%                                  ' Ergebnis der Subtraktion wird verworfen - nur Flags
  set_IC
endproc                            	
proc _SWD  ' SWD           ' 000 0 00 10	 SWap D0, D1
  b_res$ = gettext$(R%[0])
  settext R%[0], gettext$(R%[1])
  settext R%[1], b_res$
  flags_0_0_0_0 
  inc ic_dez%                       
  set_IC                          
endproc
proc _SWM  ' SWM           ' 000 0 00 11	 SWap Memory Adr(D0), Adr(D1)
  row%    = val("%"+gettext$(R%[0]))  
  temp%   = val("%"+gettext$(R%[1])) 
  btemp1$ = gettext$(RAM%, row%  ,2)
  btemp2$ = gettext$(RAM%, temp% ,2)
  settext RAM%, row%,  2, btemp2$      ' binär  eintragen
  sp_h$ = space$(5-len(str$(bin8_to_dez(btemp2$ )))) +"h"     ' variable Leerzeichen vor h für hexadezimalen Wert  
  settext RAM%, row%, 3, str$(bin8_to_dez(btemp2$ )) + sp_h$ + bin8_to_hex2(btemp2$  )    ' dez. hex eintragen      
  settext RAM%, temp%, 2, btemp1$      ' binär  eintragen
  sp_h$ = space$(5-len(str$(bin8_to_dez(btemp1$)))) +"h"     ' variable Leerzeichen vor h für hexadezimalen Wert  
  settext RAM%, temp%, 3, str$(bin8_to_dez(btemp1$)) + sp_h$ + bin8_to_hex2(btemp1$ )    ' dez. hex eintragen        
  flags_0_0_0_0 
  inc ic_dez%                       
  set_IC                          
endproc
proc _MUL  ' MUL           ' 000 0 01 00	 MULtiplication D0 <- D0*D1
  var tmp% = 0      ' lokal
  tmp%   = bin8_to_dez(gettext$(R%[0]) )*bin8_to_dez(gettext$(R%[1])) ' dezimales Ergebnis der Mutiplikation
  '
  if fullspeed% = 0   
    mul_Booth_ALU                     ' --- Booth Algorithmus in der ALU darstellen  (ohne Flags)
  endif   
  '
  if (tmp% > -129) and (tmp% < 128) ' Ergebnis im Bereich
    b_res$  = dez_to_bin8(tmp%)
    flags_b_res_N_Z_0_0
  else 
    b_res$ = right$(bin$(tmp%), 8)   ' entspricht niederwertiges Byte ALM  von ALR,ARL
    N$ =  "0"
    Z$ =  "0"
    V$ =  "1"                        ' oVerflow -Flag setzen 
    if tmp% > 255                   ' Übertrag, wenn man von vorzeichenlosen Operanden ausgeht
      C$ = "1"  
    else
      C$ = "0"  
    endif
    settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$    ' Statusregister mit Flags setzen
  endif 
  '
  settext R%[0], b_res$               ' Resultat in D0 eintragen 
  inc ic_dez% 
  set_IC
endproc
proc _DIV  ' DIV           ' 000 0 01 01	 DIVision D0 <- D0\D1	Rest SD0
  if val("%"+gettext$(R%[1])) = 0     ' Division durch 0 abfangen
    ' D0, SD0 bleiben unverändert
    N$="0"
    Z$="0"
    V$="1"                            ' oVerflow-Flag setzen  
    C$="0"                           
    settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$    ' Statusregister mit Flags setzen 
    messagebox("Der Befehl wurde nicht ausgeführt, \nDas V-Flag wird gesetzt."," --- Division durch 0 --- ",48)  
  else 
    if fullspeed% = 0
        div_ALU                       ' binäre Division in der ALU demonstrieren,  ergibt D0 und Rest in SD0
        '                             ' Flags  werden in div_ALU gesetzt
    else // schnelle Berechnung (aber -128 angleichen)
      if (val("%"+gettext$(R%[0])) = -128) or (val("%"+gettext$(R%[1])) = -128) ' OVERFLOW +128 bei Zweierkomplement in ALU! 
        ' D0, SD0 bleiben unverändert
        N$="0"
        Z$="0"
        V$="1"                        ' oVerflow-Flag setzen  
        C$="0"                            
        settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$    ' Statusregister mit Flags setzen 
      else
        ' dezimaler Rest ->  in Schattenregister SD0 eintragen    
        settext S%[0], dez_to_bin8( bin8_to_dez(gettext$(R%[0])) MOD bin8_to_dez(gettext$(R%[1])) ) 
        ' 
        ' dezimaler Quotient  -> in b_res$ für Flags und in D0 eintragen    
        b_res$    =    dez_to_bin8( bin8_to_dez(gettext$(R%[0])) \ bin8_to_dez(gettext$(R%[1])) ) 
        settext R%[0], b_res$ 
        flags_b_res_N_Z_0_0
      endif  
    endif
    '
  endif
  inc ic_dez%
  set_IC
endproc
proc _PSA  ' PSA           ' 000 0 01 10	 PuSh All Stack <- A,D,SR Reg.
  ' alle vier Adress- und Datenregister und SR auf den Stack legen 
  settext RAM%, starow%, 4,"    "        ' alten Zeiger für Stellung Stackpointer löschen 
  b_res$  = gettext$(R%[3])    
  push_b_res                 ' A1
  dec starow% 
  b_res$  = gettext$(R%[2])    
  push_b_res                 ' A0
  dec starow% 
  b_res$  = gettext$(R%[1])   
  push_b_res                 ' D1
  dec starow% 
  b_res$  = gettext$(R%[0])   
  push_b_res                 ' D0
  dec starow% 
  b_res$  = gettext$(SR%)   
  push_b_res                 ' SR
  dec starow% 
  settext SP%, d255_to_bin8(starow%)     ' aktuelle Adresse in Kellerspeicher eintragen
  settext RAM%, starow%, 4,"<-SP"        ' Zeiger für Stellung Stackpointer setzen 
  flags_0_0_0_0                          ' alle Flags auf Nullsetzen
  inc ic_dez%
  set_IC
endproc
proc _POA  ' POA           ' 000 0 01 11	 POp All SR,D,A Reg. <- Stack                     
  ' SR und alle vier Daten- und Adressregistervom Stack holen
  if starow% < 251                          ' SR und 4 Register ...
    settext RAM%, starow%, 4,"    "         '    alten Zeiger für Stellung Stackpointer löschen
    inc starow%                             ' ... Stapelzeiger jeweils 1 Richtung Ende RAM 
    settext SP%, d255_to_bin8(starow%)      ' SP auf obersten Eintrag im Kellerspeicher setzen
    settext SR%, gettext$(RAM%,starow%,2)   ' SR   
    inc starow%
    settext R%[0], gettext$(RAM%,starow%,2) ' D0   
    inc starow%
    settext R%[1], gettext$(RAM%,starow%,2) ' D1   
    inc starow%
    settext R%[2], gettext$(RAM%,starow%,2) ' A0   
    inc starow%
    settext R%[3], gettext$(RAM%,starow%,2) ' A1   
    settext SP%, d255_to_bin8(starow%)      ' aktuelle Adresse in Kellerspeicher eintragen
    settext RAM%, starow%, 4,"<-SP"         ' Zeiger für Stellung Stackpointer setzen
  else
    messagebox("FEHLER:    RAM-Ende erreicht!"," --- Stack-Fehler ---",48)
    stop% = 1 
  endif  
  ' Flags vom Stack in SR für Darstellung vereinzeln 
   N$ = mid$(gettext$(SR%),5,1)
   Z$ = mid$(gettext$(SR%),6,1)
   V$ = mid$(gettext$(SR%),7,1)
   C$ = mid$(gettext$(SR%),8,1)
  inc ic_dez%
  set_IC
endproc
proc _JSR  ' JSR           ' 000 0 10 00	 Jump SubRoutine Stack<-IC+1, A0=0: IC<-IC+A1 sonst IC<-A0+A1+ST
  temp% = ic_dez%  + 1                ' Rücksprungadresse IC+1                      
  b_res$ = d255_to_bin8(temp%)
  settext RAM%, starow% , 2, b_res$   ' Rücksprungadresse IC+1 auf Stack ' binär    
  sp_h$ = space$(5-len(str$(temp%))) + "h"                               ' variable Leerzeichen vor h für hexadezimalen Wert 
  settext RAM%, starow% , 3, str$(temp%) + sp_h$ + bin8_to_hex2(b_res$)  ' dezimal  hexadezimal
  settext RAM%, starow%, 4,"    "     ' alten Zeiger für Stellung Stackpointer löschen 
  dec starow%                         ' um 1 kleinere Adresse im Kellerspeicher ...
  settext SP%, d255_to_bin8(starow%)  ' ... im Stackpointer eintragen  
  settext RAM%, starow%  , 4,"<-SP"   ' Zeiger für Stellung Stackpointer setzen
  flags_0_0_0_0                       ' alle Flags auf Nullsetzen 
  if gettext$(R%[2])="00000000"                                                         ' A1 vorzeichenbehaftet
    ic_dez% = ic_dez% + bin8_to_dez(gettext$(R%[3]))           ' falls A0 = 0: IC <- IC + A1   Sprung zum Unterprogramm
  else
    ic_dez% = val("%"+gettext$(R%[2])) + bin8_to_dez(gettext$(R%[3])) + sta% ' IC <- A0 + A1 + ST Sprung zum Unterprogramm
  endif
  set_IC                                                             
endproc
proc _RET  ' RET           ' 000 0 11 00   RETturn subroutine      IC <- Stack
  if starow% < 255                      ' noch nicht am Speicherende
    settext RAM%, starow%, 4,"    "     ' alten Zeiger für Stellung Stackpointer löschen
    inc starow%                         ' ... Stapelzeiger jeweils 1 Richtung Ende RAM 
    settext SP%, d255_to_bin8(starow%)  ' SP auf obersten Eintrag im Kellerspeicher
    settext RAM%, starow% , 4,"<-SP"    ' Zeiger für Stellung Stackpointer setzen
    ic_dez% = val("%"+gettext$(RAM%,starow%,2) )  ' dezimale Rücksprungadresse vom Stack ...
    set_IC                                        ' ... in IC setzten 
  else
     messagebox("FEHLER:    RAM-Ende erreicht!"," --- Stack-Fehler ---",48)
    stop% = 1 
  endif  
  flags_0_0_0_0                              ' alle Flags auf Nullsetzen 
endproc
           ' JIN +A        ' 000 0 10 01	 N=1: IC <- IC + A1	      Jump If Negative    
proc _JIN  ' JIN IA	       ' 000 0 11 01   N=1: IC <- A0 + A1 + ST	Jump If Negative
  if N$ = "1"                                ' wenn N-Flag = 1                                           ' A1 vorzeichenbehaftet
    case ocyy$="10": ic_dez% = ic_dez% + bin8_to_dez(gettext$(R%[3]))                         ' IC <- IC + A1 
    case ocyy$="11": ic_dez% = val("%"+gettext$(R%[2])) + bin8_to_dez(gettext$(R%[3])) + sta% ' IC <- A0 + A1 + ST 
  else             
    inc ic_dez%                              ' wenn N-Flag = 0
  endif
  set_IC 
  flags_0_0_0_0                              ' alle Flags auf Nullsetzen          
endproc
           ' JIZ +A        ' 000 0 10 10   Z=1: IC <- IC + A1	      Jump If Zero
proc _JIZ  ' JIZ IA        ' 000 0 11 10   Z=1: IC <- A0 + A1 + ST	Jump If Zero
  if Z$ = "1"                                '  wenn Z-Flag = 1                                         ' A1 vorzeichenbehaftet
    case ocyy$="10": ic_dez% = ic_dez% + bin8_to_dez(gettext$(R%[3]))                        ' IC <- IC + A1 
    case ocyy$="11": ic_dez%= val("%"+gettext$(R%[2])) + bin8_to_dez(gettext$(R%[3])) + sta% ' IC <- A0 + A1 + ST 
  else
    inc ic_dez%                              ' wenn Z-Flag = 0
  endif
  set_IC 
  flags_0_0_0_0                              ' alle Flags auf Nullsetzen
endproc
           ' JMP +A        ' 000 0 10 11	      IC <- IC + A1	      JuMP
proc _JMP  ' JMP IA        ' 000 0 11 11	      IC <- A0 + A1	+ ST  JuMP                                                                                               ' A1 vorzeichenbehaftet
  case ocyy$="10": ic_dez% = ic_dez% + bin8_to_dez(gettext$(R%[3]))                          ' IC <- IC + A1 
  case ocyy$="11": ic_dez%= val("%"+gettext$(R%[2])) + bin8_to_dez(gettext$(R%[3])) + sta%   ' IC <- A0 + A1  + ST
  set_IC   
  flags_0_0_0_0                              ' alle Flags auf Nullsetzen
endproc
proc _LDC  ' LDC RG	       ' 000 1 00 xx   LoaD Constant  Reg xx <- next Byte ##
  inc ic_dez%       ' Zeile mit Konstanten-Byte ## CCCC CCCC  ... weiter ...
  b_res$ = gettext$(RAM%, ic_dez% ,2)
  settext R%[rx%], b_res$
  flags_b_res_N_Z_0_0  
  inc ic_dez%                              ' ...mit übernächster Befehlszeile
  set_IC
endproc
           ' JIN RG 	     ' 000 1 01 xx   N=1: IC <- Reg xx	  Jump If Negative
           ' JIZ RG	       ' 000 1 10 xx   Z=1: IC <- Reg xx	  Jump If Zero                           
           ' JMP RG 	     ' 000 1 11 xx        IC <- Reg xx	  JuMP                            
proc _JIN_JIZ_JUMP_Reg  
  if ((ocyy$="01") and (N$="1")) or ((ocyy$="10") and (Z$="1")) or (ocyy$="11")         ' JUMPs Register   
    ic_dez% = val("%"+gettext$(R%[rx%]))                                                ' IC <- Reg xx  
  else                                                                       ' auch A1 = R[3] Wert vorzeichenlos 
    inc ic_dez%                  
  endif
  set_IC 
  flags_0_0_0_0                             ' alle Flags auf Nullsetzen
endproc                      
proc _INP  ' INP RG (IO)   ' 001 0 00 xx   Reg xx           <- INPut  
  ' --- Eingabesystem (Nutzereingabe beim Programmlauf)
  input_system 
  '-----------------------
  settext R%[rx%], binp$ 
  settext RAM%, 246, 2, binp$                     ' in RAM Adr 246 = hF6   binär eintragen ...
  settext RAM%, 246, 3, chr$(bin8_to_dez(binp$))  + "    h"  + bin8_to_hex2(binp$) ' ... Zeichen und Wert hexadezimal eintragen 
  b_res$ = binp$           ' für Flags
  flags_b_res_N_Z_0_0  
  inc ic_dez%
  set_IC 
endproc
proc _OUT  ' OUT RG (IO)   ' 001 0 01 xx   OUTput           <- Reg xx 
  boutp$ = gettext$(R%[rx%]) 
  ' --- Ausgabesystem (beim Programmlauf)
  output_system   
  ' --------------------
  flags_0_0_0_0            ' alle Flags auf Nullsetzen
  inc ic_dez%
  set_IC 
endproc
proc _PSH  ' PSH RG	       ' 001 0 10 xx   PuSH  Stack      <- Reg xx 
  starow% =  val("%"+gettext$(SP%))  
  settext RAM%, starow% , 4,"    "    ' alten Zeiger für Stellung Stackpointer löschen 
  b_res$ =  gettext$(R%[rx%])
  push_b_res
  dec starow%                                     ' um 1 kleinere Adresse im Kellerspeicher ...
  settext SP%, d255_to_bin8(starow%)              '   ... eintragen
  settext RAM%, val("%"+gettext$(SP%)), 4,"<-SP"  ' Zeiger für Stellung Stackpointer setzen
  flags_b_res_N_Z_0_0                             
  inc ic_dez%
  set_IC 
endproc
proc _POP  ' POP RG	       ' 001 0 11 xx   POP  Reg xx      <- Stack 
  if starow% < 255
    settext RAM%, val("%"+gettext$(SP%)), 4,"    "      ' alten Zeiger für Stellung Stackpointer löschen 
    inc starow%                               ' Stapelzeiger 1 Richtung Ende RAM ...
    settext SP%, d255_to_bin8(starow%)                ' ... eintragen
    settext RAM%, val("%"+gettext$(SP%)), 4,"<-SP"      ' Zeiger für Stellung Stackpointer setzen
    b_res$ = gettext$(RAM%,starow%,2) 
    settext R%[rx%], b_res$     
    flags_b_res_N_Z_0_0
    inc ic_dez%
    set_IC 
  else
     messagebox("FEHLER:    RAM-Ende erreicht!"," --- Stack-Fehler ---",48)
    stop% = 1 
  endif
endproc
proc _SSR  ' SSR RG        ' 001 1 00 xx   Set Shadow Register  Reg xx -> Sxx  (SDx, SAx)
  b_res$ = gettext$(R%[rx%])
  settext S%[rx%], b_res$
  flags_b_res_N_Z_0_0
  inc ic_dez%
  set_IC 
endproc
proc _GSR  ' GSR RG        ' 001 1 01 xx   Get Shadow Register  Reg xx <- Sxx  (SDx, SAx)
   b_res$ =  gettext$(S%[rx%])
  settext R%[rx%] , b_res$                
  flags_b_res_N_Z_0_0
  inc ic_dez%
  set_IC 
endproc
proc _BTS  ' BTS RG        ' 001 1 10 xx   BitTest Reg xx with Shadowregister
  var bit% = 9
  settext AL1%, " " + gettext$(R%[rx%])     ' rechtsbündig in AL1 setzen
  settext AL2%, " " + gettext$(S%[rx%])     ' rechtsbündig in AL2 setzen 
  settext ALC%, "         "                 ' unbenutzt
  R9$ = "         "                         ' 9 Bit Ergebnis leeren ...                             
  settext ALR%, R9$                         ' ... und in die ALU setzen 
  repeat
    ALU_bitstep 
    if mid$(gettext$(AL2%),bit%, 1) = "1"        ' nur wenn Bit im Schattenregister gesetzt prüfen
       if mid$(gettext$(AL1%),bit%, 1)  = "1"    ' Bit aus Register vergleichen 
         r$ = "0"                                ' Übereinstimmung: 0
       else
         r$ = "1"                                ' Abweichung: 1
       endif
    else   
      r$ = "0"                                   ' nicht geprüfte immer: 0                        
    endif 
    R9$ =   space$(bit%-1) + r$  + right$(R9$, 9-bit%)   
    settext ALR%,R9$           
    dec bit%
  until bit% = 1                         ' ohne linkes Bit (8 von 9) 
  b_res$ = right$(gettext$(ALR%), 8)     ' Ergebnis wird verworfen, nur Flags
  flags_b_res_N_Z_0_0                    ' Übereinstimmung - Zero-Flag setzen,  Negative Flag, wenn Vorgabe negativ aber Register positiv
  inc ic_dez%
  set_IC 
endproc
proc _SWN  ' SWN RG        ' 001 1 11 xx   SWap Nibble  Reg xx
  b_res$ = right$(gettext$(R%[rx%]),4) + left$(gettext$(R%[rx%]),4)
  settext R%[rx%] , b_res$ 
  flags_b_res_N_Z_0_0    
  inc ic_dez%
  set_IC 
endproc
proc _SHL  ' SHL RG	       ' 010 0 00 xx   SHift Left   Reg xx
  N$ = mid$(gettext$(R%[rx%]),2,1)                 ' Negativ-Flag (nach Schieben)
  if val("%"+right$(gettext$(R%[rx%]),7))= 0 
    Z$ = "1"                                       ' Zero-Flag
  else
    Z$ = "0"
  endif 
  V$ = "0"                                         ' oVerflow-Flag
  C$ = left$(gettext$(R%[rx%]),1)                  ' Carry-Flag 
  settext AL1%, "         "                        ' unbenutzt
  settext AL2%, "         "                        ' unbenutzt
  settext ALC%, "         "                        ' unbenutzt
  settext ALR%,"0" + gettext$(R%[rx%])             ' in ALU setzen 
  ALU_step 
  settext ALR%, C$ + mid$(gettext$(ALR%),3,7) + "0"     ' links schieben
  settext R%[rx%], right$(gettext$(ALR%),8)  
  settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$                  ' Statusregister mit Flags setzen
  inc ic_dez%
  set_IC 
endproc
proc _SHR  ' SHR RG	       ' 010 0 01 xx   SHift Right  Reg xx
  N$ = "0"                                         ' Negativ-Flag
  if val("%"+left$(gettext$(R%[rx%]),7))= 0 
    Z$ = "1"                                       ' Zero-Flag setzen
  else
    Z$ = "0"       
  endif
  V$ = "0"
  C$ = right$(gettext$(R%[rx%]),1)                 ' Carry-Flag
  settext AL1%, "         "                        ' unbenutzt
  settext AL2%, "         "                        ' unbenutzt
  settext ALC%, "         "                        ' unbenutzt
  settext ALR%, "0" + gettext$(R%[rx%])            ' in ALU setzen  
  ALU_step   
  settext ALR%, C$ + "0"+ mid$(gettext$(ALR%),2,7)       ' rechts schieben
  settext R%[rx%], right$(gettext$(ALR%),8)   
  settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$                  ' Statusregister mit Flags setzen
  inc ic_dez%
  set_IC 
endproc
proc _ROL  ' ROL RG        ' 010 0 10 xx   ROtate Left  Reg xx
  N$ = mid$(gettext$(R%[rx%]),2,1)                 ' Negativ-Flag (nach Rotation) 
  if gettext$(R%[rx%]) = "00000000"
    Z$ = "1"
  else
    Z$ = "0"
  endif
  V$ = "0"
  C$ = left$(gettext$(R%[rx%]),1)                  ' Carry-Flag 
  settext AL1%, "         "                        ' unbenutzt
  settext AL2%, "         "                        ' unbenutzt
  settext ALC%, "         "                        ' unbenutzt
  settext ALR%,"0"+ gettext$(R%[rx%])              ' in ALU setzen 
  ALU_step  
  settext ALR%,C$ + mid$(gettext$(ALR%),3,7) + C$  ' links rotieren  
  settext R%[rx%], right$(gettext$(ALR%),8)   
  settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$                  ' Statusregister mit Flags setzen
  inc ic_dez%
  set_IC 
endproc
proc _ROR  ' ROR RG	       ' 010 0 11 xx   ROtate Right Reg xx
  N$ = right$(gettext$(R%[rx%]),1)                 ' Negativ-Flag (nach Rotation) 
  if gettext$(R%[rx%]) = "00000000"
    Z$ = "1"
  else
    Z$ = "0"
  endif                
  V$ = "0"
  C$ = N$                                          ' Carry-Flag ist gleich Negative-Flag    
  settext AL1%, "         "                        ' unbenutzt
  settext AL2%, "         "                        ' unbenutzt
  settext ALC%, "         "                        ' unbenutzt
  settext ALR%,"0"+ gettext$(R%[rx%])              ' in ALU setzen 
  ALU_step                                                 
  settext ALR%, C$ + C$ + mid$(gettext$(ALR%),2,7) ' rechts rotieren  
  settext R%[rx%], right$(gettext$(ALR%),8) 
  settext SR%, left$(gettext$(SR%),4)+N$+Z$+V$+C$                  ' Statusregister mit Flags setzen
  inc ic_dez%  
  set_IC 
endproc
proc _CLR  ' CLR RG	       ' 010 1 00 xx   CLear Register Reg xx <- 0
  b_res$ = "00000000" 
  settext R%[rx%],b_res$                            ' Clear Register
  flags_b_res_N_Z_0_0   
  inc ic_dez%
  set_IC 
endproc
           ' INC RG	       ' 010 1 01 xx   INCrement Reg xx  
           ' DEC RG	       ' 010 1 10 xx   DECrement Reg xx 
proc _INC_DEC                       
  settext AL1%,gettext$(R%[rx%]) 
  case ocyy$="01" : settext AL2%,"00000001"         ' +1 (INC)
  case ocyy$="10" : settext AL2%,"11111111"         ' -1 (DEC)
  add_ALU_9                                         ' Addition in der ALU (mit Flags)
  settext R%[rx%],right$(gettext$(ALR%), 8)
  inc ic_dez%
  set_IC 
endproc
proc _NOT  ' NOT RG	       ' 010 1 11 xx   Reg xx <- NOT Reg xx (bitweise)
  settext AL1%, gettext$(R%[rx%])                  ' in ALU setzen 
  complement1_ALU                                  ' Einer-Komplement in der ALU bilden
  settext R%[rx%], right$(b_res$,8)                ' Ergebnis eintragen
  flags_b_res_N_Z_0_0  
  inc ic_dez%
  set_IC 
endproc
           ' MOV RG  SR    ' 011 0 yy yy   MOVe   Reg yy <-  SR      *1) xx=yy (Reihenfolge Code beachten!)
           ' MOV RG  SP    ' 011 1 yy yy   MOVe   Reg yy <-  SP      *2) xx=yy
           ' MOV SR  RG 	 ' 100 0 xx xx	 MOVe       SR <- Reg xx   *3) xx=yy 
           ' MOV SP  RG 	 ' 101 0 xx xx   MOVe       SP <- Reg xx   *4) xx=yy 
proc _MOV_SRSP 
  if ocg$="011"
    case ocb$ = "0" :  b_res$ = gettext$(SR%)    ' <- SR
    case ocb$ = "1"   :b_res$ = gettext$(SP%)    ' <- SP
    settext R%[ry%], b_res$ 
  endif  
  if ocg$="100" 
    b_res$ = gettext$(R%[rx%])  
    settext SR%, b_res$                          ' SR <-  
  endif
  if ocg$="101" 
    b_res$ = gettext$(R%[rx%])  
    settext SP%, b_res$                          ' SP <-
  endif 
  flags_b_res_N_Z_0_0
  inc ic_dez%
  set_IC  
endproc
           ' AND RG  RG	   ' 011 0 yy xx   Reg yy <- Reg yy AND Reg xx, xx<>yy 
           ' OR  RG  RG	   ' 011 1 yy xx   Reg yy <- Reg yy OR  Reg xx, xx<>yy 
proc _AND_OR  
  var bit% = 9
  settext AL1%," "+gettext$(R%[rx%])               'rechte 8Bit des 9Bit-Rechenwerks setzen
  settext AL2%," "+gettext$(R%[ry%])
  settext ALC%, "         "                        ' unbenutzt 
  R9$ = "         "                                ' 9 Bit Ergebnis leeren ...                             
  settext ALR%, R9$                                ' ... und in die ALU setzen 
  repeat
    ALU_bitstep 
    b1$ = mid$(gettext$(AL1%),bit%, 1)  ' Bit auslesen
    b2$ = mid$(gettext$(AL2%),bit%, 1)  
    if ocb$ = "0"                           ' AND
      if b1$+b2$="11" 
        r$="1"
      else
        r$="0"
      endif
    endif
    if ocb$ = "1"                           ' OR 
      if b1$+b2$="00" 
        r$="0"
      else
        r$="1"
      endif         
    endif
    R9$ =   space$(bit%-1) + r$  + right$(R9$, 9-bit%)   
    settext ALR%,R9$           
    dec bit%
  until bit% = 1                         ' ohne linkes Bit (8 von 9) 
  b_res$ = right$(gettext$(ALR%), 8)
  settext R%[ry%],b_res$
  flags_b_res_N_Z_0_0 
  inc ic_dez%
  set_IC 
endproc

           ' ADD RG  RG	   ' 100 0 yy xx   Reg yy <- Reg yy + Reg xx,   xx<>yy 
           ' ADD RG  [RG]  ' 100 1 yy xx   Reg yy <- Reg yy + Adr(Reg xx)
proc _ADD                       
  case ocb$ = "0" : settext AL1%,gettext$(R%[rx%])                             ' ADD RG  RG	
                                          ' auch A1 = R[3] Wert vorzeichenlos
  case ocb$ = "1" : settext AL1%,gettext$(RAM%,val("%"+gettext$(R%[rx%])),2)   ' ADD Reg [Reg]   
  settext AL2%,gettext$(R%[ry%]) 
  add_ALU_9                                   ' Addition in der ALU (mit Flags)
  settext R%[ry%],right$(gettext$(ALR%), 8)
  inc ic_dez%
  set_IC 
endproc
           ' SUB RG  RG	   ' 101 0 yy xx   Reg yy <- Reg yy - Reg xx,   xx<>yy 
proc _SUB  ' SUB RG  [RG]  ' 101 1 yy xx   Reg yy <- Reg yy - Adr(Reg xx)
  if ocb$ = "0"                          ' SUB RG  RG	  
    settext AL1%, gettext$(R%[rx%])            'Reg xx in ALU setzen
  endif 
  if ocb$ = "1"                          ' SUB Reg [Reg] 
    settext AL1%, gettext$(RAM%, val("%"+gettext$(R%[rx%])) ,2)      ' auch A1 = R[3] Wert vorzeichenlos
  endif 
  complement1_ALU                              ' Einerkomplement von AL1 bilden
  settext AL1%, "00000001"                     ' 1 zur Addition in 1. Operanden
  settext AL2%,  b_res$                        ' Ergebnis in 2. Operanden setzen
  add_ALU_9                                    ' Zweierkomplement durch Addition bilden
  settext AL1%,gettext$(R%[ry%])               ' y
  settext AL2%, b_res$                         '    -x   (unterer Wert in der ALU wird abgezogen)      
  add_ALU_9                                    ' Addition  y + (-x) in der ALU (mit Flags)
  settext R%[ry%],right$(gettext$(ALR%), 8)
  inc ic_dez%
  set_IC 
endproc
           ' MOV [RG] RG	 ' 110 0 yy xx   MOVe Adr(Reg yy)   <- Reg xx 
           ' MOV RG  [RG]  ' 110 1 yy xx   MOVe     Reg yy    <- Adr(Reg xx)
proc _MOV_RAM                                  
  if ocb$ = "0"                          ' MOV [Reg] <- Reg
    row% = val("%"+gettext$(R%[ry%]))    ' auch A1 = R[3] Wert vorzeichenlos
    b_res$ = gettext$(R%[rx%])  
    settext RAM%, row%, 2, b_res$                                                       ' binär  eintragen
    sp_h$ = space$(5-len(str$(bin8_to_dez(b_res$)))) +"h"     ' variable Leerzeichen vor h für hexadezimalen Wert  
    settext RAM%, row%, 3, str$(bin8_to_dez(b_res$)) + sp_h$ + bin8_to_hex2(b_res$ )    ' dez. hex eintragen  
    flags_b_res_N_Z_0_0
    inc ic_dez%
    set_IC 
  endif
  if ocb$ = "1"                          ' MOV  Reg  <- [Reg]         
    row%=val("%"+gettext$(R%[rx%]))      ' auch A1 = R[3] Wert vorzeichenlos
    b_res$ = gettext$(RAM%, row% ,2)
    settext R%[ry%], b_res$ 
    flags_b_res_N_Z_0_0    
    inc ic_dez%
    set_IC 
  endif
endproc
           ' MOV SR  CC	   ' 111 0 CC CC	 MOVe       SR <- CC..    *5) xx=yy 2Bit IO   
proc _MOV_SRCC
  settext SR% , ocxx$ + right$(gettext$(SR%),6)  ' <- CC.. .... linke zwei Bit (IO) setzen
  flags_0_0_0_0                                  ' alle Flags auf Nullsetzen
  inc ic_dez%
  set_IC 
endproc
           ' MOV RG  RG    ' 111 0 yy xx   MOVe     Reg yy    <- Reg xx, xx<>yy  
proc _MOV_REG            
  b_res$ = gettext$(R%[rx%])  
  settext R%[ry%], b_res$ 
  flags_b_res_N_Z_0_0
  inc ic_dez%
  set_IC 
endproc
           ' MOV RG  IA    ' 111 1 00 xx   MOVe     Reg xx    <- Adr(A0+A1+ST)
           ' MOV IA  RG    ' 111 1 01 xx   MOVe Adr(A0+A1+ST) <- Reg xx  
proc _MOV_IA                                                       
  if ocyy$ = "00"                        ' Reg <- Adr.(A0 + A1 + ST)                       
    row%=val("%"+gettext$(R%[2])) + bin8_to_dez(gettext$(R%[3])) + sta% ' A1 vorzeichenbehaftet
    ram_adr_cykl                          ' RAM-Bereichsüberschreitung abfangen, Adresse zyklisch im RAM
    b_res$ = gettext$(RAM%, row% ,2)  
    settext R%[rx%], b_res$                         ' Zielregister ist hier (wie bei Input) Reg xx 
  endif     
  if ocyy$ = "01"                        ' Adr.(A0 + A1 + ST)  <- Reg   
    row%=val("%"+gettext$(R%[2])) + bin8_to_dez(gettext$(R%[3])) + sta% ' A1 vorzeichenbehaftet
    ram_adr_cykl                         ' RAM-Bereichsüberschreitung abfangen, Adresse zyklisch im RAM
    b_res$ = gettext$(R%[rx%])                                   ' hier: Quellregister Reg xx
    settext RAM%, row%, 2, b_res$                                                       ' binär eintragen
    sp_h$ = space$(5-len(str$(bin8_to_dez(b_res$)))) +"h"     ' variable Leerzeichen vor h für hexadezimalen Wert 
    settext RAM%, row%, 3, str$(bin8_to_dez(b_res$)) + sp_h$ + bin8_to_hex2(b_res$)     ' dez. hex. eintragen 
  endif  
  flags_b_res_N_Z_0_0   
  inc ic_dez%
  set_IC 
endproc
proc _LOD  ' LOD RG	       ' 111 1 10 xx   LOad Data Reg xx   <- Adr(h80+A1+ST)
  ' ab Byte 128 für Daten vorgesehen
  row% =    128 + bin8_to_dez(gettext$(R%[3])) + sta%   ' A1 vorzeichenbehaftet
  ram_adr_cykl                           ' RAM-Bereichsüberschreitung abfangen, Adresse zyklisch im RAM
  b_res$ = gettext$(RAM%, row% ,2)  
  settext R%[rx%], b_res$
  flags_b_res_N_Z_0_0  
  inc ic_dez%
  set_IC 
endproc
proc _STO	 ' STO (IO)	     ' 111 1 11 00   STOre   Datei <- Adr(h80+A1+ST) D0 Byte  über D1  (Art: IO)
  iofile$ = gettext$(o_ch%)               ' Ausgabe Kanaldatei
  if len(iofile$) = 0
    iofile$ = savefile$("Daten speichern","HC680 Datei  (*.hcx)| *.hcx")
  endif  
  assign #10,iofile$
  rewrite #10                             ' vorhandene überchreiben 
  ' ab Byte 128 für Daten vorgesehen
                ' A1 vorzeichenbehaftet 
  row% = 128 + bin8_to_dez(gettext$(R%[3])) + sta% ' ab Adr.(h80 + A1 + ST)  D0-Byte extern speichern 
  ram_adr_cykl                            ' RAM-Bereichsüberschreitung abfangen, Adresse zyklisch im RAM
  'IO_SR$                                 ' Art Daten IO, linke zwei Bit in SR
  temp% = 0                               ' Daten mitzählen
             '   D0 vorzeichenlos
  while temp% < val("%"+gettext$(R%[0]))  ' Anzahl der zu kopierenden Byte in D0 (vorzeichenlos)                  
    btemp1$ = gettext$(RAM%, row%, 2)                   ' 8 Bit binär für D1-Eintrag
    set_D1(btemp1$)                                     ' in D1 ablegen und sichtbar machen
    select IO_SR$     ' Art der Speicherung: 
      caseof "00" 
        btemp1$ = chr$(val("%"+btemp1$))   '  Zeichen
      caseof "01"   
        btemp1$ = bin8_to_dez(btemp1$)     '  dezimal
      caseof "10"  
        btemp1$ = bin8_to_hex2(btemp1$)    '  hexadezimal: xx  
      caseof "11"    
        btemp1$ = btemp1$                  '  8 Bit binär  (übernehmen) 
    endselect
    print #10,btemp1$  
    inc row%  
    if row% = 256               ' RAM Ende ...   ' messagebox("RAM-Ende!","Fehler beim Speichern der Datei \nweniger Daten geschrieben",0)
      break                     ' ... Abbruch, es werden weniger Daten geschrieben
    endif
    inc temp%                               ' Zähler für Anzahl gespeicherter Werte
    inc t%                                  ' clock weiterzählen
  endwhile // schreiben
  row% = 0                                  ' zurücksetzen
  close #10                                 ' Datei schliessen   
  '
  settext R%[0], d255_to_bin8(temp%)          ' Anzahl (vorzeichenlos) der tatsächlich geschriebenen Daten in D0 ablegen
  N$ = "0"
  if temp% = 0                  
    Z$ = "1"                                  ' Z-Flag setzen, wenn keine Daten geschrieben wurden
  else
    Z$ = "0" 
  endif
  V$ = "0"                               
  C$ = "0"
  settext SR%, left$(gettext$(SR%),4) + N$ + Z$ + V$ + C$  ' Flags in SR setzen
  inc ic_dez%
  set_IC 
endproc
proc _RCL  ' RCL (IO)      ' 111 1 11 01   ReCalL  Adr(h80+A1+ST) <- Datei   über D1 (Art: IO)  /D0 Byte gelesen
  var bit% = 0 
  V$ =  "0"                              ' oVerflow Flag vorab 0 setzen
  iofile$ = gettext$(i_ch%)              ' Eingabe Kanaldatei
  if len(iofile$) = 0 
    iofile$ = loadfile$("Daten laden","HC680 Datei  (*.hcx)| *.hcx")
  endif  
  assign #10,iofile$ 
  reset #10
  ' ab  128 für Daten vorgesehen,   A1 vorzeichenbehaftet 
  row% =    128      +       bin8_to_dez(gettext$(R%[3])) + sta% ' ab h80 + A1 + ST   einlesen  
  ram_adr_cykl                      ' RAM-Bereichsüberschreitung abfangen, Adresse zyklisch im RAM
  'IO_SR$                           ' Art Daten IO, linke zwei Bit in SR
  temp% = 0                         ' Daten mitzählen
  whilenot eof(#10)
    input #10, btemp1$
    btemp1$ = trim$(btemp1$) 
    '-------------                  ' Art der einzulesenden Daten:
    select IO_SR$
      caseof "00"                            ' --- Tastaturzeichen --- 
        conval% = ord(btemp1$)                                                     ' ANSI 0..255 Codewert erstes Zeichen  
        btemp2$ = d255_to_bin8(conval%)                                            ' binär umrechnen 
        set_D1(btemp2$)                                                            ' in D1 ablegen und sichtbar machen
        settext RAM%,row%,2, btemp2$                                               ' binär eintragen
        sp_h$ = space$(5-len(btemp1$)) +"h"                                        ' variable Leerzeichen vor h für hexadezimalen Wert                                 
        settext RAM%,row%,3, btemp1$ + sp_h$ + bin8_to_hex2(btemp2$)               ' Zeichen, hex eintragen
        ' ---
      caseof "01"                           ' --- Zahl ---
        conval% = val(btemp1$)                                                     ' Wert aus String ermitteln
        if ((conval% > 127) or (conval% < -128))                                   ' nicht darstellbar --> 0
          conval% = 0   
          btemp1$="0"
          V$ = "1"                                                                 ' oVerflow Flag setzen
        endif  
        btemp2$ = dez_to_bin8(conval%)                                             ' binär umrechnen 
        set_D1(btemp2$)                                                            ' in D1 ablegen und sichtbar machen
        settext RAM%,row%,2, btemp2$                                               ' binär eintragen
        sp_h$ = space$(5-len(btemp1$)) +"h"                                        ' variable Leerzeichen vor h für hexadezimalen Wert                                 
        settext RAM%,row%,3, btemp1$ + sp_h$ + bin8_to_hex2(btemp2$)               ' Zahl, hex eintragen
        ' ---
      caseof "10"                            ' --- hexadezimal xx ---
        conval% = val("$" + btemp1$)                                               ' dezimal ohne Vorzeichen: 0..255
        if conval% > 255                                                           ' nicht darstellbar --> 00
          conval% = 0                         
          btemp1$ ="00"
          V$ = "1"                                                                 ' oVerflow Flag setzen
        endif 
        btemp2$ = d255_to_bin8(conval%)                                            ' binär umrechnen
        set_D1(btemp2$)                                                            ' in D1 ablegen und sichtbar machen
        settext RAM%,row%,2, btemp2$                                               ' binär eintragen
        sp_h$ =  space$(5-len(str$(bin8_to_dez(btemp2$))) )                        ' variable Leerzeichen vor h für hexadezimalen Wert 
        settext RAM%,row%,3, str$(bin8_to_dez(btemp2$)) + sp_h$ + "h"+ btemp1$     ' dez. hex. eintragen
       ' ---
      caseof "11"                            ' --- 8 Bit binär --- 
        if (len(btemp1$) > 8) 
          btemp1$  = right$(btemp1$,8)                                                ' links auf 8 abschneiden
          V$ = "1"                                                                    ' oVerflow Flag setzen
        endif
        case (len(btemp1$) < 8) : btemp1$  =  mkstr$("0", 8 - len(btemp1$)) + btemp1$ ' links bis 8 mit 0 auffüllen
        bit% = 0                                                                   
        repeat                                                                        ' auf 0 bzw. 1 prüfen 
          inc bit%
          if ( (mid$(btemp1$,bit%,1) <> "0") and (mid$(btemp1$,bit%,1) <> "1") )      ' ungültige Binärziffer ...
            btemp1$ = "00000000"                                                      ' ... Nullbyte
            bit% = 8
            V$ =  "1"                                                                 ' oVerflow Flag setzen
          endif
        until bit% = 8
        set_D1(btemp1$)                                                               ' in D1 ablegen und sichtbar machen
        settext RAM%,row%,2,btemp1$                                                   ' binär eintragen
        sp_h$ = space$(5-len(str$(bin8_to_dez(btemp1$)))) +"h"                        ' variable Leerzeichen vor h für hexadezimalen Wert 
        settext RAM%,row%,3, str$(bin8_to_dez(btemp1$))+ sp_h$ + bin8_to_hex2(btemp1$)  ' dez. hex. eintragen
    endselect // Art Daten IO_SR
   '----------------------------
    inc row%    
    if row% = 256 
         V$ =  "1"                          ' oVerflow  Flag setzen ... 
      break                                 '         ... zu viele Daten für RAM-Größe, Abbruch 
    endif  
    inc temp%                               ' eingelesene Daten mitzählen
    inc t%                                  ' clock weiterzählen
  endwhile // einlesen  
  '
  row%  = 0                                 ' wieder auf Anfang setzen
  close #10                                 ' Datei schliessen 
  '
  settext R%[0], d255_to_bin8(temp%)        ' Anzahl (vorzeichenlos) eingelesener Daten in D0 ablegen 
  N$ = "0"
  if temp% = 0                  
    Z$ = "1"                                ' Z-Flag setzen, wenn keine Daten gelesen wurden
  else
    Z$ = "0" 
  endif
  ' V$  wird vorab 0 und in der Schleife gesetzt
  C$ = "0"
  settext SR%, left$(gettext$(SR%),4) + N$ + Z$ + V$ + C$  ' Flags in SR setzen
  inc ic_dez% 
  set_IC 
endproc
proc _CPY	 ' CPY	         ' 111 1 11 10   CoPY Adr(A1)<-Adr(A0)     D0 Byte über D1
  V$ =  "0"                                ' oVerflow Flag vorab zurücksetzen
  var i% = 0         ' Daten mitzählen
  while i% < val("%"+gettext$(R%[0]))      ' Anzahl der zu kopierenden Byte in D0 (vorzeichenlos)
    temp% = i% + val("%"+gettext$(R%[2]))  ' Quellzeile bestimmen
    if temp% = 256                         ' RAM-Ende erreicht ...  'messagebox("RAM-Ende erreicht!","--- Fehler beim Kopieren! ---",0)
      break                                ' ... es werden weniger Daten kopiert, Abbruch 
    endif  
    btemp1$ = gettext$(RAM%, temp% , 2)    ' binär aus Quellzeile auslesen
    set_D1(btemp1$)                        ' in D1 ablegen und sichtbar machen
    row% = i%  + val("%"+gettext$(R%[3]))  ' Zielzeile bestimmen
    if row% = 256 
      V$ =  "1"                            ' oVerflow    ' messagebox("RAM-Ende erreicht - Überlauf!","--- Fehler beim Kopieren! ---",0)
      break                                ' zu viele Byte für RAM-Größe, Abbruch 
    endif  
    settext RAM%, row%, 2, btemp1$                              ' binär eintragen
    sp_h$ = space$(5-len(str$(bin8_to_dez(btemp1$ )))) +"h"    ' variable Leerzeichen vor h für hexadezimalen Wert 
    settext RAM%, row%, 3, str$(bin8_to_dez(btemp1$ )) + sp_h$ + bin8_to_hex2(btemp1$) ' dez. hex. eintragen
    inc i%
    inc t%                                  ' clock weiterzählen   
  endwhile 
  settext R%[0], d255_to_bin8(i%)             ' Anzahl (vorzeichenlos) kopierter Bytes in D0 ablegen 
  N$ = "0"
  if i% = 0                  
    Z$ = "1"                                  ' Z-Flag setzen, wenn keine Daten kopiert wurden
  else
    Z$ = "0" 
  endif
  ' V$  wird vorab und  bei break (Zielzeile) eventuell in der Schleife bearbeitet
  C$ = "0"
  settext SR%, left$(gettext$(SR%),4) + N$ + Z$ + V$ + C$  ' Flags in SR setzen
  inc ic_dez% 
  set_IC 
endproc
proc _STP  ' STP           ' 111 1 11 11 	 StoP
  stop% = 1   
  inc ic_dez%  
  set_IC
  ' -->  Flags nicht verändern - Weiterlauf des Programms auch mit nachfolgendem Sprungbefehl denkbar
endproc
'} 
' *****************************************************
'. 