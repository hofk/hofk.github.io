<!DOCTYPE html>
<!--  @author hofk   windows and web version     https://cpusimulation.hofk.de/   -->
<head>
    <title> CPU-Simulation-8Bit </title>
    <meta charset="utf-8" />
    
    <style>
    
    *{
        box-sizing:border-box;
        border-collapse:collapse;
        outline: 0;
        border: 0;
        margin: 0;
        padding: 0;
        cellspacing: 0;
        cellpadding: 0;
        border-spacing: 0;
        image-rendering: pixelated;
        
    }
    
    body {
        overflow: hidden; /* to avoid incorrect mouse coordinates ( mouseover -> self-created 'div' tooltips) */
        background-color: #eeeeee;
        font-family: sans-serif;
    }
    
    .slider {
        -webkit-appearance: none;
        width: 100%;
        height: 24vh;
        border-radius: 0vh;
        background: #cdcdcd;
        outline: none;
        opacity: 0.4;
        -webkit-transition: .2s;
        transition: opacity .2s;
    }
    
    .slider:hover {
        opacity: 1;
    }
    
    .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 4vh;
        height: 4vh;
        /*border: 0;*/
        border-radius: 2vh;
        background: url('faster32.png');
        cursor: pointer;
    }
    
    .slider::-moz-range-thumb {
        width: 4vh;
        height: 4vh;
        border: 0;
        border-radius: 2vh;
        background: url('faster32.png');
        cursor: pointer;
    }
    
    #lft{
        position:absolute;
        left: 0vh;
        top: 0vh;
        width: 70vh; /* see const widthLeft below */
        height: 100vh;     /* see const heightLeft  below */
        margin: 0vh;
        padding: 0vh;
        overflow:hidden;
        font: Arial;
        font-size: 1.9vh;
        text-align: center;
    }
     
    #assl{
        position: absolute;
        left: 1vh;
        top: 100vh; /* not visible for now  */
        width: 58vh;
        height:90vh;
        margin: 0vh;
        padding: 0vh;
        overflow: hidden;
    }
    
    #asmLoad {
        visibility: hidden;
    }
    
     #hcxLoad {
        visibility: hidden;
    }
    
    #selectAsmFile {
        visibility: hidden;
        position: absolute;
        left: 55vh;
        top: 62.5vh;
        width: 20vh;
        height: 3vh;
        font: Arial;
        font-size: 1.7vh;
        color: #339966;
        text-decoration: underline overline #339966;
        cursor: pointer;
    }
    
    #selectInputFile {
        /*visibility: hidden;*/
        position: absolute;
        left: 3vh;
        top: 18vh;
        width: 6vh;
        height: 3vh;
        font: Arial;
        font-size: 1.7vh;
        color: #339966;
        text-decoration: underline  #339966;
        cursor: pointer;
    }
                
    </style>
</head>

<body>
    <div id = 'wrap'>
        <div id = 'lft'>
            <input type="file" id="asmLoad">
            <label for="asmLoad" id="selectAsmFile"> select file </label>
            <input type="file" id="hcxLoad">
            <label for="hcxLoad" id="selectInputFile"> select </label>
        </div>
        <div id = 'assl'>
            <img src="assemblerList.png" >
        </div>
    </div>

</body>

<script type="module">

// @author hofk

import * as THREE from "./three.module.134.js";
import { OrbitControls } from "./OrbitControls.134.js";

// ....... JavaScript syntax extensions - partly adaptations to original source code (XProfan) .......
const gettext = ( elm ) => ( elm.innerHTML || elm.value );
const settext = ( elm, string ) => ( elm.innerHTML = string );
const mkstr = ( s, n ) => ( s.repeat( n ) );
const space = ( n )  => ( ' '.repeat( n ) );
const right = ( s, n ) => ( n === 0 ? '' : s.substr( -n ) );
const left  = ( s, n ) => ( s.substr( 0, n ) );
const mid = (s, n, c ) => ( s.substr( n - 1, c ) );

const sp_h = ( n ) => ( space( 5 - n ) + 'h' );            // variable space before h for hexadecimal value in RAM

function substr( s1, n, s2 ) { // s1 string, n number of the substring, s2 separator
    
    let pos;
    let s = s1;
    
    for ( let i = 0; i < n - 1; i ++ ) {
        
        pos = s.indexOf( s2 );
        s = s.substr( pos + 1 );
        
    }
     
    pos = s.indexOf( s2 );
    
    return s.slice( 0, pos );
    
}

String.prototype.bdec = function ( ) { return parseInt( this, 2 ) }            // decimal value of the binary number string
String.prototype.hdec = function ( ) { return parseInt( this, 16 ) }           // decimal value of the hexadecimal string
String.prototype.ord = function ( ) { return this.charCodeAt( 0 ) }            // ANSI code first character
String.prototype.val = function ( ) { return parseInt( this, 10 ) }            // decimal value of the decimal number string

Number.prototype.chr = function ( ) { return String.fromCharCode( this ) }     // character to ANSI code
Number.prototype.str = function ( ) { return this.toString( 10 ) }             // convert decimal value to string
Number.prototype.bin = function ( ) { return this.toString( 2 ) }              // convert decimal value to binary number ( 8 or 16 bit )

// .............  global ........................

const wrap = document.getElementById( 'wrap' );
const assl = document.getElementById( 'assl' );
const vhu = ( i ) => ( i + 'vh' );

let mouse = new THREE.Vector2( );
let raycaster = new THREE.Raycaster( );
let intersects = [];
let selection;
let objectsToRaycast = [];
let wih, wiw, lcw, lch;
let mnVisible, op1Visible, op2Visible; 

const div = 'div';
const input = 'input';
const text = 'text';
const file = 'file';
const range = 'range';
const button = 'button';
const checkbox = 'checkbox';
const span = 'span';
const table = 'table';
const tr = 'tr';
const td = 'td';
//const p = 'p';

const noChars = [ 'Shift', 'Control', 'Alt', 'AltGraph', 'Enter', 'Backspace', 'Insert', 'Delete', 'Home', 'End', 'PageUp', 'PageDown', 'Escape', 'Tab',  'CapsLock', 'Pause', 'ScrollLock', 'NumLock', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'OS', 'ContextMenu', 'Dead' ];

// .............. initialization .................

let ttEN = [];

const white  = '#ffffff';
const black =  '#000000';
const dGray  = '#222222';
const gray  =  '#e6e6e6';
const lGray  = '#f6f6f6';
const sandy  = '#eeeed3'; 
const lSandy = '#fdfde2'; // light sandy
const vSandy = '#fefeeb'; // very light sandy
const dred =   '#e10000'; // dark red 
const green =  '#00c800';
const dgreen = '#0a8318'; // dark green
const yellow = '#ffff00';

const sfont = 'sfont';
const csfont = 'csfont';
const vsfont = 'vsfont';
const ttfont = 'ttfont';
const lfont = 'lfont';
const cfont = 'cfont';
const rfont = 'rfont';
const cnfont = 'cnfont';
const xfont = 'xfont';
const shfont = 'shfont';

// ----  global variables for the simulation ( adapted from original source code XProfan ) ----

let inp;                    // user input into edit decimal/ char/ hexadecimal hxx Hxx $xx
let hinp;                   // input hexadecimal
let binp;                   // input binary
let inpval;                 // value input
let ansi;                   // ANSI-Code char or of the first char in the string
let boutp;                  // output binary
let oc;                     // opcode of the command (binary, parsed: xxx x xx xx)
let mn, op1, op2;           // mnemonic,  operand 1, operand 2
let ocg;                    // opcode grop 3 bit
let ocb;                    // opcode bit (place 4)
let ocyy;                   // opcode 2bit (partly target register)
let ocxx;                   // opcode 2bit (partly source register)
let rx;                     // opcode decimal (partly index of register field)
let ry;                     // opcode decimal (partly index of register field)
let ocyyxx;                 // yy xx combine (with space)
let coninp;                 // constant - input from edit
let conbin;                 // constant binary representation
let conval;                 // decimal value of constant
let opcomm;                 // comment on command
let concomm;                // comment on constant
let IO_SR;                  // left two bits of the Status Register, type input/output character, dec, hex, bin
let XY_SR;                  // bits 3,4 of the status register, freely usable
let fl;                     // flags that can be set by the command
let N;                      // N-flag (negativ)            0/1 --> Status Register SR
let Z;                      // Z-flag (zero)               0/1 --> Status Register SR
let V;                      // V-flag (overflow )          0/1 --> Status Register SR 
let C;                      // C-flag (carry)              0/1 --> Status Register SR
let N_;                     // N-flag as char N  after command execution
let Z_;                     // Z-flag as char Z  after command execution      
let V_;                     // V-flag as char V  after command execution
let C_;                     // C-flag as char C  after command execution
      // V-flag, oVerflow flag: If the overflow flag is set, then an overflow occurred during the last arithmetic operation
         // if signed operands are assumed. (< -128  oder  > 127) 
      // C flag, Carry flag: If this flag is set, then a carry occurred during the last arithmetic operation, 
         // assuming unsigned operands. (>255) 
         // If the last executed instruction was a shift/rotate operation, the carry flag indicates 
         // whether a bit was shifted out or around.
let C8, R8;                 // carryover and result  8 bit 
let C9, R9;                 // carryover and result  9 bit (ALU)
let bit;                    // bit counter
let addBit;                 // bit counter add_ALU_9
let mulBit;                 // bit counter mul_Booth_ALU5
let b1, b2, b3;             // individual bits of the operands, the carry, the shift counter
let bc, r;                  // bit carryover, bit result
let mk;                     // one mouse button pressed: mk is '1'
let ip, jp;                 // row and column index of the maxipixels of the MGA display (Micro-Graphic-Adapter)
let pix;                    // MGA pixel (0 or 1)
let mgapix;                 // MGA address pixel/status (7 bit from RAM line 247 = hF7)
let b_res;                  // byte with result/ intermediate result of an operation
let btmp;                   // temporary value, binary
let tmp;                    // temporary value, multiplication, division
let btmp1 = "";             // temporary byte, multiplication, division (global, since _MUL_Booth ... is decomposed)
let btmp2 = "";             // temporary byte, multiplication, division (global, since _MUL_Booth ... is decomposed)
let temp;                   // global temporary integer for intermediate storage
let btemp1 = "";            // global temporary byte, intermediate storage
let btemp2 = "";            // global temporary byte, intermediate storage
let iofile;                 // channel file (internal), I/O file to be saved with STO command/ to be loaded with RCL
let asmfile                 // HC 680 assembler file
let asm;                    // assembler lines
let aps;                    // assembler program string
let asmArr = [];            // assembler program array
let l_asm;                  // length of the assembler line
let takt;                   // variable processor clock
let ms;                     // clock delay in milliseconds
let t0;                     // CPU time base value
let t;                      // CPU time
let tb;                     // CPU time at break
//let debugfile;            // debug file  ( debug only in Windows variant)
//let debug;                // debug to IC state
let breakp;                 // breakpoint    hexadecimal comparison value
let break1, break1bak;      // breakpoint 1, hexadecimal
let break2, break2bak;      // breakpoint 2, hexadecimal
let break3, break3bak;      // breakpoint 3, hexadecimal 
let ramr;                   // RAM row, content
let row;                    // calculated number of the RAM row, helper variable
let mgarow;                 // row content in the MGA display
let pfr;                    // program from - hexadecimal address for storage
let pto;                    // program to   - hexadecimal address for storage
let dfr;                    // data    from - hexadecimal address for storage
let dto;                    // data    to   - hexadecimal address for storage
let bin8;                   // binary number 8-bit  
let hex2;                   // hexadecimal number, 2 digits
let hex1;                   // Hexadecimal digit
//                          // sp_h see function above
let msg;                    // message result
let key;                    // key during program run (binary code --> RAM line 246 = hF6)
let ass;                    // assembler command or assembler constant
let conalt;                 // alternative representation of the constants
let mnArr = [];             // array for mnemonics of the assembler
let opArr = [];             // array for operands 1 and 2 for assember commands
let R = [];                 // content register array:         R[0]= DO, R[1]= D1, R[2]= AO, R[3]= A1
let S = [];                 // contents shadow register array: S[0]=SDO, S[1]=SD1, S[2]=SAO, S[3]=SA1
let comment = [];           // comment array for commands and constants
let mga = [];               // RAM rows MGA display, content
let hlp = [];               // array, content of the structure help assembler commands
let RAM = [];               // RAM content
let posRAMy = -2;           // y RAM position (initial value)
let ramrow = 0;             // row number in RAM
let prevrow = 0;            // previous row number
let sta_dec = 0;            // standard start address decimal
let sta = "00";             // standard start address hexadecimal
let coderow    = 0;         // number Command line (from h00 is default)
let ic_dec     = 0;         // decimal value Instruction Counter IC
let cIC = 0;                // current IC 
let ic_dec_fl  = 0;         // decimal IC - remember to insert the flags set by the command
let conrow     = 128;       // number constant row
let starow     = 245;       // default, stack row (base address)
let ramshift   = 0;         // shift assembler in RAM
let halt       = 0;         // halt program by operator: 1
let stop       = 0;         // after STP command or error: 1
let breakit    = 0;         // operator abort with X STOP: 1
let break123   = 0;         // after one of the three breakpoints: 1
let onestep    = 0;         // for single step, clicked on next: 1 
let nospeed    = 0;         // program execution in single step: 1
let afterstep  = 0;         // after program execution in single step: 1 (to restore status start button)
let fullspeed  = 0;         // from > 255Hz fullspeed = 1 (remember, no stop, reduce clock if necessary)
let iorow = 0;              // row output log
let inp_OkClicked = false;  // end of user input during program run

let hcxArr = [];            // array:  input data from *.hcx

// ----------- const and let for web three.js variant -----------

const taktLinear = t => t / 10;
const taktQuadratic = t =>  10 + ( t - 98 ) * ( t - 98 ) / 100;

const M4 = new THREE.Matrix4( ); // helper matrix to position instanced meshes

const color = new THREE.Color( );
const colorWhite = new THREE.Color( 0xffffff );
const colorBlack = new THREE.Color( 0x000000 );

let CPUCLOCK;

let IR;        // instruction register
let IC;        // instruction counter
let ST;        // start adress
let SR;        // status register
let SP;        // stack pointer

// ALU contents

let AL1;    // ALU storage 1, AL1, operand
let AL2;    // ALU storage 2, AL2, operand
let ALC;    // ALU storage 3, ALC, carry
let ALR;    // ALU storage 4, ALR, result

let ARL;    // ALU storage, Result/ Low byte of 16Bit

let ALBA;    // ALU storage, multiplication according to Booth / D0 for addition
let ALBS;    // ALU storage, multiplication according to Booth / Subtraction (2's complement)
let ALx;    // ALU storage multiplication according to Booth,  (extra bit after result/low byte)

/* web variant: division not in ALU 
let ALS;    // ALU storage, for dividend shifting counter
let ALD;    // ALU storage, dividend for shift >> and shift <<
let ALN;    // ALU storage, divisor (summand, 2's complement)
let ALP;    // ALU storage, positive divisor
 
let AV1;    // ALU storage / Sign 1 for division
let AV2;    // ALU storage / Sign 2 for division

let ALf;    // ALU storage Division, first pass (shift option >> at 1 over 0)
let ALt;    // ALU storage Division, pass second partial loop
let ALa;    // ALU storage Division, addition of -abs(divisor)
*/

const visible = 0;
const hidden = -8000;

const visibility0 = ( A ) => ( A === '0' ? visible : hidden );
const visibility1 = ( A ) => ( A === '1' ? visible : hidden );

//................. vh*10 
const widthLeft =    700;
const heightLeft =  1000;
const widthRight =  1700;
const heightRight = 1000;
const widthHead =   2400;
const heightHead =    30;

let data = [];
let idx = 0;

// ------------------------------- project sub-areas --------------------------------  

// left area   see:   #lft{ .. } and  <div id = 'lft'>  

const containerRight = create( wrap, div, '', cfont, lSandy, widthLeft, 0, widthRight, heightRight );
containerRight.addEventListener( 'pointerdown', onContainerRightPointerDown );

 // head  overlays left and right
const containerHead  = create( wrap, div, '', cfont, gray, 0, 0, widthHead, heightHead );

const header = create( containerHead, span, '', cfont, gray, 3, 3,  widthHead - 6, 24 );
settext( header, 'Simulation Processor HC680 -fictional-  8 Bit Data/Addresses V 1.0.8.web' );

// --------------------------------- tooltip ----------------------------------------

const tt = create( wrap, text, '', ttfont, white, 240, 300, 160, 160 );
tt.style.padding = '0.1vh';
tt.style.border = '0.2vh outset';
settext( tt, '' );
tt.style.transition = '0.1s';
tt.style.visibility = 'hidden';

// ----------------------------------------------------------------------------------

data.push( [ 420, 32, 130, 25, 550, 66, 720, 660 ] ); //  element & tooltip:  left, top, width, height 
const shorthlp = create( lft, button, '', csfont, gray, data[ idx ++ ] );
settext( shorthlp, 'Short Instruction' );
ttEN.push( "Quick Reference Guide:"
          + "<br>-------------  <br>"        
+ "<br> Please note the tooltips for the essential elements.                "
+ "<br> Create an assembler/machine program by selecting the mnemonics and operands."
+ "<br> Invalid assembler commands are converted to NOP (00000000).  "
+ "<br> Store the empty RAM as assembler ( to clipboaed ) and open the file to recognize the structure."
+ "<br> Assembler files can be created and edited with a text editor."
+ "<br> Omissions are possible for easier notation. For details see loading tooltip."
+ "<br> Load one or more assembler sequences respecting the memory addresses."
+ "<br> Although the representation of RAM is designed for assembler instructions only up to line 127, "
+ "<br> a machine program will be executed even beyond that!  "
+ "<br> The RAM rows starting from 128 are conceptually for data, the stack, the keyboard- and mouse buffer  " 
+ "<br> and the Micro-Graphic-Adapter (MGA display 8x8 'maxi' pixels)."
+ "<br> If the program runs into this area, however, the bytes are interpreted as machine commands!"
+ "<br> Likewise, data can be written and executed in the range up to line 127."
+ "<br> However, RAM rows 0 and 128 are reconstructed from the edit in the assembler area  "
+ "<br> after manipulation at program stop."
+ "<br> "
+ "<br> Start the machine program with the green start button. "
+ "<br> "
+ "<br> Do not click on the input field that appears when the program is run, see the tool tip."
+ "<br> The byte with the address hF6 serves as keyboard buffer. It is filled in every clock pulse and enables "
+ "<br> even elementary event-driven GUI programs with the Micro-Graphic-Adapter."
+ "<br> In the RAM byte hF7 the MGA status is stored: | black: 1 | row: bbb | click: 1 | column: bbb |"
+ "<br> i.e. left bit set: black, three bit: row, 1 bit: click = 1, three bit: column."
+ "<br> The content of byte hF7 is evaluated by the system in each clock cycle, the addressed pixel is set/deleted."
+ "<br> For programs that respond to keyboard and/or mouse events, experimentally determine the clock range." 
+ "<br> "
+ "<br> Please also refer to the HC680 manual."
+ "<br> " );

shorthlp.addEventListener( 'pointerdown', onShorthlpPointerDown );

function onShorthlpPointerDown( event ) {
    
     alert(   "Please note the respective tooltips,"
            + "\nquick guide in this tooltip."
            + "\n "
            + "\n "
        );
    
}

// -------------------- interface input/output --------------------

const inputSystem = create( lft, span, '', lfont, sandy, 20, 31, 200, 24 );
settext( inputSystem, 'Input Output System' );

const ioOutline = create( lft, span, '', cfont, sandy, 5, 56, 390, 128 ); 
ioOutline.style.border = '0.3vh outset #ffffff';

const drawInp = create( lft, span, '', sfont, sandy, 10, 68, 46, 22 );
settext( drawInp, 'Input:' );

const drawANSIinp = create( lft, span, '', sfont, sandy, 135, 68, 32, 22 );
settext( drawANSIinp, 'ANSI' );

const inpKey_  = create( lft, span, '', cfont, white, 10, 90, 45, 28 );
inpKey_.style.border = '0.1vh solid';
hide( inpKey_ );

data.push( [ 10, 90, 45, 28, 55, 118, 680 , 220] );
const inp_ = create( lft, input, text, lfont, white, data[ idx ++ ] );
hide( inp_ );
ttEN.push( " Continuous input of a keyboard character. "  
+ "<br> The input takes place to each clock also without clicking into the input field!"
+ "<br> The binary ANSI code is stored at address hF6."
+ "<br> "
+ "<br> With the command INP alternatively also input of a decimal number in the range -128 ... 127 "
+ "<br> or enter a hexadecimal number in the form hxx or Hxx or $xx."
+ "<br> Hexadecimal digits 0..9, A..F or a..f - invalid digits are converted to 0."
+ "<br> For INP, the input must be acknowledged with OK."
+ "<br> The input is then stored in the register and at address hF6 "
+ "<br> and displayed in the input/output log. The display there is according to the content "
+ "<br> of the IO bits in the status register: 00 character, 01 decimal, 10 hexadecimal, 11 binary."
+ "<br> "

);

const altinp_  = create( lft, span, '', cfont, gray, 68, 90, 46, 22 );    // alternatively: number/code || code/number

const ans_ = create( lft, span, '', cfont, gray, 127, 90, 43, 22 );        // ANSI code on character input

const binp_ = create( lft, span, '', cfont, gray, 10, 120, 87, 22 );

const hinp_ = create( lft, span, '', cfont, gray, 100, 120, 43, 22 );

data.push( [ 150, 115, 30, 30, 180, 145, 240, 24] );
const inp_ok = create( lft, button, '', xfont, gray, data[ idx ++ ] );
settext( inp_ok, 'OK' );
hide( inp_ok );
ttEN.push( "Confirm the input by clicking OK." );

inp_ok.addEventListener( 'pointerdown', onInp_okPointerDown );

const inputFileName  = create( lft, input, text, lfont, white, 10, 150, 135, 28 );
inputFileName.setAttribute( 'readonly', 'true');
inputFileName.value = 'select *.hcx';

hcxLoad.addEventListener( 'change', e => {
    
    inputFileName.value = hcxLoad.files[0].name;
    
    if ( right( inputFileName.value, 4 ) !== '.hcx' ) {
          
        alert( 'incorrect file type or no selection, use *.hcx' );
        
        inputFileName.value = 'select *.hcx';
    }
    
} );

// ......................................

const drawOutp = create( lft, span, '',  sfont, sandy, 250, 68, 46, 22 );
settext( drawOutp, 'Output:' );

const drawANSIout = create( lft, span, '', sfont, sandy, 315, 68, 32, 22 );
settext( drawANSIout, 'ANSI' );

const outp_ = create( lft,  span, '', cfont, gray, 250, 90, 46, 22 );

const ansout_ = create( lft, span, '', cfont, gray, 310, 90, 43, 22 );

const coutp_ = create( lft, span, '', cfont, gray, 360, 90, 22 , 22 ); 

const boutp_ = create( lft, span, '', cfont, gray, 250, 120, 87, 22 );
 
const houtp_ = create( lft, span, '', cfont, gray, 340, 120, 43, 22 );

const toClipboard = create( lft, button, '', cfont, gray, 250, 150, 135, 28 );
toClipboard.style.color = dred;
settext( toClipboard, 'to Clipboard');
toClipboard.addEventListener( 'pointerdown', onToClipboardPointerDown );

const hcxTextArea = create( wrap, 'textarea', '', lfont, green, 0, 0, 0, 0 ); //  input/output helper

// .................  I/O-Protocol  ................

const drawShio = create( lft, span, '', sfont, sandy, 575, 35, 90, 22 );
settext( drawShio, 'I/O-Protocol' );

const shio = create( lft, input, checkbox, lfont, '', 670, 38, 22, 22 );
shio.addEventListener( 'change', onShioChange );

let trIO = [];
let inpIO = [];
let outIO = [];

const IO = create( lft, span, '', cfont, sandy, 500, 65, 190, 450 );
IO.style.overflowY = 'scroll';

hide( IO ); // hide for now

const tableIO = create( IO, table, '', lfont, white, 0, 0, 190, 900 );

const headIO = create( tableIO, tr, '', vsfont, white, 2, 5, 170, 24 );
settext( headIO, ' .. > input ..... output > ..'  );

for ( let i = 0; i < 40; i ++ )   {

    trIO[ i ] = create( tableIO, tr, '', lfont, white, 2, 28 + 22 * i, 170, 20 );
    inpIO[ i ] = create( trIO[ i ], td, '', cfont, white, 2, 0, 78, 20 );
    outIO[ i ] = create( trIO[ i ], td, '', cfont, white, 84, 0, 78, 20 );
    
}

const drawClrio = create( lft, span, '', sfont, sandy, 525, 530, 135, 22 );
settext( drawClrio, 'delete I/O-Protocol' );
hide( drawClrio );

const clrio = create( lft, button, '', xfont, gray, 665, 525, 22, 22 );
settext( clrio, 'X' );
hide( clrio );

// ---------------------------- Control unit -------------------------------------

const controlUnit = create( lft, span, '', shfont, sandy, 20, 210, 150, 24 );
settext( controlUnit, 'Control Unit' );

const cuOutline = create( lft, span, '', cfont, sandy, 5, 235, 480, 290 ); 
cuOutline.style.border = '0.3vh outset  #ffffff';

const drawHC680BC = create( lft, span, '', lfont, sandy, 140, 240, 200, 22 );
settext( drawHC680BC, 'HC680 binary code ' );

const drawRunStatus = create( lft, span, '', rfont, sandy, 10, 270, 125, 22 );
settext( drawRunStatus, 'execute' );

const startbin = create( lft, button, '', xfont, green, 140, 265, 40, 40 );
startbin.style.borderRadius = '8vh';
startbin.style.border = '0.51vh solid silver';
//startbin.addEventListener( 'pointerdown', onStartbinPointerDown );
startbin.addEventListener( 'pointerdown', onStartbinPointerDown );

data.push( [ 190, 275, 22, 22, 210, 300, 450, 30 ] );
const abr = create( lft, button, '', xfont, gray, data[ idx ++ ] );
settext( abr, 'X' );
ttEN.push( " Cancel program immediately with x, \notherwise click yellow circle. ");
abr.addEventListener( 'pointerdown', onAbrPointerDown );
hide( abr );

const drawSTOP =  create( lft, span, '', xfont, sandy, 220, 275, 52, 22 );
drawSTOP.style.color = dred;
settext( drawSTOP, 'STOP' );
hide( drawSTOP );

const bit_stp = create( lft, button, '', cfont, gray, 20, 265, 300, 40 );
settext( bit_stp, ' input ... ' );
hide( bit_stp );

const wait_inp = create( lft, button, '', cfont, gray, 20, 265, 300, 40 );
settext( wait_inp, ' input  ... ' );
hide( wait_inp );

const nextstep = create( lft, button, '', cfont, gray, 400, 266, 70, 30 );
nextstep.addEventListener( 'pointerdown', onNextstepPointerDown );
settext( nextstep, 'go on' );
hide( nextstep );

const drawClockSpeed  =  create( lft, span, '', cfont, sandy, 10, 306, 120, 22 );
settext( drawClockSpeed, 'clock speed:' );

const takthz =  create( lft, span, '', cfont, gray, 380, 304, 60, 22 );
settext( takthz, '1.0' );

const drawTakthz =  create( lft, span, '', cfont, sandy, 445, 304, 35, 22 );
settext( drawTakthz, 'Hz' );

data.push( [ 12, 330, 460, 18, 12, 350, 580, 140 ] );
const takt_scroll = create( lft, input, range, lfont, '', data[ idx ++ ]);
ttEN.push( " --- frequency selection --- <br>" 
+ "<br> Single step (above), then clock frequency from 0.1 to 255Hz, then unbraked. <br> "
+ "<br> - The frequency can also be changed during the program run."
+ "<br>  During the program run the breakpoints are editable."  
+ "<br> - from 10Hz nonlinear scale. <br> " 
+ "<br>  ");

const drawBreakpt =  create( lft, span, '', sfont, sandy, 30, 373, 100, 22 );
settext( drawBreakpt, 'Breakpoints' );

data.push( [ 120, 370, 28, 28, 130, 400, 280, 66 ] );
const breakpt1 = create( lft, input, text, cfont, white, data[ idx ++ ] );
ttEN.push( "Breakpoint 1"
+ "<br> Hexadecimal address, a single step. " 
+ "<br> Not considered for clock >255Hz." );

data.push( [ 155, 370, 28, 28, 165, 400, 280, 66 ] );
const breakpt2 = create( lft, input, text, cfont, white, data[ idx ++ ] );
ttEN.push( "Breakpoint 2"
+ "<br> Hexadecimal address, a single step." 
+ "<br> Not considered for clock >255Hz." );

data.push( [ 190, 370, 28, 28, 200, 400, 280, 66 ] );
const breakpt3 = create( lft, input, text, cfont, white, data[ idx ++ ] );
breakpt3.value = '7F';
ttEN.push( "Breakpoint 3"
+ "<br> Hexadecimal address, a single step." 
+ "<br> Not considered for clock >255Hz." );

const drawBrpHex = create( lft, span, '', sfont, sandy, 225, 385, 30, 22 );
settext( drawBrpHex, 'hex' );
 
// debug and cache ( only in Windows version )

const drawbitwise = create( lft, span, '', sfont, sandy, 370, 360, 90, 22 );
settext( drawbitwise, 'ALU bitwise' );

data.push( [ 385, 380, 22, 22, 395, 400, 380, 33 ] );
const alu_bitw = create( lft, input, checkbox, lfont, '', data[ idx ++ ] );
ttEN.push( " Display the calculation process in the ALU bitwise. <br> ");

const setIC = create( lft, button, '', cfont, gray, 285, 420, 60, 30 ); // set IC during program run
setIC.addEventListener( 'pointerdown', onSetICpointerdown );
settext( setIC, 'set IC' );
hide( setIC );

const set_hexIC = create( lft, input, text, cfont, white, 355, 420, 28, 28 ); 
set_hexIC.value = '00';
hide( set_hexIC );

const drawSet_IC = create( lft, span, '', lfont, sandy, 390, 425, 90, 22 );
settext( drawSet_IC, '00 current' );
hide( drawSet_IC );

const drawICHex = create( lft, span, '', sfont, sandy, 358, 448, 30, 22 );
settext( drawICHex, 'hex' );
hide( drawICHex );

const drawXRam = create( lft, span, '', rfont, sandy, 10, 480, 170, 22 );
settext( drawXRam, 'delete RAM/Flags' );

data.push( [ 185, 480, 22, 22, 195, 500, 620, 44 ] );
const xram = create( lft, button, '', xfont, gray, data[ idx ++ ] );
settext( xram, 'X' );
ttEN.push( "CAUTION! "
+ "<br> Delete the entire RAM, the flag column and the comments after confirmation prompt.");
xram.addEventListener( 'pointerdown', onXramPointerDown );

const drwXFlag = create( lft, span, '', rfont, sandy, 235, 480, 120, 22 );
settext( drwXFlag, 'delete Flags' );

data.push( [ 360, 480, 22, 22, 370, 500, 500, 44 ] );
const xflag = create( lft, button, '', xfont, gray, data[ idx ++ ] );
settext( xflag, 'X' );
ttEN.push( "CAUTION! "
+ "<br> Delete the column of the last set flags without confirmation prompt.");
xflag.addEventListener( 'pointerdown', onXflagPointerDown );

// ------------------------- interface programming assembler --------------------------

const drawPrgAssembler = create( lft, span, '', shfont, sandy, 20, 540, 250, 24 );
settext( drawPrgAssembler, 'Programming Assembler' );

//const paOutline = create( lft, span, '', cfont, sandy, 5, 550, 690, 445 ); 
//paOutline.style.border = '0.3vh outset  #ffffff';

// ----------------- Assembler file program name, save, load, move  ----------------

const drawPrg = create( lft, span, '', sfont, sandy, 335, 565, 75, 22 );
settext( drawPrg, 'programm' );

const drawData = create( lft, span, '', sfont, sandy, 410, 565, 50, 22 );
settext( drawData, '| data:' );

const progname = create( lft, input, text, lfont, white, 465, 560, 220, 28 );
let prgn = ""; // for current program name

const drawStAdr = create( lft, span, '', sfont, sandy, 250, 600, 75, 22 );
settext( drawStAdr, 'start adr.' );

const drawPrgfromto = create( lft, span, '', sfont, sandy, 345, 600, 60, 22 );
settext( drawPrgfromto, 'from to' );

const drawDatafromto = create( lft, span, '', sfont, sandy, 410, 600, 75, 22 );
settext( drawDatafromto, ' | from to' );

const startadr = create( lft, input, text, cfont, white, 275, 630, 28, 28 );
startadr.value = '00'; // start address of the program is h00 (default)

const drawhex = create( lft, span, '', sfont, sandy, 310, 645, 40, 22 );
settext( drawhex, 'hex' );

const prgvon = create( lft, input, text, cfont, white, 340, 630, 28, 28 ); // start address of the program for storage 
const prgbis = create( lft, input, text, cfont, white, 375, 630, 28, 28 ); // end address of the program < 80 hex for storage
const datvon = create( lft, input, text, cfont, white, 410, 630, 28, 28 ); // address start data block from 80 hex for storage
const datbis = create( lft, input, text, cfont, white, 445, 630, 28, 28 ); // data block up to the address for storage

const asm_tmp = create( wrap, 'textarea', '', lfont, green, 0, 0, 0, 0 ); // as a buffer for store, load, shift assembler
const asm_bak = create( wrap, 'textarea', '', lfont, green, 0, 0, 0, 0 ); // as a buffer for store, load, shift assembler

const drawStore = create( lft, span, '', csfont, sandy, 500, 600, 140, 22 );
settext( drawStore, 'store to clipboard' );

const drawLoad = create( lft, span, '', csfont, sandy, 650, 600, 40, 22 );
settext( drawLoad, 'load' );

data.push( [ 570, 620, 30, 30, 600, 650, 500, 130 ] );
const store = create( lft, button, '', cfont, gray, data[ idx ++ ] );
settext( store, '‚Üí' );
ttEN.push( "Store a HC680 assembler file >>> to Clipboard .<br>"
+ "<br> The start address is stored." 
+ "<br> From beginningt address (min. 00) to end address (max. 7F) the program, "
+ "<br> the data from (min. 80) to (max. FF) are stored."
+ "<br> If no values are entered (the part) is not stored."
+ "<br> ");

store.addEventListener( 'pointerdown', store_asm );

data.push( [ 655, 620, 30, 30, 685, 650, 620, 220 ] );
const load = create( lft, button, '', cfont, gray, data[ idx ++ ] );
settext( load, '‚Üê' );
ttEN.push( "Load an HC680 assembly file into the working memory. <br><br>" 
+ " Faulty assembler commands are interpreted as NOP.<br>" 
+ " The colon after the command address is optional, one or two spaces are sufficient for it.<br>" 
+ " Also, the dots around the operands are optional, then put one to four separator spaces.<br>" 
+ " In the data area from address h80 only the left value or character is read.<br>" 
+ " For a better overview, the data can be set right-justified.<br>"
+ " The colon after the data address can be omitted, up to five spaces are allowed.<br>" 
+ " The 2nd column (uniform hexadecimal) is optional. It will be recalculated.<br>" 
+ " From column 21 the comment is read in, the semicolon in front of it is optional.<br>" 
+ " Please note the start address stored in the file." 
+ " <br> " );

load.addEventListener( 'pointerdown', load_asm );

const drawshift_by = create( lft, span, '', sfont, sandy, 490, 665, 60, 22 );
settext( drawshift_by, 'relocate' );

data.push( [  555, 660, 45, 28,  555, 690, 650, 33 ] );
const shift_by = create( lft, input, text, cfont, white, data[ idx ++ ] );
ttEN.push( "  ‚Üî  shift of program and/or data in memory, decimal or hexadecimal (-)hxx resp. Hxx, $xx <br>" 
+ "<br> "
);

data.push( [ 610, 660, 36, 28, 610, 690, 450, 150  ] );
const relocate = create( lft, button, '', cfont, gray, data[ idx ++ ]);
settext( relocate, '‚Üî' );
ttEN.push( "Shift the assembly instructions and/or the data in RAM.<br>" 
+ "<br> Specify the offset in decimal or hexadecimal hxx with sign. "
+ "<br> It is shifted from the entered start to the end addresses."
+ "<br> The existing contents are overwritten, free lines are set to zero."
//+ "<br> The RAM section is stored as asm_tmp.txt."            // only windows version 
//+ "<br> The complete RAM is saved before under asm_bak.txt."  // only windows version 
);

relocate.addEventListener( 'pointerdown', reloc_asm );

// --------------------------------- programming --------------------------------------

const drawAssComm = create( lft, span, '', lfont, sandy, 20, 670, 260, 22 );
settext( drawAssComm, 'ASSEMBLER-COMMAND' );

const drawCommAdr = create( lft, span, '', sfont, sandy, 23, 700, 22, 22 );
settext( drawCommAdr, 'Adr' );

const drawOpCode = create( lft, span, '', sfont, sandy, 65, 700, 90, 22 );
settext( drawOpCode, 'Op Code' );

const drawMnemonic = create( lft, span, '', sfont, sandy, 150, 700, 60, 22 );
settext( drawMnemonic, 'Mnemonic' );

const drawOp1 =  create( lft, span, '', sfont, sandy, 290, 700, 50, 22 );
settext( drawOp1, 'Op. 1' );

const drawOp2 =  create( lft, span, '', sfont, sandy, 380, 700, 50, 22 );
settext( drawOp2, 'Op. 2' );

data.push( [ 230, 700, 22, 30, 240, 670, 140, 30] );
const codeup = create( lft, button, '', cfont, gray, data[ idx ++ ] );
settext( codeup, '‚Üë' );
ttEN.push( "RAM - Adr. back " );
codeup.addEventListener( 'pointerdown', onCodeupPointerDown );

data.push( [  230, 740, 22, 30 , 230, 770, 140, 30  ] );
const codedown = create( lft, button, '', cfont, gray, data[ idx ++ ] );
settext( codedown, '‚Üì' );
ttEN.push( "RAM - Adr. forward " );
codedown.addEventListener( 'pointerdown', onCodedownPointerDown );

const cadr = create( lft, span, '', cfont, gray, 20, 720, 28, 22 );
settext( cadr, '00' );

const oc_ = create( lft, span, '', cfont, gray, 50, 720, 90, 22 );
settext( oc_, '00000000' ); // initialize

// ........................ mnemonics mn ................................. 

mnArr = [ 'NOP', 'CMP', 'SWD', 'SWM', 'MUL', 'DIV', 'PSA', 'POA', 'JSR', 'RET', 'JIN', 'JIZ', 'JMP', 'LDC', '## ', 'INP', 'OUT', 'PSH', 'POP', 'SSR', 'GSR', 'BTS', 'SWN', 'SHL', 'SHR', 'ROL', 'ROR', 'CLR', 'INC', 'DEC', 'NOT', 'AND', 'OR ', 'ADD', 'SUB', 'MOV', 'LOD', 'STO', 'RCL', 'CPY', 'STP' ];

const mn_ = create( lft, input, text, sfont, white, 150, 720, 50, 28 );
mn_.value = mnArr[0] ; // NOP
mn_.addEventListener( 'pointerdown', onMnPointerDown );
mn_.addEventListener( 'input', onMnInput );

data.push( [ 200, 721, 22, 26, 222, 747, 270, 22 ] );
const mnShow = create( lft, span, '', csfont, white, data[ idx ++ ] );
settext( mnShow, '‚ñΩ' );
ttEN.push( "  assembler, select or enter command mnemonic" );
mnShow.style.cursor = 'pointer';
mnShow.addEventListener( 'pointerdown', onMnShowPointerDown );

const mnListOutline = create( wrap, span, '', cfont, white, 150, 15, 72, 708 );
mnListOutline.style.border = '0.3vh outset silver';
mnListOutline.style.visibility = 'hidden';
mnListOutline.addEventListener( 'mousemove', onMnListMove );
mnListOutline.addEventListener( 'pointerdown', onMnListPointerDown );

let mnList = [];

for ( let i = 0; i < 41; i ++ ) {
     
    mnList[ i ] = create( mnListOutline, span, '', sfont, white,  5, 4 + 17 * i , 55, 15 );
    
    mnList[ i ].style.fontSize = '1.4vh';
    mnList[ i ].style.textAlign = 'left';
    mnList[ i ].style.paddingLeft = '0.5vh';
    mnList[ i ].style.textAlign = 'left'; 
    mnList[ i ].style.cursor = 'pointer';
    settext( mnList[ i ], mnArr[ i ] );
    
    mnList[ i ].style.visibility = 'hidden';
    
}

// ................... operands op1 op2 .........................

opArr = [ '.IA.', '.+A.', '.D0.', '.D1.', '.A0.', '.A1.', '.SR.', '.SP.', '[D0]', '[D1]', '[A0]', '[A1]', '0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111', '1000', '1001', '1010', '1011', '1100', '1101', '1110', '1111', '.00.', '.01.', '.10.', '.11.' ];

const op1_ = create( lft, input, text, sfont, white, 270, 720, 50, 28 );
op1Visible = false;
op1_.style.visibility = 'hidden';
op1_.addEventListener( 'pointerdown', onOp1PointerDown );
op1_.addEventListener( 'input', onOp1Input ); 

data.push( [ 320, 721, 22, 26,  344, 747, 300, 22 ] );
const op1Show = create( lft, span, '', csfont, white, data[ idx ++ ] );
settext( op1Show, '‚ñΩ' );
ttEN.push( "Assembler - 1st operand  select or fill in" );
op1Show.style.cursor = 'pointer';
op1Show.style.visibility = 'hidden';
op1Show.addEventListener( 'pointerdown', onOp1ShowPointerDown );

const op2_ = create( lft, input, text, sfont, white, 360, 720, 50, 28 );
op2Visible = false;
op2_.style.visibility = 'hidden';
op2_.addEventListener( 'pointerdown', onOp2PointerDown );
op2_.addEventListener( 'input', onOp2Input ); 

data.push( [ 410, 721, 22, 26, 432, 747, 300, 22 ] );
const op2Show = create( lft, span, '', csfont, white, data[ idx ++ ] );
settext( op2Show, '‚ñΩ' );
ttEN.push( "Assembler - 2nd operand  select or fill in" );
op2Show.style.cursor = 'pointer';
op2Show.style.visibility = 'hidden';
op2Show.addEventListener( 'pointerdown', onOp2ShowPointerDown );

const opListOutline = create( wrap, span, '', cfont, white, 0, 170, 72, 551 );
opListOutline.style.border = '0.3vh outset silver';
opListOutline.style.visibility = 'hidden';
opListOutline.addEventListener( 'mousemove', onOpListMove );
opListOutline.addEventListener( 'pointerdown', onOpListPointerDown );

let opList = [];

for ( let i = 0; i < 32; i ++ ) {
    
    opList[ i ] = create( opListOutline, span, '', cnfont, white, 5, 1 + 17 * i, 55, 17 );
        
    opList[ i ].style.fontFamily = 'monospace';
    opList[ i ].style.font  = 'Courier New';
    opList[ i ].style.fontSize = '1.6vh';
    opList[ i ].style.fontWeight = '600';
    opList[ i ].style.paddingLeft = '0.5vh';
    opList[ i ].style.textAlign = 'left'; 
    opList[ i ].style.cursor = 'pointer';
    settext( opList[ i ], opArr[ i ] );
    
    opList[ i ].style.visibility = 'hidden';
    
}

const drawFl = create( lft, span, '', sfont, sandy, 30, 751, 35, 22 );
settext( drawFl, 'Flags' );

const fl_ = create( lft, span, '', cfont, gray, 70, 750, 70, 22 );
settext( fl_, '' );

const drawOpComm = create( lft, span, '', sfont, sandy, 450, 760, 170, 22 );
settext( drawOpComm, 'comment to command' );

data.push( [ 150, 780, 535, 28, 400, 810, 260, 28 ] );
const opcomm_ = create( lft, input, text, lfont, white, data[ idx ++ ] );
opcomm_.value = '';
ttEN.push( " Enter a comment to the command. ");

// ................. data, constants ..............................................

const drawAssData = create( lft, span, '', lfont, sandy, 20, 830, 100, 22 );
settext( drawAssData, 'DATA' );

const drawDataAdr = create( lft, span, '', sfont, sandy, 23, 860,  22, 22 );
settext( drawDataAdr, 'Adr' );

const drawBinary = create( lft, span, '', sfont, sandy, 65, 860, 60, 22 );
settext( drawBinary, 'binary' );

const drawConAnsi = create( lft, span, '', sfont, sandy, 325, 860, 50, 22 );
settext( drawConAnsi, 'ANSI' );

const drawConComm = create( lft, span, '', sfont, sandy, 450, 860, 150, 22 );
settext( drawConComm, 'comment to data' );

const conadr = create( lft, span, '', cfont, gray, 20, 880, 28, 22 );
settext( conadr, '80' );

const conbin_ = create( lft, span, '', cfont, gray, 50, 880, 90, 22 );
settext( conbin_, '00000000' );

data.push( [ 150, 880, 72, 28, 130, 910, 680, 28 ] );
const coninp_ = create( lft, input, text, lfont, white, data[ idx ++ ] );
coninp_.value = '0';
ttEN.push( " keyboard character or decimal number -128 ... 127 or hexadecimal number hxx (also Hxx, $xx) ");
coninp_.addEventListener( 'pointerdown', onConinpPointerDown );
coninp_.addEventListener( 'input', onConinpInput );

data.push( [ 230, 860, 22, 30, 240, 830, 120, 30 ] );
const conup =  create( lft, button, '', cfont, gray, data[ idx ++ ] );
settext( conup, '‚Üë' );
ttEN.push( " RAM - Adr. back ");
conup.addEventListener( 'pointerdown', onConupPointerDown );

data.push( [ 230, 900, 22, 30, 230, 930, 140, 30 ] );
const condown =  create( lft, button, '', cfont, gray, data[ idx ++ ] );
settext( condown, '‚Üì' );
ttEN.push( " RAM - Adr. forward ");
condown.addEventListener( 'pointerdown', onCondownPointerDown );

const conalt_ = create( lft, span, '', cfont, gray, 260, 881, 46, 22 );

const conans = create( lft, span, '', cfont, gray, 320, 881, 43, 22 );

data.push( [ 370, 880, 310, 28, 400, 910, 260, 28 ] );
const concomm_ = create( lft, input, text, lfont, white, data[ idx ++ ] );
concomm_.value = '';
ttEN.push( " Enter a comment to the constant.");

const drawConHex = create( lft, span, '', csfont, sandy, 55, 911, 25, 22 );
settext( drawConHex, 'hex' );

const conhex = create( lft, span, '', cfont, gray, 82, 910, 45, 22 );
settext( conhex, '00' );

const drawHlp = create( lft, text, '',  csfont, sandy, 240, 935, 530, 22 );
settext( drawHlp, 'list of assembler commands' );

const hlp_ = create( lft, button, '', rfont, gray, 50, 955, 630, 26, );
settext( hlp_, '‚ñΩ ' );
hlp_.addEventListener( 'pointerover', onHlpPointerOver );
hlp_.addEventListener( 'pointerleave', onHlpPointerLeave );

for ( let i = 0; i < 256; i ++ ) {
    
    comment[ i ] = ';';            //  Data field also for comments on constants from line 128!
    
}

// ----------------- scenes ---------------------------

const sceneLeft = new THREE.Scene();
sceneLeft.background = new THREE.Color( sandy );

const sceneRight = new THREE.Scene();
sceneRight.background = new THREE.Color( lSandy );

const directionalLightRight = new THREE.DirectionalLight( );
directionalLightRight.intensity = 0.3;
directionalLightRight.position.set( 0 , 6 , 15 );
sceneRight.add( directionalLightRight );

// -------------------- MGA Display --------------------------------------------------

const cvMGA = document.createElement('canvas')
cvMGA.width =  896; //  7 * 128
cvMGA.height = 128;

const txtMGAGeo = new THREE.PlaneBufferGeometry( 7, 0.99 ); // 7 : 1
const ctxMGA = cvMGA.getContext( '2d' );    
const cvMGATexture = new THREE.Texture( cvMGA );
const cvMGAMaterial = new THREE.MeshBasicMaterial( { map: cvMGATexture, side: THREE.DoubleSide } );
const txtMGAMesh = new THREE.Mesh( txtMGAGeo, cvMGAMaterial );

txtMGAMesh.position.x = -8;
txtMGAMesh.position.y = 11.5;
sceneRight.add( txtMGAMesh );

const txtMGA =  '   MGA - Display';
canvasSet( cvMGATexture, ctxMGA, sandy, cvMGA.width , cvMGA.height, txtMGA ); 

const matMGA = new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.DoubleSide } );
const geoMGA = new THREE.BoxBufferGeometry( 0.49, 0.49, 0.2 );

const iMeshMGA = new THREE.InstancedMesh( geoMGA, matMGA, 64 );
iMeshMGA.name = 'MGA';
objectsToRaycast.push( iMeshMGA );

for ( let i = 0; i < 8; i ++ ) {   
    
    for ( let j = 0; j < 8; j ++ ) {
        
        iMeshMGA.setMatrixAt( i * 8 + j , M4.setPosition( j / 2, 3.5 - i / 2, 0 ) );
        iMeshMGA.setColorAt( i * 8 + j, colorWhite );
        
    }
    
}

iMeshMGA.position.set( -10, 7, 0 );
sceneRight.add( iMeshMGA );

const matMGAgrid = new THREE.MeshPhongMaterial({ color: 0xdedede, side: THREE.DoubleSide } );
const geoMGAgridH = new THREE.BoxBufferGeometry( 4, 0.02, 0.3 ); // horizontal
const geoMGAgridV = new THREE.BoxBufferGeometry( 0.02, 4, 0.3 ); // vertical

const iMeshMGAgridH = new THREE.InstancedMesh( geoMGAgridH, matMGAgrid, 9 );
const iMeshMGAgridV = new THREE.InstancedMesh( geoMGAgridV, matMGAgrid, 9 );

for ( let i = 0; i <= 8; i ++ ) {   
    
    iMeshMGAgridH.setMatrixAt( i, M4.setPosition( 0, i / 2, 0 ) );
    iMeshMGAgridV.setMatrixAt( i, M4.setPosition( i / 2, 0, 0 ) );
    
}

iMeshMGAgridH.position.set( -8.25, 6.75 , 0 );
sceneRight.add( iMeshMGAgridH );

iMeshMGAgridV.position.set( -10.25, 8.75, 0 );
sceneRight.add( iMeshMGAgridV );
 
// -------------------- CPU & RAM --------------------------------------------------

const matBox = new THREE.MeshBasicMaterial({color: 0xaaaaaa,  transparent: true,  opacity: 0.1 } );

const matDig = new THREE.MeshPhongMaterial( );
matDig.specular.setRGB( 0.4, 0.4, 0.4 );

const geoBox = new THREE.BoxBufferGeometry( 0.5, 0.85, 0.3 );
const geoDig0 = new THREE.TorusBufferGeometry( 0.2, 0.05, 36, 36 ); 
const geoDig1 = new THREE.CylinderBufferGeometry( 0.05, 0.05, 0.48, 144 );
 
// --------------------- CPU --------------------------------------

const CPU = new THREE.Object3D();
const BITx = ( x, j ) => ( x + 0.6 * j );
const RSy = ( y, i ) => ( y - i * 2 - ( i > 1 ? 1.25 : 0 ) );

// --- CPU clock ---

settextCPU( 'üïî', 90, -16, 17, 1, 1 );

const iMeshBoxCPUCLOCK  = new THREE.InstancedMesh( geoBox, matBox, 16 );
addPosReg( iMeshBoxCPUCLOCK, 16, -15, 17, visible );
CPU.add( iMeshBoxCPUCLOCK );

const iMeshDig0CPUCLOCK = new THREE.InstancedMesh( geoDig0, matDig, 16 );
CPU.add( iMeshDig0CPUCLOCK );

const iMeshDig1CPUCLOCK = new THREE.InstancedMesh( geoDig1, matDig, 16 );
CPU.add( iMeshDig1CPUCLOCK );

t0 = 65536;            // base value CPU time 2^16 ... 
t = t0;                // initialize CPU time

CPUCLOCK = '0000000000000000'; // ... only right 16 bits with 0 are displayed
rf_CPUCLOCK ( );

function rf_CPUCLOCK ( ) {
    
    for ( let j = 0; j < 16; j ++ ) {
        
        visibilityReg( iMeshDig0CPUCLOCK , -15, 17, j, visibility0( CPUCLOCK [ j ] ) );
        visibilityReg( iMeshDig1CPUCLOCK , -15, 17, j, visibility1( CPUCLOCK [ j ] ) );
        
    }
    
    iMeshDig0CPUCLOCK.instanceMatrix.needsUpdate = true;
    iMeshDig1CPUCLOCK.instanceMatrix.needsUpdate = true;
    
}


// --- 4 register  R  ( left, data & adress: D0, D1, A0, A1 ) ---

// settextCPU( text, size, x, y, w, h )
settextCPU( 'DataRegister', 90, -13.8, 15, 4.4, 0.6 );
settextCPU( 'ShadowRegister', 90, -7.9, 15, 5.1, 0.6 );

settextCPU( 'D0', 90, -16.6, 14.3, 1, 0.7 );
settextCPU( '00', 90, -10.85, 14.23, 1, 0.7 );
settextCPU( 'SD0', 90, -5, 14.3, 1.3, 0.7 );

settextCPU( 'D1', 90, -16.6, 12.3, 1, 0.7 );
settextCPU( '01', 90, -10.85, 12.3, 1, 0.7 );
settextCPU( 'SD1', 90, -5, 12.3, 1.3, 0.7 );

settextCPU( 'AddressRegister', 90, -13.9, 9.9, 5.2, 0.6 );

settextCPU( 'A0', 90, -16.6, 9.1, 1, 0.7 );
settextCPU( '10', 90, -10.85, 9.1, 1, 0.7 );
settextCPU( 'SA0', 90, -5, 9.1, 1.3, 0.7 );

settextCPU( 'A1', 90, -16.6, 7.1, 1, 0.7 );
settextCPU( '11', 90, -10.85, 7.1, 1, 0.7 );
settextCPU( 'SA1', 90, -5, 7.1, 1.3, 0.7 );

settextCPU( 'InstructionRegister - IR', 90, -9, 4.8, 9, 0.7 );
settextCPU( 'StatusRegister - SR', 90, -0.9, 4.8, 8, 0.7 );
settextCPU( 'InstructionCounter - IC', 90, -8.8, 2.8, 9, 0.7 );
settextCPU( 'I O X Y N Z V C', 80, -0.9, 3.3, 7, 0.7 );
settextCPU( 'FLAG', 85, 0.7, 2.8, 1.5, 0.7 );
settextCPU( 'Startadr.', 90, -12, 0, 3, 0.7 );
settextCPU( '- ST', 90, -4.7, 0, 2, 0.7 );
settextCPU( 'StackPointer - SP', 90, -0.7, 1, 6, 0.7 );
const regLftx = -16;
const regLfty =  13.5;

const iMeshBoxR = new THREE.InstancedMesh( geoBox, matBox, 32 ); 

for ( let i = 0; i < 4; i ++ ) {   
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityRS( iMeshBoxR, regLftx, regLfty, i, j, visible );    
        
    }
    
}

CPU.add( iMeshBoxR );

const iMeshDig0R = new THREE.InstancedMesh( geoDig0, matDig, 32 );

CPU.add( iMeshDig0R );

const iMeshDig1R = new THREE.InstancedMesh( geoDig1, matDig, 32 );

CPU.add( iMeshDig1R );

R[0] = R[1] = R[2] = R[3] = '00000000';

rf_R( 0 );
rf_R( 1 );
rf_R( 2 );
rf_R( 3 );

// --- 4 Shadow register  S  ( right, SD0, SD1, SA0, SA1 ) ---

const regRgtx = -10;
const regRgty =  13.5;

const iMeshBoxS = new THREE.InstancedMesh( geoBox, matBox, 32 ); 

for ( let i = 0; i < 4; i ++ ) {   
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityRS( iMeshBoxS, regRgtx, regRgty, i, j, visible );    
        
    }
    
}

CPU.add( iMeshBoxS );

const iMeshDig0S = new THREE.InstancedMesh( geoDig0, matDig, 32 );

CPU.add( iMeshDig0S );

const iMeshDig1S = new THREE.InstancedMesh( geoDig1, matDig, 32 );

CPU.add( iMeshDig1S );

S[0] = S[1] = S[2] = S[3] = '00000000';

rf_S( 0 );
rf_S( 1 );
rf_S( 2 );
rf_S( 3 );

// --- instruction register  IR ---
const regTy = 4;

const iMeshBoxIR  = new THREE.InstancedMesh( geoBox, matBox, 8 );
addPosReg( iMeshBoxIR, 8, regRgtx, regTy, visible );
CPU.add( iMeshBoxIR );

const iMeshDig0IR = new THREE.InstancedMesh( geoDig0, matDig, 8 );
CPU.add( iMeshDig0IR );

const iMeshDig1IR = new THREE.InstancedMesh( geoDig1, matDig, 8 );
CPU.add( iMeshDig1IR );

IR = '00000000';
rf_IR( );

function rf_IR( ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshDig0IR, regRgtx, regTy, j, visibility0( IR[ j ] ) );
        visibilityReg( iMeshDig1IR, regRgtx, regTy, j, visibility1( IR[ j ] ) );
        
    }
    
    iMeshDig0IR.instanceMatrix.needsUpdate = true;
    iMeshDig1IR.instanceMatrix.needsUpdate = true;
    
}

// --- instruction counter  IC ---
const regMy = 2;

const iMeshBoxIC = new THREE.InstancedMesh( geoBox, matBox, 8 );
addPosReg( iMeshBoxIC, 8, regRgtx, regMy, visible );

const iMeshDig0IC = new THREE.InstancedMesh( geoDig0, matDig, 8 );
CPU.add( iMeshDig0IC );

const iMeshDig1IC = new THREE.InstancedMesh( geoDig1, matDig, 8 );
CPU.add( iMeshDig1IC );

IC = '00000000';
rf_IC( );

function rf_IC( ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshDig0IC, regRgtx, regMy, j, visibility0( IC[ j ] ) );
        visibilityReg( iMeshDig1IC, regRgtx, regMy, j, visibility1( IC[ j ] ) );
        
    }
    
    iMeshDig0IC.instanceMatrix.needsUpdate = true;
    iMeshDig1IC.instanceMatrix.needsUpdate = true;
    
}

// --- start adress ST ---
const regBy = 0;

const iMeshBoxST = new THREE.InstancedMesh( geoBox, matBox, 8 );
addPosReg( iMeshBoxST, 8, regRgtx, regBy, visible );

const iMeshDig0ST = new THREE.InstancedMesh( geoDig0, matDig, 8 );
CPU.add( iMeshDig0ST );

const iMeshDig1ST = new THREE.InstancedMesh( geoDig1, matDig, 8 );
CPU.add( iMeshDig1ST );

ST = '00000000';
rf_ST( );

function rf_ST( ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshDig0ST, regRgtx, regBy, j, visibility0( ST[ j ] ) );
        visibilityReg( iMeshDig1ST, regRgtx, regBy, j, visibility1( ST[ j ] ) );
        
    }
    
    iMeshDig0ST.instanceMatrix.needsUpdate = true;
    iMeshDig1ST.instanceMatrix.needsUpdate = true;
    
}

// --- status register  SR ---
const aluLx = -3;

const iMeshBoxSR = new THREE.InstancedMesh( geoBox, matBox, 8 );
addPosReg( iMeshBoxSR, 8, aluLx, regTy, visible );

const iMeshDig0SR = new THREE.InstancedMesh( geoDig0, matDig, 8 );
CPU.add( iMeshDig0SR );

const iMeshDig1SR = new THREE.InstancedMesh( geoDig1, matDig, 8 );
CPU.add( iMeshDig1SR );

SR = '00000000';
rf_SR( );

function rf_SR( ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshDig0SR, aluLx, regTy, j, visibility0( SR[ j ] ) );
        visibilityReg( iMeshDig1SR, aluLx, regTy, j, visibility1( SR[ j ] ) );
        
    }
    
    iMeshDig0SR.instanceMatrix.needsUpdate = true;
    iMeshDig1SR.instanceMatrix.needsUpdate = true;
}

// --- stack pointer  SP ---

const iMeshBoxSP = new THREE.InstancedMesh( geoBox, matBox, 8 );
addPosReg( iMeshBoxSP, 8, aluLx, regBy, visible );

const iMeshDig0SP = new THREE.InstancedMesh( geoDig0, matDig, 8 );
CPU.add( iMeshDig0SP );

const iMeshDig1SP = new THREE.InstancedMesh( geoDig1, matDig, 8 );
CPU.add( iMeshDig1SP );

SP = '00000000';
rf_SP( );

function rf_SP( ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshDig0SP, aluLx, regBy, j, visibility0( SP[ j ] ) );
        visibilityReg( iMeshDig1SP, aluLx, regBy, j, visibility1( SP[ j ] ) );
        
    }
    
    iMeshDig0SP.instanceMatrix.needsUpdate = true;
    iMeshDig1SP.instanceMatrix.needsUpdate = true;
    
}

// -----  9 Bit Arithmetic Logic Unit  (ALU)  -----

const cvALU = document.createElement('canvas')
cvALU.width = 1280; // 10 * 128
cvALU.height = 128;

const txtALUGeo = new THREE.PlaneBufferGeometry( 10, 0.99 ); // 10 : 1
const ctxALU = cvALU.getContext( '2d' );    
const cvALUTexture = new THREE.Texture( cvALU );
const cvALUMaterial = new THREE.MeshBasicMaterial( { map: cvALUTexture, side: THREE.DoubleSide } );
const txtALUMesh = new THREE.Mesh( txtALUGeo, cvALUMaterial );

txtALUMesh.position.x = -4;
txtALUMesh.position.y = 1.5;
sceneRight.add( txtALUMesh );

const txtALU = '   Arithmetic Logic Unit ';
canvasSet( cvALUTexture, ctxALU, sandy, cvALU.width , cvALU.height, txtALU ); 

/* web variant: division not in ALU
                        //  temporary for DIV ,  hide for now ...
const ASP_DIV  = settextCPU( ' \\ DIV  ', 90, 0, 12, 6, 0.7 );
ASP_DIV.visible = false;
const fta_DIV  = settextCPU( 'f t a', 80, 6.2, 13.7, 2, 0.7 );
fta_DIV.visible = false; 
const Sg_DIV = settextCPU( 'Sg', 90, -3.7, 11.7, 1, 0.7 );
Sg_DIV.visible = false;
const S_DIV = settextCPU( 'S', 90, 7.5, 12, 0.5, 0.7 );
S_DIV.visible = false;
const D_DIV = settextCPU( 'D', 90, 7.5, 11, 0.5, 0.7 );
D_DIV.visible = false;
const N_DIV = settextCPU( 'N', 90, 7.5, 10, 0.5, 0.7 );
N_DIV.visible = false;
const P_DIV = settextCPU( 'P', 90, 7.5,  9, 0.5, 0.7 );
P_DIV.visible = false;
const L_DIV = settextCPU( 'L', 90, 7.5,  8, 0.5, 0.7 );
L_DIV.visible = false;
*/
                    //  temporary for MUL ,  hide for now ...
const A_MUL = settextCPU( 'A', 90, 7.5, 11, 0.5, 0.7 ); // at the same position as D_DIV
A_MUL.visible = false;
const S_MUL = settextCPU( 'S', 90, 7.5, 10, 0.5, 0.7 ); // at the same position as N_DIV
S_MUL.visible = false;
const x_MUL = settextCPU( 'x', 90, 7.5,  9, 0.5, 0.7 ); // at the same position as P_DIV
x_MUL.visible = false;

const Booth_MUL = settextCPU( '¬ª Booth ', 80, 6, 7, 3.5, 0.45 ); // multiplication, Booth steps
Booth_MUL.visible = false;

// --- ALU Storage 1, AL1, operand ---
const alu1y = 11;

const iMeshBoxAL1 = new THREE.InstancedMesh( geoBox, matBox, 9 );
addPosReg( iMeshBoxAL1, 9, aluLx, alu1y, visible );

const iMeshDig0AL1 = new THREE.InstancedMesh( geoDig0, matDig, 9 );
CPU.add( iMeshDig0AL1 );

const iMeshDig1AL1 = new THREE.InstancedMesh( geoDig1, matDig, 9 );
CPU.add( iMeshDig1AL1 );

AL1 = '';
rf_AL1( );

function rf_AL1( ) {
    
    for ( let j = 0; j < 9; j ++ ) {
        
        visibilityReg( iMeshDig0AL1, aluLx, alu1y, j, visibility0( AL1[ j ] ) );
        visibilityReg( iMeshDig1AL1, aluLx, alu1y, j, visibility1( AL1[ j ] ) );
        
    }
    
    iMeshDig0AL1.instanceMatrix.needsUpdate = true;
    iMeshDig1AL1.instanceMatrix.needsUpdate = true;
}

// --- ALU Storage 2, AL2, operand --- 
const alu2y = 10;

const iMeshBoxAL2 = new THREE.InstancedMesh( geoBox, matBox, 9 );
addPosReg( iMeshBoxAL2, 9, aluLx, alu2y, visible );

const iMeshDig0AL2 = new THREE.InstancedMesh( geoDig0, matDig, 9 );
CPU.add( iMeshDig0AL2 );

const iMeshDig1AL2 = new THREE.InstancedMesh( geoDig1, matDig, 9 );
CPU.add( iMeshDig1AL2 );

AL2 = '';
rf_AL2( );

function rf_AL2( ) {
    
    for ( let j = 0; j < 9; j ++ ) {
        
        visibilityReg( iMeshDig0AL2, aluLx, alu2y, j, visibility0( AL2[ j ] ) );
        visibilityReg( iMeshDig1AL2, aluLx, alu2y, j, visibility1( AL2[ j ] ) );
        
    }
    
    iMeshDig0AL2.instanceMatrix.needsUpdate = true;
    iMeshDig1AL2.instanceMatrix.needsUpdate = true;
    
}

// --- ALU Storage 3, ALC, carry ---
const alu3y = 9;

const iMeshBoxALC = new THREE.InstancedMesh( geoBox, matBox, 9 );
addPosReg( iMeshBoxALC, 9, aluLx, alu3y, visible );

const iMeshDig0ALC = new THREE.InstancedMesh( geoDig0, matDig, 9 );
CPU.add( iMeshDig0ALC );

const iMeshDig1ALC = new THREE.InstancedMesh( geoDig1, matDig, 9 ); 
CPU.add( iMeshDig1ALC );

ALC = '';
rf_ALC( );

function rf_ALC( ) {
    
    for ( let j = 0; j < 9; j ++ ) {
        
        visibilityReg( iMeshDig0ALC, aluLx, alu3y, j, visibility0( ALC[ j ] ) );
        visibilityReg( iMeshDig1ALC, aluLx, alu3y, j, visibility1( ALC[ j ] ) );
        
    }
    
    iMeshDig0ALC.instanceMatrix.needsUpdate = true;
    iMeshDig1ALC.instanceMatrix.needsUpdate = true;
}

// --- ALU Storage 4, ALR, result ---
const alu4y = 8;

const iMeshBoxALR = new THREE.InstancedMesh( geoBox, matBox, 9 );
addPosReg( iMeshBoxALR, 9, aluLx, alu4y, visible );

const iMeshDig0ALR = new THREE.InstancedMesh( geoDig0, matDig, 9 ); 
CPU.add( iMeshDig0ALR );

const iMeshDig1ALR = new THREE.InstancedMesh( geoDig1, matDig, 9 ); 
CPU.add( iMeshDig1ALR );

ALR = '';
rf_ALR( );

function rf_ALR( ) {
    
    for ( let j = 0; j < 9; j ++ ) {
        
        visibilityReg( iMeshDig0ALR, aluLx, alu4y, j, visibility0( ALR[ j ] ) );
        visibilityReg( iMeshDig1ALR, aluLx, alu4y, j, visibility1( ALR[ j ] ) );
        
    }
    
    iMeshDig0ALR.instanceMatrix.needsUpdate = true;
    iMeshDig1ALR.instanceMatrix.needsUpdate = true;
}

// ----- temporary ALU storages -----

// hidden for now  ...

const matDigTmp = new THREE.MeshPhongMaterial( { color: 0xff66dd } ); 
// matDigTmp.emissive.setRGB( 0.2, 0.2, 0.2 ); 
matDigTmp.specular.setRGB( 0.6, 0.6, 0.6 )

const aluRx = 2.6;


/*  web variant:  division not in ALU

//  ALU storage for shifting counter Dividend

const alu0y = 12;

const iMeshBoxALS = new THREE.InstancedMesh( geoBox, matBox, 8 );
CPU.add( iMeshBoxALS );

const iMeshDig0ALS = new THREE.InstancedMesh( geoDig0, matDigTmp, 8 ); 
CPU.add( iMeshDig0ALS );

const iMeshDig1ALS = new THREE.InstancedMesh( geoDig1, matDigTmp, 8 ); 
CPU.add( iMeshDig0ALS );

_ALS( hidden );

function _ALS( ShowHide ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshBoxALS, aluRx, alu0y, j, ShowHide );
        
    }
    
}

function rf_ALS( ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshDig0ALS, aluRx, alu0y, j, visibility0( ALS[ j ] ) );
        visibilityReg( iMeshDig1ALS, aluRx, alu0y, j, visibility1( ALS[ j ] ) );
        
    }
    
    iMeshDig0ALS.instanceMatrix.needsUpdate = true;
    iMeshDig1ALS.instanceMatrix.needsUpdate = true;
}

// ALU storage dividend for shift >> and shift <<

const iMeshBoxALD = new THREE.InstancedMesh( geoBox, matBox, 8 );
CPU.add( iMeshBoxALD );

const iMeshDig0ALD = new THREE.InstancedMesh( geoDig0, matDigTmp, 8 ); 
CPU.add( iMeshDig0ALD );

const iMeshDig1ALD = new THREE.InstancedMesh( geoDig1, matDigTmp, 8 ); 
CPU.add( iMeshDig0ALD );

_ALD( hidden );

function _ALD( ShowHide ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshBoxALD, aluRx, alu1y, j, ShowHide );
        
    }
    
}

function rf_ALD( ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshDig0ALD, aluRx, alu1y, j, visibility0( ALD[ j ] ) );
        visibilityReg( iMeshDig1ALD, aluRx, alu1y, j, visibility1( ALD[ j ] ) );
        
    }
    
    iMeshDig0ALD.instanceMatrix.needsUpdate = true;
    iMeshDig1ALD.instanceMatrix.needsUpdate = true;
}

// ALU storage, divisor (summand, 2's complement)

const iMeshBoxALN = new THREE.InstancedMesh( geoBox, matBox, 8 );
CPU.add( iMeshBoxALN );

const iMeshDig0ALN = new THREE.InstancedMesh( geoDig0, matDigTmp, 8 ); 
CPU.add( iMeshDig0ALN );

const iMeshDig1ALN = new THREE.InstancedMesh( geoDig1, matDigTmp, 8 ); 
CPU.add( iMeshDig1ALN );

_ALN( hidden );

function _ALN( ShowHide ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshBoxALN, aluRx, alu2y, j, ShowHide );
        
    }        
    
}

function rf_ALN( ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshDig0ALN, aluRx, alu2y, j, visibility0( ALN[ j ] ) );
        visibilityReg( iMeshDig1ALN, aluRx, alu2y, j, visibility1( ALN[ j ] ) );
        
    }
    
    iMeshDig0ALN.instanceMatrix.needsUpdate = true;
    iMeshDig1ALN.instanceMatrix.needsUpdate = true;
    
}

// ALU storage, positive divisor

const iMeshBoxALP = new THREE.InstancedMesh( geoBox, matBox, 8 );
CPU.add( iMeshBoxALP );

const iMeshDig0ALP = new THREE.InstancedMesh( geoDig0, matDigTmp, 8 ); 
CPU.add( iMeshDig0ALP );

const iMeshDig1ALP = new THREE.InstancedMesh( geoDig1, matDigTmp, 8 ); 
CPU.add( iMeshDig1ALP );

_ALP( hidden );

function _ALP( ShowHide ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshBoxALP, aluRx, alu3y, j, ShowHide );
        
    }
    
}

function rf_ALP( ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshDig0ALP, aluRx, alu3y, j, visibility0( ALP[ j ] ) );
        visibilityReg( iMeshDig1ALP, aluRx, alu3y, j, visibility1( ALP[ j ] ) );
        
    }
    
    iMeshDig0ALP.instanceMatrix.needsUpdate = true;
    iMeshDig1ALP.instanceMatrix.needsUpdate = true;
    
}
*/

// ALU storage,  result/ low byte of 16 bit for multiplication  ( web variant: division not in ALU  ) 

const iMeshBoxARL = new THREE.InstancedMesh( geoBox, matBox, 8 );
CPU.add( iMeshBoxARL );

const iMeshDig0ARL = new THREE.InstancedMesh( geoDig0, matDigTmp, 8 ); 
CPU.add( iMeshDig0ARL );

const iMeshDig1ARL = new THREE.InstancedMesh( geoDig1, matDigTmp, 8 ); 
CPU.add( iMeshDig1ARL );

_ARL( hidden );

function _ARL( ShowHide ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshBoxARL, aluRx, alu4y, j, ShowHide );
        
    }
    
}

function rf_ARL( ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshDig0ARL, aluRx, alu4y, j, visibility0( ARL[ j ] ) );
        visibilityReg( iMeshDig1ARL, aluRx, alu4y, j, visibility1( ARL[ j ] ) );
        
    }
    
    iMeshDig0ARL.instanceMatrix.needsUpdate = true;
    iMeshDig1ARL.instanceMatrix.needsUpdate = true;
    
}

// --- for multiplication ---

// ( Note! coordinates as with division )

//  ALU storage, multiplication to Booth / D0 for addition

const iMeshBoxALBA = new THREE.InstancedMesh( geoBox, matBox, 8 );
CPU.add( iMeshBoxALBA );

const iMeshDig0ALBA = new THREE.InstancedMesh( geoDig0, matDigTmp, 8 ); 
CPU.add( iMeshDig0ALBA );

const iMeshDig1ALBA = new THREE.InstancedMesh( geoDig1, matDigTmp, 8 ); 
CPU.add( iMeshDig1ALBA );

_ALBA( hidden );

function _ALBA( ShowHide ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshBoxALBA, aluRx, alu1y, j, ShowHide );
        
    }
    
}
 
function rf_ALBA( ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshDig0ALBA, aluRx, alu1y, j, visibility0( ALBA[ j ] ) );
        visibilityReg( iMeshDig1ALBA, aluRx, alu1y, j, visibility1( ALBA[ j ] ) );
        
    }
    
    iMeshDig0ALBA.instanceMatrix.needsUpdate = true;
    iMeshDig1ALBA.instanceMatrix.needsUpdate = true;
}

// ALU storage, multiplication to Booth / subtraction (2's complement)

const iMeshBoxALBS = new THREE.InstancedMesh( geoBox, matBox, 8 );
CPU.add( iMeshBoxALBS );

const iMeshDig0ALBS = new THREE.InstancedMesh( geoDig0, matDigTmp, 8 ); 
CPU.add( iMeshDig0ALBS );

const iMeshDig1ALBS = new THREE.InstancedMesh( geoDig1, matDigTmp, 8 ); 
CPU.add( iMeshDig1ALBS );

_ALBS( hidden );

function _ALBS( ShowHide ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshBoxALBS, aluRx, alu2y, j, ShowHide );
        
    }
    
}

function rf_ALBS( ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        visibilityReg( iMeshDig0ALBS, aluRx, alu2y, j, visibility0( ALBS[ j ] ) );
        visibilityReg( iMeshDig1ALBS, aluRx, alu2y, j, visibility1( ALBS[ j ] ));
        
    }
    
    iMeshDig0ALBS.instanceMatrix.needsUpdate = true;
    iMeshDig1ALBS.instanceMatrix.needsUpdate = true;
    
}

//  --- 1 bit ALU storages  for multiplication ( division ) ---

// NOTE!  Materials may not be used with InstancedMesh and other 3D objects.
const matBoxTmp1 = matBox.clone( ); 
const matDigTmp1 = matDigTmp.clone( );

const geoBoxBit = new THREE.BoxBufferGeometry( 0.5, 0.85, 0.3 );
const geoDig0Bit = new THREE.TorusBufferGeometry( 0.2, 0.05, 36, 36 );
const geoDig1Bit = new THREE.CylinderBufferGeometry( 0.05, 0.05, 0.48, 144 );

//  web version:  division not in ALU
    /* 
    const aluSx = -3.6;
    
    // ALU storeage, sign 1 for division
    
    const meshBoxAV1 = new THREE.Mesh( geoBoxBit, matBoxTmp1 );
    CPU.add( meshBoxAV1 );
    
    const meshDig0AV1 = new THREE.Mesh( geoDig0Bit, matDigTmp1 );
    CPU.add( meshDig0AV1 );
    
    const meshDig1AV1 = new THREE.Mesh( geoDig1Bit, matDigTmp1 );
    CPU.add( meshDig1AV1 );
    
    AV1 = '';
    _AV1( hidden );
    rf_AV1( );
    
    function _AV1( ShowHide ) {
        
        meshBoxAV1.position.set( aluSx, alu1y, ShowHide );
        
    }
    
    function rf_AV1( ) {
        
        meshDig0AV1.position.set( aluSx, alu1y, visibility0( AV1 ) );
        meshDig1AV1.position.set( aluSx, alu1y, visibility1( AV1 ) );
        
    }
    
    // ALU Storage, sign 2 for division
    
    const meshBoxAV2 = new THREE.Mesh( geoBoxBit, matBoxTmp1 );
    CPU.add( meshBoxAV2 );
    
    const meshDig0AV2 = new THREE.Mesh( geoDig0Bit, matDigTmp1 );
    CPU.add( meshDig0AV2 );
    
    const meshDig1AV2 = new THREE.Mesh( geoDig1Bit, matDigTmp1 );
    CPU.add( meshDig1AV2 );
    
    AV2 = '';
    _AV2( hidden );
    rf_AV2( );
    
    function _AV2( ShowHide ) {
        
        meshBoxAV2.position.set( aluSx, alu2y, ShowHide );
    }
    
    function rf_AV2( ) {
        
        meshDig0AV2.position.set( aluSx, alu2y, visibility0( AV2 ) );
        meshDig1AV2.position.set( aluSx, alu2y, visibility1( AV2 ) );
    }
    
    // ALU storage division, first pass (shift option >> at 1 over 0)
    
    const aluD1x = 5.6;
    const aluDy  = 13;
    
    const meshBoxALf = new THREE.Mesh( geoBoxBit, matBoxTmp1 );
    CPU.add( meshBoxALf );
    
    const meshDig0ALf = new THREE.Mesh( geoDig0Bit, matDigTmp1 );
    CPU.add( meshDig0ALf );
    
    const meshDig1ALf = new THREE.Mesh( geoDig1Bit, matDigTmp1 );
    CPU.add( meshDig1ALf );
    
    ALf= '';
    _ALf( hidden );
    rf_ALf( );
    
    function _ALf( ShowHide ) {
        
        meshBoxALf.position.set( aluD1x, aluDy, ShowHide );
        
    }
    
    function rf_ALf( ) {
        
        meshDig0ALf.position.set( aluD1x, aluDy, visibility0( ALf ) );
        meshDig1ALf.position.set( aluD1x, aluDy, visibility1( ALf ) );
        
    }
    
    // ALU storage division, pass second partial loop
    
    const aluD2x = 6.2;
    
    const meshBoxALt = new THREE.Mesh( geoBoxBit, matBoxTmp1 );
    CPU.add( meshBoxALt );
    
    const meshDig0ALt = new THREE.Mesh( geoDig0Bit, matDigTmp1 );
    CPU.add( meshDig0ALt );
    
    const meshDig1ALt = new THREE.Mesh( geoDig1Bit, matDigTmp1 );
    CPU.add( meshDig1ALt );
    
    ALt = '';
    _ALt( hidden );
    rf_ALt( );
    
    function _ALt( ShowHide ) {
        
        meshBoxALt.position.set( aluD2x, aluDy, ShowHide );
        
    } 
    
    function rf_ALt( ) {
        
        meshDig0ALt.position.set( aluD2x, aluDy, visibility0( ALt ) );
        meshDig1ALt.position.set( aluD2x, aluDy, visibility1( ALt ) );
        
    }
    
    // ALU storage division, addition of -abs(divisor)
    
    const aluD3x = 6.8;
    
    const meshBoxALa  = new THREE.Mesh( geoBoxBit, matBoxTmp1 );
    CPU.add( meshBoxALa );
    
    const meshDig0ALa  = new THREE.Mesh( geoDig0Bit, matDigTmp1 );
    CPU.add( meshDig0ALa );
    
    const meshDig1ALa  = new THREE.Mesh( geoDig1Bit, matDigTmp1 );
    CPU.add( meshDig1ALa );
    
    ALa = '';
    _ALa( hidden );
    rf_ALa( );
    
    function _ALa( ShowHide ) {
        
        meshBoxALa.position.set( aluD3x, aluDy, ShowHide );
        
    }
    
    function rf_ALa( ) {
        
        meshDig0ALa.position.set( aluD3x, aluDy, visibility0( ALa ) );
        meshDig1ALa.position.set( aluD3x, aluDy, visibility1( ALa ) );
        
    }
    */

// --- for multiplication ---

const aluMx = 7.4;
const aluMy = 8;

// ALU storage multiplication to Booth (extra bit after result/low byte)

const meshBoxALx  = new THREE.Mesh( geoBoxBit, matBoxTmp1 );
CPU.add( meshBoxALx );

const meshDig0ALx  = new THREE.Mesh( geoDig0Bit, matDigTmp1 );
CPU.add( meshDig0ALx );

const meshDig1ALx  = new THREE.Mesh( geoDig1Bit, matDigTmp1 );
CPU.add( meshDig1ALx );

ALx = '';
_ALx( hidden );
rf_ALx( );

function _ALx( ShowHide ) {
    
    meshBoxALx.position.set( aluMx, aluMy, ShowHide );
    
}

function rf_ALx( ) {
    
    meshDig0ALx.position.set( aluMx, aluMy, visibility0( ALx ) );
    meshDig1ALx.position.set( aluMx, aluMy, visibility1( ALx ) );
    
}

// ..................

CPU.position.x =  -6;
CPU.position.y = -12;

sceneRight.add( CPU );

// --------------------  RAM  -------------------------------------- 

const RAMx = ( j ) => (  0.6 * j + 8 );
const RAMy = ( i ) => ( 12 - i );

const RAMobj = new THREE.Object3D();
const countRAM = 2048; // = 256 * 8;  256 Byte RAM

// RAM content initialize

for ( let i = 0; i < 256; i ++ ) {

    bin8 = d255_to_bin8( i );
    hex2 = dec_to_hex2( i );
    ass = i < 128 ? 'NOP': '0    h00';
    
    // 245 base address STACKPOINTER, 246 buffer byte for keypad, 247 MGA display pixel, then MGA display line (1 to 8)  
    fl = i < 245 ? '': ( i === 245 ? '<-SP' : ( i === 246 ? '->Ta' : ( i === 247 ? '->Pix' : 'row'+ ( i - 247 ) ) ) );
    
    //   Adr. binary, hex,   content, assembler, flags
    ramr = [ bin8, hex2, '00000000', ass, fl ];
    
    RAM.push( ramr ) ;
    
}

// ----------------  RAM header -----------------

const cvHead = document.createElement('canvas');
cvHead.width = 2432; //  19 * 128
cvHead.height = 128;

const txtHeadGeo = new THREE.PlaneBufferGeometry( 19, 0.99 ); // 19 : 1 
const ctxHead = cvHead.getContext( '2d' );    
const cvHeadTexture = new THREE.Texture( cvHead );
const cvHeadMaterial = new THREE.MeshBasicMaterial( { map: cvHeadTexture, side: THREE.DoubleSide } );
const txtHeadMesh = new THREE.Mesh( txtHeadGeo, cvHeadMaterial );
txtHeadMesh.position.x = 12;
txtHeadMesh.position.y = 13;
RAMobj.add( txtHeadMesh );

const txtHead =  ' Adress   hex    Content      Command/Value  Flag';
canvasSet( cvHeadTexture, ctxHead, sandy, cvHead.width , cvHead.height, txtHead ); 

// ----------------- RAM-adress ----------------- 

const cvAdrW =  576; //  cvAdrH * 4.5
const cvAdrH = 128;
const txtAdrGeo = new THREE.PlaneBufferGeometry( 4.5, 0.99 ); // 4.5 : 1

let cvAdr = [];
let ctxAdr = [];
let cvAdrTexture = [];
let cvAdrMaterial = [];
let txtAdrMesh = [];
let txtAdr;

for ( let i = 0; i < 256 ; i ++ ) {
    
    cvAdr.push( document.createElement('canvas') );
    cvAdr[ i ].width = cvAdrW;
    cvAdr[ i ].height = cvAdrH;
    
    ctxAdr.push( cvAdr[ i ].getContext( '2d' ) );
    
    cvAdrTexture.push( new THREE.Texture( cvAdr[ i ] ) );
    cvAdrMaterial.push( new THREE.MeshBasicMaterial( { map: cvAdrTexture[ i ], side: THREE.DoubleSide } ) );
    
    txtAdrMesh.push( new THREE.Mesh( txtAdrGeo, cvAdrMaterial[ i ] ) );
    txtAdrMesh[ i ].position.x = 4.8;
    txtAdrMesh[ i ].position.y = - i + 12;
    RAMobj.add( txtAdrMesh[ i ] );
     
    txtAdr = RAM[ i ][ 0 ].padEnd( 10 ) + RAM[ i ][ 1 ];
    canvasSet( cvAdrTexture[i], ctxAdr[i], lSandy, cvAdrW, cvAdrH, txtAdr ); 
    
}

// ----------------- RAM-assembler ----------------- 

const cvAssW = 1024 ; // 128 * 8
const cvAssH =  128;
const txtAssGeo = new THREE.PlaneBufferGeometry ( 8, 0.99 ); // 8 : 1

let cvAss = [];
let ctxAss = [];
let cvAssTexture = [];
let cvAssMaterial = [];
let txtAssMesh = [];
let txtAss;

for ( let i = 0; i < 256 ; i ++ ) {

    cvAss.push( document.createElement('canvas') );
    cvAss[ i ].width = cvAssW;
    cvAss[ i ].height = cvAssH;
    
    ctxAss.push( cvAss[ i ].getContext( '2d' ) );
    
    cvAssTexture.push( new THREE.Texture( cvAss[ i ] ) );
    cvAssMaterial.push( new THREE.MeshBasicMaterial( { map: cvAssTexture[ i ], side: THREE.DoubleSide } ) );
    
    txtAssMesh.push( new THREE.Mesh( txtAssGeo, cvAssMaterial[ i ] ) );
    txtAssMesh[ i ].position.x = 17.4;
    txtAssMesh[ i ].position.y = - i + 12;
    txtAssMesh[ i ].name = 'line';
    objectsToRaycast.push( txtAssMesh[ i ] );
    RAMobj.add( txtAssMesh[ i ] );
     
    txtAss = RAM[ i ][ 3 ].padEnd( 16 ) + RAM[ i ][ 4 ];
    canvasSet( cvAssTexture[i], ctxAss[i], lSandy, cvAssW, cvAssH, txtAss );
    
}

//  ------------------ RAM - binary data ------------------------------

const iMeshBoxRAM  = new THREE.InstancedMesh( geoBox, matBox, countRAM );
positionRAM( iMeshBoxRAM, visible );
RAMobj.add( iMeshBoxRAM );

const iMeshDig0RAM = new THREE.InstancedMesh( geoDig0, matDig, countRAM );
positionRAM( iMeshDig0RAM, visible );
RAMobj.add( iMeshDig0RAM );

const iMeshDig1RAM = new THREE.InstancedMesh( geoDig1, matDig, countRAM );
positionRAM( iMeshDig1RAM, hidden );
RAMobj.add( iMeshDig1RAM );

RAMobj.position.x = 0;
RAMobj.position.y = posRAMy;

sceneRight.add( RAMobj );
 
// ---------------------- RAM - up down ---------------------------------

const matRAMupDown = new THREE.MeshPhongMaterial( { color: lGray, transparent: true, opacity: 0.5, wireframe: false } );

const RAMup = new THREE.Group( );
const geoRAMupCyl = new THREE.CylinderBufferGeometry( 0.2, 0.2, 6, 6, 1 );
const meshRAMupCyl = new THREE.Mesh( geoRAMupCyl, matRAMupDown );
meshRAMupCyl.name = 'up';
RAMup.add( meshRAMupCyl );
objectsToRaycast.push( meshRAMupCyl );
const geoRAMupCone = new THREE.CylinderBufferGeometry( 0, 0.4, 1.6, 6, 1 );
const meshRAMupCone = new THREE.Mesh( geoRAMupCone, matRAMupDown );
meshRAMupCone.name = 'up';
meshRAMupCone.position.y = 3.8;
RAMup.add( meshRAMupCone );
objectsToRaycast.push( meshRAMupCone );
RAMup.position.x = RAMobj.position.x + 22;
RAMup.position.y = 4;
sceneRight.add( RAMup );

const RAMdown = new THREE.Group( );
const geoRAMdownCyl = new THREE.CylinderBufferGeometry( 0.2, 0.2, 6, 6, 1 );
const meshRAMdownCyl = new THREE.Mesh( geoRAMdownCyl, matRAMupDown );
meshRAMdownCyl.name = 'down';
RAMdown.add( meshRAMdownCyl );
objectsToRaycast.push( meshRAMdownCyl );
const geoRAMdownCone = new THREE.CylinderBufferGeometry( 0.4, 0.0, 1.6, 6, 1 );
const meshRAMdownCone = new THREE.Mesh( geoRAMdownCone, matRAMupDown );
meshRAMdownCone.name = 'down';
meshRAMdownCone.position.y = -3.8;
RAMdown.add( meshRAMdownCone );
objectsToRaycast.push( meshRAMdownCone );
RAMdown.position.x =  RAMobj.position.x + 22;
RAMdown.position.y = -4;
sceneRight.add( RAMdown );

// -----------------  cameras  -----------------------------------------

const aspectLeft = widthLeft / heightLeft; 
const cameraLeft = new THREE.OrthographicCamera( -aspectLeft, aspectLeft, 1, -1, 0.01, 1000 );
cameraLeft.position.set( 5, 10, 50 );

const aspectRight  = containerRight.clientWidth / containerRight.clientHeight;
const cameraRight = new THREE.PerspectiveCamera( 55, aspectRight, 0.01, -hidden / 2  );
cameraRight.position.set( 0, 0, 26.5 );

// -----------------  renderer  -----------------------------------------

const rendererLeft = new THREE.WebGLRenderer( { antialias: true } );

rendererLeft.setSize( lft.clientWidth, lft.clientHeight );

rendererLeft.setPixelRatio( window.devicePixelRatio );

lft.appendChild( rendererLeft.domElement );

const rendererRight = new THREE.WebGLRenderer( { antialias: true } );

rendererRight.setSize( containerRight.clientWidth, containerRight.clientHeight );

rendererRight.setPixelRatio( window.devicePixelRatio );

containerRight.appendChild( rendererRight.domElement );

// --------------------------------------------------------------------

new OrbitControls( cameraRight, rendererRight.domElement ); // module without THREE.

window.addEventListener( 'resize', onWindowResize );

window.addEventListener('keydown', onWindowKeyDown );
window.addEventListener('keyup', onWindowKeyUp );

lft.addEventListener( 'pointermove', onLftPointerMove );

 // --- initialize ---

coderow = 0;
conrow = 128;
oc = '00000000';

const clock = new THREE.Clock( );
let t_ = clock.getElapsedTime( );
let dt;

// Stats:
let progAss;    // programming assembler, knob green
let progRuns;   // program running, knob gray  
let cmdExec;    // command is executed
let nextCmd;    // new command can be executed
 
let onInput;    // during user input
let finInput;   // after finishing the user input

let onAdd;      // during addition
let addPart;    // during addition part 1, 2
let goAdd;

let mulBitstepPart; //during multiplication
let goMULbitstepPart;

let onADDbitstep;
let onCOMPLbitstep;
let onANDORbitstep;
let onBTSbitstep;
let onMULbitstep;
let onMULbitstepPart;

let bitstep;  

let cmd;
let goCmd;
let goRCL1 = false;
let delay;
let bitdelay;

initializeProgramStatus( )
 
// ============================================================================
 
animate( );

// ============================================================================

function animate() {
    
    requestAnimationFrame( animate );
    
    // events to the MGA Display  
    mk = '0';          // default: no mouse button was pressed (status)     
    refresh_mga( );
       
    RAMobj.position.y = posRAMy;  // RAM object positioning
    
    if ( progAss ) { // programming assembler
        
        takt = gettext( takt_scroll ).val( );       // scrollrange
        
        displayTakt( );
        
        mn = gettext( mn_ );                        // mnemonic
        op1 = gettext( op1_ );                      // operand 1
        op2 = gettext( op2_ );                      // operand 2
        
        opcomm = gettext( opcomm_ ).trim( );    // Comment on command
        
        coninp = gettext( coninp_ );
        concomm = gettext( concomm_ ).trim( );  // Comment on constant 
        
        assembler_to_binary_code( );
        define_constant( );
        
        rf_binRAM( ramrow );                 // refresh binary content  3D RAM        
        rf_assFlagsRAM( ramrow, lGray );     // mark command row in RAM
        
        rel_value( );    // edit shift value for assembler in RAM 
        
    }
    
    if ( progRuns ) {  // binary code runs
    
        get_pulse( );
        
        if ( !cmdExec && nextCmd  && halt === 0 ) {
        
            decode_binary( ); // decode binary machine instruction and execute it
        
        }
        
        if ( !cmdExec && !nextCmd ) { // wait until further command is to be executed 
            
            dt = clock.getElapsedTime( ) - t_;
            nextCmd = dt < delay ? false : true;
            
        }
        
        // a command is executed 
        
        if ( cmdExec ) {
        
            if ( onInput ) make_input( );
            if ( finInput ) finalize_input( );
            
            if ( onADDbitstep ) {
            
                dt = clock.getElapsedTime( ) - t_;
                bitstep = dt < bitdelay ? false : true;
                
                if ( bitstep && addBit < 9 ) {
                    
                    bitAddition( ); 
                    addBit ++;       // previous, higher value bit
                    t_ = clock.getElapsedTime( );
                    
                }
                
                if ( addBit === 9 ) {
                    
                    onADDbitstep = false;
                    onAdd = true;
                    t_ = clock.getElapsedTime( );
                    
                }
                
            }
            
            if ( onCOMPLbitstep ) {
                
                dt = clock.getElapsedTime( ) - t_;
                bitstep = dt < bitdelay ? false : true;
                
                if ( bitstep && bit > 1 ) { //  => ALU_bitstep
                    
                    complementBit( );
                    bit --;
                    t_ = clock.getElapsedTime( );
                    
                }
                
                if ( bit === 1 ) {
                    
                    onCOMPLbitstep = false;
                    t_ = clock.getElapsedTime( );
                    
                } 
                
            }
            
            if ( onANDORbitstep ) {
                
                dt = clock.getElapsedTime( ) - t_;
                bitstep = dt < bitdelay ? false : true;
                
                if ( bitstep && bit > 1 ) { //  => ALU_bitstep
                    
                    bitAndOr( );
                    bit --;
                    t_ = clock.getElapsedTime( );
                    
                }
                
                if ( bit === 1 ) {
                    
                    onANDORbitstep = false;
                    _AND_OR1( );
                    
                } 
                
            }
            
            if ( onBTSbitstep ) {
                
                dt = clock.getElapsedTime( ) - t_;
                bitstep = dt < bitdelay ? false : true;
                
                if ( bitstep && bit > 1 ) { //  => ALU_bitstep
                    
                    bittest( );
                    bit --;
                    t_ = clock.getElapsedTime( );
                    
                }
                
                if ( bit === 1 ) {
                    
                    onBTSbitstep = false;
                    _BTS1( );
                    
                }
                
            }
            
            if ( onMULbitstep && !onMULbitstepPart ) { //
                
                dt = clock.getElapsedTime( ) - t_;
                bitstep = dt < bitdelay ? false : true;
                
                if ( bitstep && mulBit < 8 ) { //  => ALU_bitstep
                    
                    mulBit ++;
                    mul_clearReg( );  //  start, several substeps attached
                    
                    mulBitstepPart ='setb1b2';
                    onMULbitstepPart = true;
                    goMULbitstepPart = false;
                    t_ = clock.getElapsedTime( );
                    
                }
                
                if ( mulBit === 8 ) {
                    
                    onMULbitstep = false;
                    onMULbitstepPart = false;
                    goCmd = true;
                    cmd = 'MUL6';
                    
                }
                
            }
            
            if ( onMULbitstep && onMULbitstepPart && !goMULbitstepPart && !onAdd && !onADDbitstep ) {
                
                dt = clock.getElapsedTime( ) - t_;
                goMULbitstepPart = dt < bitdelay ? false : true;
                
            }
            
            if ( mulBitstepPart === 'setb1b2' && goMULbitstepPart ) {
                
                mul_setb1b2( );
                
                mulBitstepPart = 'extraStep';
                goMULbitstepPart = false;
                t_ = clock.getElapsedTime( );
                
            }
            
            if ( mulBitstepPart === 'extraStep' && goMULbitstepPart ) {
                
                mul_extraStep( ); 
                
                mulBitstepPart = 'addSection';
                goMULbitstepPart = false;
                t_ = clock.getElapsedTime( );
                
            }
            
            if ( mulBitstepPart === 'addSection' && goMULbitstepPart ) {
                
                mul_addSection( );
                
                goMULbitstepPart = false;
                mulBitstepPart = 'shift';
                t_ = clock.getElapsedTime( );
                
                
                
            }
            
            if ( mulBitstepPart === 'shift' && goMULbitstepPart ) {
                
                mul_shift( );
                
                mulBitstepPart = '';
                goMULbitstepPart = false;
                onMULbitstepPart = false;
                t_ = clock.getElapsedTime( );
                
            }
            
            if ( onAdd && !goAdd ) {
                
                dt = clock.getElapsedTime( ) - t_;
                goAdd = dt < delay ? false : true;
                
            }
            
            if ( addPart === '1' && goAdd ) {
                
                add_ALU_9_1( );
                addPart = '2';
                
            }
            
            if ( addPart === '2' && goAdd ) {
                
                add_ALU_9_2( );
                addPart = '';
                
                goAdd = false;
                onAdd = false;
                
            }
            
            if ( !onCOMPLbitstep && !onAdd && !onMULbitstepPart && !onInput && !finInput && !goCmd ) {
                
                dt = clock.getElapsedTime( ) - t_;
                goCmd = dt < delay ? false : true;
                
            }
            
            if ( cmd === 'CMP1' && goCmd ) _CMP1( );
            if ( cmd === 'CMP2' && goCmd ) _CMP2( );
            if ( cmd === 'CMP3' && goCmd ) _CMP3( );
            if ( cmd === 'CMP4' && goCmd ) _CMP4( );
            
            if ( cmd === 'MUL1' && goCmd ) _MUL_Booth_ALU1( );
            if ( cmd === 'MUL2' && goCmd ) _MUL_Booth_ALU2( );
            if ( cmd === 'MUL3' && goCmd ) _MUL_Booth_ALU3( );
            if ( cmd === 'MUL4' && goCmd ) _MUL_Booth_ALU4( );
            if ( cmd === 'MUL5' && goCmd ) _MUL_Booth_ALU5( );
            if ( cmd === 'MUL6' && goCmd ) _MUL_Booth_ALU6( );
            
            if ( cmd === 'SHL1' && goCmd ) _SHL1( );
            if ( cmd === 'SHR1' && goCmd ) _SHR1( );
            if ( cmd === 'ROL1' && goCmd ) _ROL1( );
            if ( cmd === 'ROR1' && goCmd ) _ROR1( );
            
            if ( cmd === 'INC_DEC1' && goCmd ) _INC_DEC1( );
            
            if ( cmd === 'NOT1' && goCmd ) _NOT1( );
            if ( cmd === 'NOT2' && goCmd ) _NOT2( );
            
            if ( cmd === 'ADD1' && goCmd ) _ADD1( );
            
            if ( cmd === 'SUB1' && goCmd ) _SUB1( );
            if ( cmd === 'SUB2' && goCmd ) _SUB2( );
            if ( cmd === 'SUB3' && goCmd ) _SUB3( );
            if ( cmd === 'SUB4' && goCmd ) _SUB4( );
            
            if ( cmd === 'RCL1' && goRCL1 ) _RCL1( ); // wait until asynchronous loading is finished
        }
        
        if ( stop === 1 ) {
            
            rf_assFlagsRAM( prevrow );
            onAbrPointerDown( );
            
        }
        
    }

    if( prevrow !== ramrow  ) {
            
            rf_assFlagsRAM( prevrow );
            prevrow = ramrow;
            
    }
    
    rendererLeft.render( sceneLeft, cameraLeft );
    rendererRight.render( sceneRight, cameraRight );

}

//   -----  status  -----

function initializeProgramStatus( ) {
    
    ramrow = 0;             // row number in RAM
    prevrow = 0;            // previous row number
    coderow    = 0;         // number Command row (from h00 is default)
    ic_dec     = 0;         // decimal value Instruction Counter IC
    ic_dec_fl  = 0;         // decimal IC - remember to enter the flags set by the command
    conrow     = 128;       // number constant row
    starow     = 245;       // default, stack row (base address)
    ramshift   = 0;         // shifting assembler in RAM
    halt       = 0;         // program paused (by operator): 1
    stop       = 0;         // after STP command or error: 1
    breakit    = 0;         // operator abort with X STOP: 1
    break123   = 0;         // after one of the three breakpoints: 1
    
    onestep    = 0;         // clicked on next for single step: 1
    nospeed    = 0;         // program execution in single step: 1
    afterstep  = 0;         // after program execution in single step: 1 (to restore status start knob)
    fullspeed  = 0;         // from > 255Hz fullspeed = 1 (remember, no stop, reduce clock if necessary)
    inp_OkClicked = false;  // End user input during program run.
    
    progAss = true;         // programming assembler, knob green
    progRuns = false;       // Program running, knob gray  
    cmdExec = false;        // Command is executed
    nextCmd = true;         // new command can be executed
    
    onInput = false;        // during user input
    finInput = false;       // after completion of the user input
    
    onAdd = false;          // during addition
    addPart = '';           // during addition part 1, 2
    goAdd = false;
    
    mulBitstepPart = '';    // during multiplication
    goMULbitstepPart = false;
    
    onADDbitstep = false;
    onCOMPLbitstep = false;
    onANDORbitstep = false;
    onBTSbitstep = false;
    onMULbitstep = false;
    onMULbitstepPart = false;
    
    bitstep = false;
    
    cmd = '';
    goCmd = false;
    
}


// -----  event handling  -----

function onStartbinPointerDown( event ) {
    
    if (  nospeed === 0 ) {
    
        if ( progRuns ) {
        
            if ( halt === 0 ) {
                
                drawRunStatus.style.color = green;
                settext( drawRunStatus, 'run further' );
                startbin.style.background = yellow;
                
                hide( inp_ );
                hide( inpKey_ );
                
                cIC = bin8_to_hex2( IC );
                set_hexIC.value = cIC ;                 // current IC hexadecimal in edit control
                settext( drawSet_IC, cIC + ' current' );
                show_set_IC( );                         // show to reset IC if necessary, "manual" command sequence
                
                show( drawSTOP );
                show( abr );
                
                halt = 1;
                
            } else  {
                
                show( inpKey_ );
                
                hide_set_IC( );
                hide( drawSTOP );
                hide( abr );
                
                drawRunStatus.style.color = dred;                // dark red font
                settext( drawRunStatus, 'halt again' );
                startbin.style.background = gray;                // run knob gray
                
                halt = 0;
                
            }
            
        }
        
    } 
    
    if ( !progRuns ) {
        
        run_binary_code( );     // <--- start machine program (binary code HC680)
        
    }
    
}

function onAbrPointerDown( event ) {
    
    progRuns = false;
    progAss = true;
    breakit = 1;
    stop = 1;
    
    rf_assFlagsRAM( ramrow ); // remove marking
    
    ic_dec = 0;
    set_IC( );
    
    initializeProgramStatus( );
    show( xram );
    show( xflag );
    show_assembler_controls( );
    
    drawRunStatus.style.color = black;
    settext( drawRunStatus, 'execute' );
    startbin.style.background = green;
    
    hide( abr );
    hide( drawSTOP );
    hide( nextstep );
    
    show( clrio );
    
}

function onHlpPointerOver ( event ) {
    
    assl.style.top = '3vh'; // visible
    
}

function onHlpPointerLeave ( event ) {
    
    assl.style.top = '100vh'; // not visible
    
}

function onContainerRightPointerDown( event ) {

        mouse.x = ( ( event.clientX - lft.clientWidth ) / containerRight.clientWidth ) * 2 - 1;
        mouse.y = -( event.clientY / containerRight.clientHeight ) * 2 + 1;
        
        raycaster.setFromCamera( mouse, cameraRight );
        intersects = raycaster.intersectObjects( objectsToRaycast );
        
        if ( intersects.length > 0 ) {                            //  cutting object
        
            if ( intersects[0].object.name === 'up' ) {
                
                posRAMy  = posRAMy > -4 ? posRAMy - 16 : posRAMy;
                
            }
            
            if ( intersects[0].object.name === 'down' ) {
                
                posRAMy = posRAMy < 224 ? posRAMy + 16 : posRAMy;
                
            }
            
            if( progAss && intersects[0].object.name === 'line' ) {
                
                ramrow = -intersects[0].object.position.y + 12;    // intersects[0].object - first cutting object
                
                restore_from_RAM( );    // restore command or constant from RAM with comment
                    
            }
            
            if (  intersects[0].object.name === 'MGA' ) {
                
                mk = '1';                                    // mouse button was pressed (status)
                click_mga( intersects[ 0 ].instanceId );     // click in the MGA display
                
            }
            
        }
        
}

function onToClipboardPointerDown( event ) {
    
    hcxTextArea.select( );
    document.execCommand( "Copy" );
    toClipboard.style.color = dred;
    
}

function onInp_okPointerDown( event ) {
    
    inp_OkClicked = true;
    onInput = false;
    finInput = true;
    
}

function onShioChange( event ) {
    
    if ( shio.checked ) {
        
        show( IO );
        show( drawClrio );
        show( clrio );
        
    } else {
        
        hide( IO );
        hide( drawClrio );
        hide( clrio );
        
    }
    
}

function onNextstepPointerDown( event ) {   
   
    if( gettext( takt_scroll ).val( ) === 0 ) {  // scrollrange
        
        nospeed = 1;  // single step
        onestep = 1;  // one command forward;
        
    } else {
        
        nospeed = 0;    // variable takt
        afterstep = 1;  // status start knob recovery
        
    } 
    
    if ( break123 === 1 ) {
        
        break123 = 0; 
        afterstep = 1; // status start knob recovery
    }
   
    halt = 0;       // keep going
    
}

function onSetICpointerdown ( ) {
    
    rf_assFlagsRAM( ramrow ); // remove marking
    
    const set = gettext( set_hexIC );  
    ramrow = set.hdec( );
    
    IC = hex2_to_bin8( set ); //  set IC with possibly changed value 
    rf_IC( );
    
    settext( drawSet_IC, cIC + ' before' );
    
    rf_assFlagsRAM( IC.bdec( ), lGray );   
    
}

function onXramPointerDown( event ) {
    
    RAM_delete( ); // clear RAM, comments and current flags
    
}

function onXflagPointerDown( event ) {
    
    flag_delete( ); // delete current flags
    
}

function onCodeupPointerDown( event ) {    //  program row up
    
    if ( coderow > 0 ) {                 // with boundary check command row >= 0
        
        coderow --;
        ramrow = coderow;                            // current command row
        clr_hide12( );
        restore_instruction( );                      // set mnemonic Op1,2 and comment in input edits
        settext( cadr, dec_to_hex2( coderow ) );     // fill in code address hexadecimal
        
    }
    
    mnListHide( );
    opListHide( );
    
}

function onCodedownPointerDown( event ) { //  program row down
    
    if ( coderow < 127 ) {                    // with boundary check command row < h80
        
        coderow ++;
        ramrow = coderow;                               // current command row    
        clr_hide12( );
        restore_instruction( );                         // set mnemonic Op1,2 and comment in input edits
        settext( cadr, dec_to_hex2( coderow ) );        // fill in code address hexadecimal
        
    }
    
    mnListHide( );
    opListHide( );
    
}

function onMnPointerDown( event ) {
    
    ramrow = coderow;    // current command row
    mnListHide( );
    opListHide( );
    assembler_to_binary_code( );
    
}

function onMnInput( event ) {
    
    ramrow = coderow;    // current command row
    mnListHide( );
    opListHide( );    
    assembler_to_binary_code( );
    
} 

function onMnShowPointerDown( event ) {
    
    ramrow = coderow;    // current command row
    opListHide( );
    
    if ( mnVisible ) {
        
        mnListHide( );
        
    } else {
        
        mnListOutline.style.visibility = 'visible';
        
        for ( let i = 0; i < 41; i ++ ) {
            
            mnList[ i ].style.visibility = 'visible';
            
        }
        
        mnVisible = true;
        opListHide( );
        tt.style.visibility = 'hidden';
        
    }
        
}

function onMnListMove( event ) {
    
    const y = event.clientY / lch * 1000 - 19;
    
    for ( let i = 0; i < 41; i ++ ) {
        
        if (  y > 17 * i && y  < 17 * ( i + 1 ) ) {
            
            mnList[ i  ].style.background = gray;
            
        } else {
                
            mnList[ i ].style.background = white;
         
        }
        
    }
    
}

function onMnListPointerDown( event ) {
    
    const y = event.clientY / lch * 1000 - 19;
    
    for ( let i = 0; i < 41; i ++ ) {
        
        if (  y > 17 * i && y  < 17 * ( i + 1 ) ) {
            
            mn_.value = mnArr[i];
            
        }
        
    }
    
    assembler_to_binary_code( );
    
    mnListHide( );
    
}

function onOp1PointerDown( event ) {
    
    mnListHide( );
    opListHide( );
    assembler_to_binary_code( );
    
}

function onOp1Input( event ) {
    
    opListHide( );
    assembler_to_binary_code( );
    
} 

function onOp1ShowPointerDown( event ) {
    
    if ( op1Visible ) {
        
        opListHide( );
        
    } else {
        
        opListOutline.style.left = vhu( 270 / 10 );
        
        opListShow( );
        
        op1Visible = true;
        op2Visible = false;
        mnListHide( );
        tt.style.visibility = 'hidden';
        
    }
    
}

function onOp2PointerDown( event ) {
    
    mnListHide( );
    opListHide( );
    assembler_to_binary_code( );
    
}

function onOp2Input( event ) {
    
    opListHide( );
    assembler_to_binary_code( );
    
} 

function onOp2ShowPointerDown( event ) {
    
    if ( op2Visible ) {
        
        opListHide( );
        
    } else {
        
        opListOutline.style.left = vhu( 360 / 10 );
         
        opListShow( );
        
        op1Visible = false;
        op2Visible = true;
        mnListHide( );
        tt.style.visibility = 'hidden';
        
    }
    
}

function onOpListMove( event ) {
    
    const y = event.clientY / lch * 1000 - 180;
    
    for ( let i = 0; i < 32; i ++ ) {
        
        if (  y > 17 * i && y  < 17 * ( i + 1 ) ) {
            
            opList[ i  ].style.background = gray;
            
        } else {
            
            opList[ i ].style.background = white;
         
        }
        
    }
    
}

function onOpListPointerDown( event ) {
    
    const y = event.clientY / lch * 1000 - 180;
    
    for ( let i = 0; i < 32; i ++ ) {
        
        if (  y > 17 * i && y  < 17 * ( i + 1 ) ) {
            
            if ( op1Visible )  op1_.value = opArr[i];
            if ( op2Visible )  op2_.value = opArr[i];
            
        }
        
    }
    
    assembler_to_binary_code( );
    
    opListHide( );
    
}

function onConupPointerDown( event ) {
     
    if ( conrow > 128 ) {            // with boundary check 
        
        conrow --;
        ramrow = conrow;            // current row
        restore_const( );            // set constant (input) with comment
        
        mnListHide( );
        opListHide( );
        
    }
}

function onCondownPointerDown( event ) {
    
    conrow ++;
    ramrow = conrow;            // current row
    restore_const( );            // set constant (input) with comment
    
    mnListHide( );
    opListHide( );
    
}

function onConinpPointerDown( event ) {    
        
    ramrow = conrow;            // current row    
    mnListHide( );
    opListHide( );
    define_constant( );
    
}

function onConinpInput( event ) {

    ramrow = conrow;            // current row    
    mnListHide( );
    opListHide( );
    define_constant( );
    
}

function onLftPointerMove( event ) {
    
    if ( !mnVisible && !op1Visible && !op2Visible ) {
        
        const x = event.clientX / lch * 1000;
        const y = event.clientY / lch * 1000;
        
        let idx = null;        
            
        for ( let i = 0; i < data.length; i ++ ) {
            
            if ( x > data[ i ][0] && x < data[ i ][0] + data[ i ][2] && y > data[ i ][1] && y < data[ i ][1] + data[ i ][3] ) {
                
                idx = i; // Index Tooltip
                
            }
            
        }
        
        if ( idx === null ) {
            
            tt.style.visibility = 'hidden';
            
        } else {
                
            tt.style.left   = vhu( data[ idx ][4] / 10 );
            tt.style.top    = vhu( data[ idx ][5] / 10 );
            tt.style.width  = vhu( data[ idx ][6] / 10 );
            tt.style.height = vhu( data[ idx ][7] / 10 );
            
            settext( tt, ttEN[ idx ] );
            
            tt.style.visibility = 'visible';
            
        }
        
    }
    
}

function onWindowKeyDown( event ) {
    
    if( progRuns && halt === 0 && !onInput ) {
    
        let key = event.key;    
        let noChr = false;
        
        for ( let i = 0; i < noChars.length; i ++ ) {
            
            noChr = noChr || ( key === noChars[ i ] );
            
            if ( noChr ) break;
            
        }
        
        if ( !noChr ) {
            
            key = key[0];                                // important for dead keys 'Dead'
            settext( inpKey_, key );                    // ... character in key input
            
            btmp = d255_to_bin8( key.ord( ) );
            settext( altinp_, key.ord( ) > 127 ? bin8_to_dec( btmp ).str( ) : '' );    // display value of the character 
            
            settext( binp_, btmp );                          // display binary
            settext( hinp_, "h" + bin8_to_hex2( btmp ) );    // display hexadecimal
            settext( ans_, key );                            // display ANSI
            RAM[ 246 ][2] = btmp;                            // RAM Addr 246 = hF6, enter in binary form ...
            rf_binRAM( 246 );
            RAM[ 246 ][3] = key + "    h" + bin8_to_hex2( btmp );    // ... fill in character and value hexadecimal
            rf_assFlagsRAM( 246 );
            
        }
        
    }
    
}

function onWindowKeyUp( event ) {
    
    
    key = ''; // reset keyCode
    
}

function onWindowResize( ) { // resize( )
    
    wiw = window.innerWidth;
    wih = window.innerHeight;
    
    lcw = lft.clientWidth;
    lch = lft.clientHeight; 
    
    cameraRight.aspect = containerRight.clientWidth / containerRight.clientHeight;
    cameraRight.updateProjectionMatrix();
    
    rendererLeft.setSize( lcw, lch );
    rendererRight.setSize( containerRight.clientWidth, containerRight.clientHeight );
    
}

// ----- Surface, GUI ----- 

function create( parent, element, type, controlFont, background, left, top, width, height ) {
    
    let l, t, w, h;
    
    if ( Array.isArray( left ) ) {
        
        l = left[ 0 ] / 10;
        t = left[ 1 ] / 10;
        w = left[ 2 ] / 10;
        h = left[ 3 ] / 10;
        
    } else {
        
        l = left / 10;
        t = top / 10;
        w = width / 10;
        h = height / 10;
        
    }
    
    const elm = document.createElement( element );
    
    if ( type !== '' ) elm.setAttribute( 'type', type );
    
    elm.style.position = 'absolute';
    elm.style.margin = '0vh';
    elm.style.padding = '0vh';
    elm.style.overflow = 'hidden';
    
    if ( element === button ) {
    
        elm.style.border = '0.1vh solid gray';
        elm.style.borderRadius = '0.33vh';
        
    } else if ( element === tr ) {
        
        elm.style.borderLeft = '0.2vh solid #eeeed3';
        elm.style.borderBottom = '0.1vh solid #eeeed3';
        
    } else if ( element === td ) {
        
        elm.style.borderRight = '0.2vh solid #eeeed3';
                
    } else if ( element === input && type === text ) {
        
        elm.style.border = '0.1vh solid gray';    
        
    } else if ( element === input && type === range ) {
        
        elm.setAttribute( 'class', 'slider' );
        elm.setAttribute( 'min', '0' );
        elm.setAttribute( 'max', '255' );
        elm.setAttribute( 'value', '10' );
        elm.setAttribute( 'step', '1' );
        
    } else if ( element === input && type === file ) {
        
        elm.style.borderLeft = '0.1vh solid red';
        
    
    } else {
        
        elm.style.outline = 'none';
    }
    
    elm.style.fontFamily = 'sans-serif';
    
    if ( controlFont !== '' ) {
        
        switch ( controlFont ) {
            
            case sfont:
                elm.style.font  = 'Arial';
                elm.style.fontSize = '1.5vh';
                elm.style.textAlign = 'left';
                break;
                
            case csfont:
                elm.style.font  = 'Arial';
                elm.style.fontSize = '1.5vh';
                elm.style.textAlign = 'center';
                break;
                                
            case ttfont:
                elm.style.font  = 'Lucida Console';
                elm.style.fontWeight = '100';
                elm.style.fontSize = '1.5vh';
                elm.style.textAlign = 'left';
                break;                
            case vsfont:
                elm.style.font = 'Lucida Console';
                elm.style.fontWeight = '100';
                elm.style.fontSize = '1.5vh';
                elm.style.textAlign = 'left';
                break;        
            case lfont:
                elm.style.font  =  'Arial';
                elm.style.fontSize = '1.9vh';
                elm.style.textAlign = 'left';
                break;
                
            case cfont:
                elm.style.font  = 'Arial';
                elm.style.fontSize = '1.9vh';
                elm.style.textAlign = 'center';
                break;
                
            case rfont:
                elm.style.font  =  'Arial';
                elm.style.fontSize = '1.9vh';
                elm.style.textAlign = 'right';
                break;
            case cnfont:
                elm.style.font  = 'Courier New';
                elm.style.fontSize = '1.9vh';
                elm.style.textAlign = 'center';
                break;        
            case xfont:
                elm.style.font  = 'Arial';
                elm.style.fontSize = '1.8vh';
                elm.style.textAlign = 'center';
                elm.style.fontWeight = 'bold';
                break;
            case shfont: // section header
                elm.style.font  = 'Arial';
                elm.style.fontSize = '2vh';
                elm.style.textAlign = 'left';
                break;
            
        }
        
    }    
        
    if ( background !== '' ) elm.style.background = background;
    
    elm.style.left = vhu( l );
    elm.style.top = vhu( t );
    elm.style.width = vhu( w );
    elm.style.height = vhu( h );
    parent.appendChild( elm );
    
    return elm;
    
}

function canvasSet( texture, ctx, bgr, w, h, txt ) {
 
    ctx.fillStyle = bgr; 
    ctx.fillRect( 0, 0, w, h );
    ctx.fillStyle = dGray;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.font = 'bold 80px Courier';     
    ctx.fillText(  txt, 0, h / 2 );    
    texture.needsUpdate = true;
    
}

function settextCPU( text, size, x, y, w, h ) {
    
    const cv = document.createElement('canvas')
    cv.width =  160 * w; 
    cv.height = 160 * h;
    const txtGeo = new THREE.PlaneGeometry( w, h ); 
    const ctx = cv.getContext( '2d' );    
    const cvTexture = new THREE.Texture( cv );
    const cvMaterial = new THREE.MeshBasicMaterial( { map: cvTexture, side: THREE.DoubleSide } );
    const txtMesh = new THREE.Mesh( txtGeo, cvMaterial );
    txtMesh.position.x = x;
    txtMesh.position.y = y;
    CPU.add( txtMesh );
    ctx.fillStyle =lSandy; 
    ctx.fillRect( 0, 0, cv.width, cv.height );    
    ctx.fillStyle = dGray;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = 'bold ' + size + 'px Courier';     
    ctx.fillText( text,  cv.width / 2, cv.height / 2 );    
    cvTexture.needsUpdate = true;
    
    return txtMesh;

}

function addPosReg( iMesh, bc, x, y, z ) { // registers,  bit count (bc)
    
    for ( let j = 0; j < bc; j ++ ) {
         
        iMesh.setMatrixAt( j, M4.setPosition( BITx( x, j ), y, z ) );
    
    }
    
    CPU.add( iMesh );
    
}

function positionRAM( iMesh, z ) {
    
    let inst = 0;
    
    for ( let i = 0; i < 256; i ++ ) {    
        
        for ( let j = 0; j < 8; j ++ ) {
            
            iMesh.setMatrixAt( inst ++,  M4.setPosition( RAMx( j ), RAMy( i ), z ) );
            
        }
        
    }
    
}

function visibilityRAM( iMesh, i, j, visibility ) {
    
    iMesh.setMatrixAt( i * 8 + j, M4.setPosition( RAMx( j ), RAMy( i ), visibility ) );
    
}

function visibilityRS( iMesh, x, y, i, j, visibility ) {
    
    iMesh.setMatrixAt( i * 8 + j, M4.setPosition(  BITx( x, j ), RSy( y, i ), visibility ) );
    
}

function visibilityReg( iMesh, x, y, j, visibility ) {
    
    iMesh.setMatrixAt( j,  M4.setPosition( BITx( x, j ), y, visibility ) );    
    
}

function rf_binRAM( row ) {
    
    for ( let j = 0; j < 8 ; j ++ ) {
    
        if ( RAM[ row ][ 2 ][ j ] === '0' ) {
            
            visibilityRAM( iMeshDig0RAM, row, j, visible );
            visibilityRAM( iMeshDig1RAM, row, j, hidden );
            
        } else { // === '1'
            
            visibilityRAM( iMeshDig0RAM, row, j, hidden );
            visibilityRAM( iMeshDig1RAM, row, j, visible );
            
        }
        
    }
    
    iMeshDig0RAM.instanceMatrix.needsUpdate = true;
    iMeshDig1RAM.instanceMatrix.needsUpdate = true;
    
}

function rf_assFlagsRAM( row, color ) {
    
    color = color || lSandy;
    txtAss = RAM[ row ][ 3 ].padEnd( 16 ) + RAM[ row ][ 4 ];
    canvasSet( cvAssTexture[ row ], ctxAss[ row ], color, cvAssW, cvAssH, txtAss );

}

function rf_R( i ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        if ( R[ i ][ j ] === '0' ) { // register, left
            
            visibilityRS( iMeshDig0R, regLftx, regLfty, i, j, visible );
            visibilityRS( iMeshDig1R, regLftx, regLfty, i, j, hidden );
            
        } else { // === '1'
            
            visibilityRS( iMeshDig0R, regLftx, regLfty, i, j, hidden );
            visibilityRS( iMeshDig1R, regLftx, regLfty, i, j, visible );
            
        }
        
    }
    
    iMeshDig0R.instanceMatrix.needsUpdate = true;
    iMeshDig1R.instanceMatrix.needsUpdate = true;
    
}

function rf_S( i ) {
    
    for ( let j = 0; j < 8; j ++ ) {
        
        if ( S[ i ][ j ] === '0' ) { // shadow register, right
            
            visibilityRS( iMeshDig0S, regRgtx, regRgty, i, j, visible );
            visibilityRS( iMeshDig1S, regRgtx, regRgty, i, j, hidden );
            
        } else { // === '1'
            
            visibilityRS( iMeshDig0S, regRgtx, regRgty, i, j, hidden );
            visibilityRS( iMeshDig1S, regRgtx, regRgty, i, j, visible );
        
        }
        
    }
    
    iMeshDig0S.instanceMatrix.needsUpdate = true;
    iMeshDig1S.instanceMatrix.needsUpdate = true;
    
}

function mnListHide( ) {

    if( mnList[ 0 ].style.visibility === 'visible' ) {
    
        for ( let i = 0; i < 41; i ++ ) {
        
            mnList[ i ].style.visibility = 'hidden';
            mnList[ i ].style.background = white;    
        }
        
    }
    
    mnListOutline.style.visibility = 'hidden';
    mnVisible = false;

}

function opListShow( ) {

    opListOutline.style.visibility = 'visible';
    
    for ( let i = 0; i < 32; i ++ ) {
        
        opList[ i ].style.background = white;
        opList[ i ].style.visibility = 'visible';
        
    }
    
}

function opListHide( ) {
    
    if( opList[ 0 ].style.visibility === 'visible' ) {
        
        for ( let i = 0; i < 32; i ++ ) {
        
            opList[ i ].style.visibility = 'hidden';
            //opList[ i ].style.background = white;
            
        }
        
    }
        
    opListOutline.style.visibility = 'hidden';
    
    op1Visible = false;
    op2Visible = false;
    
}

// --- Takt ( event handling ) ------

function displayTakt( ) { // when programming assembler  
      
  if ( takt === 0 ) { // scale start
        
        settext( takthz, 'Step' );
        
    } else {                        //  non-linear scale
        
        hide( nextstep );
        
        if ( takt < 101 ) {
            
            takt = taktLinear( takt );      // scale calculation up to 10Hz linear
            
        } else {
            
            takt = taktQuadratic( takt );   // scale calculation from 10Hz quadratic
        }
        
        if ( takt < 256 ) {
            
            settext( takthz, takt.str( ) );
            
        } else {
            
            settext( takthz, "Speed" );
            
        }
        
    }
    
}

function get_pulse( ) {    // determine current takt (non-linear scale)
    
    takt = gettext( takt_scroll ).val( );        // scrollrange
    
    if ( takt !== 0 ) {
        
        if ( takt < 101 ) {
        
            takt = taktLinear( takt );                       // scale calculation up to 10Hz linear
            
        } else {
            
            takt = taktQuadratic( takt );                    // scale calculation from 10Hz quadratic
            
        }
        
    }
    
    if ( takt <= 255 ) {
        
        if (  break123 === 0 && takt <= 255 ) {
            
            break1 = gettext( breakpt1 )            // determine breakpoint 1
            break2 = gettext( breakpt2 )            // determine breakpoint 2
            break3 = gettext( breakpt3 )            // determine breakpoint 3
            
            breakp = bin8_to_hex2( IC )             // IC hexadecimal
            
            if ( break1 === breakp ) {  //  breakpoint ->  one single step 
                
                break123 = 1;
                nospeed = 1;
                halt = 1;
                afterstep = 0;
                
                if ( breakp !== 'br1' ) {
                    
                    tb = t;
                    break1bak = breakp;
                    breakpt1.value = 'br1';
                    
                }
                
            }
             
            if ( break2 === breakp ) {  //  breakpoint ->  one single step 
                
                break123 = 1;
                nospeed = 1;
                halt = 1;
                afterstep = 0;
                
                if ( breakp !== 'br2' ) {
                    
                    tb = t;
                    break2bak = breakp;
                    breakpt2.value = 'br2';
                    
                }
                
            }
             
            if ( break3 === breakp ) {  //  breakpoint ->  one single step 
                
                break123 = 1;
                nospeed = 1;
                halt = 1;
                afterstep = 0;
                
                if ( breakp !== 'br3' ) {
                    
                    tb = t;
                    break3bak = breakp;
                    breakpt3.value = 'br3';
                    
                }
                
            }
            
        }
        
    
    
        if ( t === tb + 1 && breakpt1.value === 'br1' ) {
            
            breakpt1.value = break1bak;
            
        }
        
        if ( t === tb + 1 && breakpt2.value === 'br2' ) {
            
            breakpt2.value = break2bak;
            
        }
        
        if ( t === tb + 1 && breakpt3.value === 'br3' ) {
            
            breakpt3.value = break3bak;
            
        }
    
    }
    
    if ( takt === 0 || break123 === 1 ) { // scale start or breakpoint
    
        hide( inp_ );
        
        drawRunStatus.style.color = black;
        settext( drawRunStatus, 'Step ...' );
        startbin.style.background = sandy;
        
        settext( takthz, 'Step' );
        
        show( drawSTOP );
        show( abr );
        show( nextstep );
        
        show_set_IC( );
        settext( drawSet_IC, bin8_to_hex2( IC ) + ' current'  );
        
        delay = onestep === 1 ? 0 : Infinity;   // onestep === 1  => one command forward    
        onestep = 0;        
        nospeed = 1;                            // single step
        afterstep = 1;                          // memorize for recovery status start knob 
        
    }
    
    if ( nospeed === 1 ) show( nextstep );
    
    if ( takt > 0 && nospeed === 0 ) {
    
        if ( afterstep === 1 ){
            
            drawRunStatus.style.color = dred;                // dark red font
            settext( drawRunStatus, 'halt again' );
            startbin.style.background = gray;                // run knob gray
            
            hide_set_IC( );
            
            afterstep = 0;
            
        }
        
        if ( takt < 256 ) {
            
            settext( takthz, takt.str( ) );
            nospeed = 0;                // variable takt
            
        } else {
            
            settext( takthz, "Speed" );
            
        }
            
        delay = halt === 1 ? Infinity : 1 / takt;
        bitdelay = halt === 1 ? Infinity : ( alu_bitw.checked ? delay : 0 );
         
    }
    
}

function set_clock( ) {     // set CPU time

 if ( t === 131072 ) {              // overflow at 2^17 ... 
    
    t = t0;                         // t0 = 65536  (base value CPU time 2^16 --> right 16 only zeros)
    
 } else {
    
    t ++ // CPU time increment
    
 }
 
  CPUCLOCK = right( t.bin( ), 16 );  // set 16 bit CPU time
  rf_CPUCLOCK ( );
  
}

// ----- display/ clean up/ control -----

function show( elm ) {                            // show control
    
    elm.style.visibility = 'visible';
    
} 

function hide( elm ) {                            // hide control
    
    elm.style.visibility = 'hidden';
    
}

function hide_assembler_controls( ) {            // hide controls for assembler programming
    
    hide( startadr ); // hide controls
    hide( prgvon );
    hide( prgbis );
    hide( datvon );
    hide( datbis );
    hide( shift_by ); 
    hide( cadr );
    hide( oc_ );
    hide( mnShow );
    hide( mn_ );
    hide( op1_ ); hide( op1Show );
    hide( op2_ ); hide( op2Show );
    hide( codeup );
    hide( codedown );
    hide( fl_ );
    hide( conadr );
    hide( coninp_ );
    hide( conhex );
    hide( coninp_ );
    hide( conup );
    hide( condown );
    hide( conalt_ );
    hide( conans );
    hide( concomm_ );
    hide( hlp_ );    
    hide( load );
    hide( store );
    hide( relocate );  
    
}

function show_assembler_controls( ) {          // show controls for assembler programming
    
    show( startadr ); // show controls 
    show( prgvon );
    show( prgbis );
    show( datvon );
    show( datbis );
    show( shift_by ); 
    show( cadr );
    show( oc_ );
    show( mnShow );
    show( mn_ );
    show( op1_ ); show( op1Show );
    show( op2_ ); show( op2Show );
    show( codeup );
    show( codedown );
    show( fl_ );
    show( conadr );
    show( coninp_ );
    show( conhex );
    show( coninp_ );
    show( conup );
    show( condown );  
    show( conalt_ );
    show( conans );
    show( concomm_ );
    show( hlp_ );
    show( load );  
    show( store );
    show( relocate );
    
}

function clr_hide12( ) {            // delete, hide operand edits 1 and 2
 
    op1="";
    hide( op1_ ); hide( op1Show );
    op2="";
    hide( op2_ ); hide( op2Show );
 
}

function RAM_delete( ) {  // clear RAM, comments and current flags with query
    
  const msg = confirm("                CAUTION!\n\n Are you really sure?\n  \nDid you store the program? \n "   + "\nDo you really want to delete the 256Byte RAM (memory/program/data)" + "\nand the last flags and comments completely?  " )
 
    if ( msg ) {   // OK
    
      row  = 0; 
      
      do {
        
        RAM[ row ][ 2 ] = "00000000";
        rf_binRAM( row );                 // refresh binary content  3D RAM
        
        if ( row < 128 ) {
        
          RAM[ row ][ 3 ] = "NOP";
          
        } else { 
        
          RAM[ row ][ 3 ] = "0    h00"; // decimal: Sign, 4 digits / 1 blank / hexadec. two digits
          
        }
        
        if ( row < 245 )  RAM[ row ][ 4 ] = "    ";  //  4 spaces up to before SP Base address
        
        rf_assFlagsRAM( row ); 
        
        comment[ row ] = ";";
        
        row ++;
        
      } while ( row  < 256 ); 
       
      
    }
    
    coderow = 0;
    restore_instruction( );               // set mnemonic Op1,2 and comment in input edits
    conrow  = 128;
    restore_const( );                     // set constant (input) with comment

}

function flag_delete( ){ // delete current flags without asking

  row = 0;
  
  do {
  
   RAM[ row ][ 4 ] = "    ";         //  4 spaces
   rf_assFlagsRAM( row );
   
   row ++;
   
 } while ( row < 127 );
 
}

//  ----- flags -----

function flags_0_0_0_0( ) {

  N = Z = V = C = '0';                      // set all flags to zero
  SR = left( SR, 4 ) + N + Z + V + C;       // set status register with flags
  rf_SR( );                                 // refresh
  
}

function flags_b_res_N_Z_0_0( ) {           // determine flags N and Z from result in b_res, V=0 C=0  
  
  N = b_res[0];
  Z = b_res === "00000000" ? "1" : "0";
  V = "0"
  C = "0"
  SR = left( SR, 4 ) + N + Z + V + C;       // set status register with flags
  rf_SR( );                                 // refresh
  
}

function flags_latest( ic_dec_fl ) { // last set flags after command execution behind assembler
 
  if( N === "1" )  N_ = "N";
  if( N === "0" )  N_ = " "
  if( Z === "1" )  Z_ = "Z"
  if( Z === "0" )  Z_ = " "
  if( V === "1" )  V_ = "V"
  if( V === "0" )  V_ = " "
  if( C === "1" )  C_ = "C"
  if( C === "0" )  C_ = " "
  RAM[ ic_dec_fl ][4] = N_ + Z_ + V_ + C_; // flags set after command execution
  rf_assFlagsRAM( ic_dec_fl, lGray );      // refresh assembler and flags
  
}

// --- input output system -------------

function input_system( ) {   // Input system - user input during program run   
  
  show( IO );                  // show input-output protocol 
  show( wait_inp )             // cover start knob
  shio.checked = true;
  hide( inpKey_ );
  
  show( inp_ );
  inp_.focus( );
  inp_.value = RAM[ 246 ][3][0];
  
  onInput = true;
  
  // in animate: make_input( ) while not inp_OkClicked  
  //  ... then finalize_input( )

}

function make_input( ) {
    
    inp = gettext( inp_ );     // input decimal number -128 to 127 or hexadecimal number or keyboard character    
    
    if ( inp  === "" ) {
      
      hide( inp_ok );
      binp = "";                 // "" do not automatically convert to 000000 
      settext( altinp_, "" );
      settext( ans_, "" );
      
    } else {
      
      ansi = inp.ord( );         // ANSI code first character
      
      if ( ( ansi > 47 && ansi < 58 ) ||  ( ansi === 45 && inp.length >1 ) ) { // decimal digit or minus sign at the beginning  
        inpval = inp.val( );             // decimal value of the input
        binp = dec_to_bin8( inpval );    // convert number to binary (negative: two's complement)
        
        if ( inpval > -129  && inpval < 128 ) {
        
          if ( inpval < 0 ) {
          
            settext ( altinp_, dec_to_bin8( inpval ).bdec( ).str( ) );  // alternative representation of the input character/number
          
          } else {
          
            settext( altinp_, "" );
            
          }
          
          settext( ans_,  inpval.chr( ) ); // display character
          show( inp_ok );
          
        } else {                  // invalid decimal number:     < -128   or   > 127           -> OVERFLOW
        
          hide( inp_ok );
          binp = "OVERFLOW";
          settext( altinp_, "" );
          settext( ans_, "" );
          
        } // Dezimal
        
      } else if ( ( ansi === 36 || ansi === 72 || ansi === 104  ) &&   inp.length === 3 ) {  // $ or H or h at the beginning: hexadecimal number
      
         binp = hex2_to_bin8( inp[1] + inp[2] );      // hexadecimal number to binary number 
         inpval = binp.bdec( )                        // corrected input value (letter above F, f to 0)
         settext( altinp_, inpval.str( ) );
         settext( ans_, inpval.chr( ) );              // display character    
         show( inp_ok );
         
      } else {                                   // input of a keyboard character
      
        if ( inp.length === 1 ) {
        
          binp = d255_to_bin8( ansi );                     // ANSI code of the character binary
          
          if ( ansi > 127 ) {
          
            settext( altinp_, bin8_to_dec( binp ).str( ) ); // display value of the character 
            
          } else {
          
            settext( altinp_, "" );
            
          }
          
          settext( ans_, ansi.str( ) );                // display ANSI code of the character decimally
          show( inp_ok );
          
        } else {
         
          binp = "ERROR";     // incorrect input: several characters, but no valid decimal number  -> ERROR
          hide( inp_ok ); 
          settext( altinp_, "");
          settext( ans_, "");
          
        }
        
      } // keyboard character
      
    } // non-empty input
  
    settext( binp_, binp )                            // display input binary
    
    if ( binp === "" || binp === "OVERFLOW" || binp === "ERROR" ) { // invalid, no display
      
      settext( hinp_, "" );
      
    } else {
      
      hinp = bin8_to_hex2( binp );
      settext( hinp_, "h" + hinp );        // display input hexadecimal
      
    }
    
}

function finalize_input( ) {
  
  inp_OkClicked = false;
  onInput = false;
  
  // IO_SR                             // type data IO left 2 bit SR  
  switch ( IO_SR ) { 
      case  "00":                      // --- keyboard character --- 
        settext( inpIO[ iorow ++ ], binp.bdec( ).chr( ) );              // write character to input list
      break;
      case "01":                       // --- decimal ---
        settext( inpIO[ iorow ++ ], bin8_to_dec( binp ) );              // write decimal number to input list
      break;
      case "10":                       // --- hexadecimal xx ---
        settext( inpIO[ iorow ++ ], "h" + hinp );                       // write hxx to input list
      break;
      case "11":                       // --- 8 bit binary ---      
       settext( inpIO[ iorow ++ ], ">" + left( binp, 4 ) );
       settext( outIO[ iorow ++ ], right( binp, 4 ) + "." );            // write binary to input/output list
       
  } // type data IO_SR
  
  R[ rx ] = binp;
  rf_R( rx );
  
  RAM[246][2] = binp;                     // in RAM Adr 246 = hF6   binary enter ...
  RAM[246][3] = bin8_to_dec( binp ).chr( ) + "    h"  + bin8_to_hex2( binp ) // ... enter character and value in hexadecimal
  
  rf_binRAM( 246 );                    // refresh binary content  3D RAM
  rf_assFlagsRAM( 246 );               // refresh assembler flags  3D RAM
  
  b_res = binp;                        // for flags
  flags_b_res_N_Z_0_0( );  
  ic_dec ++;
    
  hide( inp_ok );
  hide( wait_inp );
  
  hide( inp_ );
  show( inpKey_ );
  settext( inpKey_, bin8_to_dec( binp ).chr( ) );
  
  finInput = false;
  finalizeCommand( );
 
}

function output_system( ) {
  
  show( IO );                      // show input-output protocol
  shio.checked = true;
  settext( boutp_, boutp );                                          // binary output
  settext( houtp_, "h" + bin8_to_hex2( boutp ) );                    // hexadecimal output
  settext( outp_, bin8_to_dec( boutp ).str( ) );                     // decimal output with sign
 
  if ( boutp[0] === "1" ) {                                          // output is negative ...
  
    settext( ansout_, boutp.bdec( ).str( ) );                         // ... output ANSI code
    
  } else {
  
    settext( ansout_,"" );                                           // output decimal is already ANSI code
    
  }
  
  settext( coutp_, boutp.bdec( ).chr( ) );                            // output as character according to ANSI code
  
  // IO_SR                               // type data IO left 2 bit SR 
  switch ( IO_SR ) {
      
      case "00":                       // --- keyboard character --- 
      settext( outIO[ iorow ++ ], gettext( coutp_ ) );                // output list character
      break;
      case "01":                       // --- decimal ---
        settext( outIO[ iorow ++ ], gettext( outp_ ) );              // output list Dezimalzahl
      break;
      case "10":                       // --- hexadecimal xx ---
        settext( outIO[ iorow ++ ], gettext( houtp_ ) );             // output list hexadecimal: xx
      break;
      case "11":                       // --- 8 bit binary --- 
        settext( inpIO[ iorow ], "." + left( boutp, 4 ) );
        settext( outIO[ iorow ++ ], right( boutp, 4 ) + ">" );      // inpuz output list 8 bit binary 
        
  } // type data IO_SR
 
}

// --- number systems / arithmetics -----

function dec_to_bin3( d ) { //  decimal 0..7    -> 3 bit binary
    
    const b = d.bin( );
    
    return mkstr( "0", 3 - b.length ) + b;

}

function d255_to_bin8( d ) { //  dec   0..255 (unsigned)              -> binary 8-digit
    
    const b = d.bin( );
    
    return ( mkstr( '0', 8 - b.length ) + b );

}

function dec_to_bin8( d ) { //  dec -128..127 (sign: two's complement) -> binary 8-digit
    
    if ( d > -1 && d < 128 ) {                // positive range with zero
        
        return d255_to_bin8( d );            // with leading zeros
        
    } else if ( d > -129 && d < 0 ) {         // negative range - two's complement
        
        return ( 256 + d ).bin( );    // 1 is first bit
        
    } else if ( d < -128  || d > 127 ) {    // cannot be represented in 8 bit signed form
        
        return "OVERFLOW";
        
    }
    
}

function bin8_to_dec( b ) {    // binary 8-digit            -> dec -128..127 (sign: two's complement)
    
    if ( b[0] === '0' ) return  b.bdec( );                            //    0 to 127
    if ( b[0] === '1' ) return -128 + b.substr( 1, 7 ).bdec( );        // -128 to -1
    
}

function dec_to_hex2( d ) {    // decimal (positive) to hexadecimal 2 digits
    
    const h = d.toString( 16 ).toUpperCase( );
    return mkstr( "0", 2 - h.length ) + h; // create leading zero
}

function hex2_to_bin8( h ) { // hexadecimal 2 digits to binary 8 digits
    
    const b = parseInt( h, 16 ).bin( );
    return mkstr( "0", 8 - b.length ) + b;         
    
}

function bin8_to_hex2( b ) { //  binary 8 digits to hexadecimal 2 digits 
    
    const d0 = left( b, 4 ).bdec( );
    const d1 = right( b, 4 ).bdec( );
    return d0.toString( 16 ).toUpperCase( ) + d1.toString( 16 ).toUpperCase( );
    
}

function bit_add( ) { // addition of 3 bits with carry

  let bz = 0;                         // initialize
  
  bz += b1 === "1" ? 1 : 0;           // count set bits
  bz += b2 === "1" ? 1 : 0;
  bz += b3 === "1" ? 1 : 0;
  
  switch ( bz ) {                     // number of bits -> result (decimal=)
  
    case 0:
      bc = "0" ; r = "0"; break;                // 00    (0)   
    case 1:
      bc = "0" ; r = "1"; break;                // 01    (1)
    case 2:
      bc = "1" ; r = "0"; break;                // 10    (2)
    case 3:
      bc = "1" ; r = "1"                        // 11    (3)
      
  }
  
}

// ........ ALU ............

function add_ALU_9( ) { // addition in the 9 bit arithmetic unit in the ALU with flags
  
  onAdd = true;
  
  // 9-bit adder, 8-bit and sign extension for overflow checking  
  // Bit positions (C Carry): C 7 6 5 4 3 2 1 0 - duplicate most significant bit 7 in C, dec -128 bis +127
  AL1 = AL1[0] + AL1;        // most significant bit 1st operand, duplicate
  rf_AL1( );
  AL2 = AL1[0] + AL2;        // most significant bit 2nd operand, duplicate
  rf_AL2( );
  
  C9 = "         ";          // empty carry over
  ALC = C9;
  rf_ALC( );
  R9 = "         ";          // 9 bit result, empty
  ALR = R9;
  rf_ALR( );
  
  addPart ='1';
  //onAdd1 = true;
  goAdd = false;
  goCmd = false;
  t_ = clock.getElapsedTime( ); 
  
}

 function add_ALU_9_1( ) {
  
  addBit = 0  // begin with bit value 0 (right)
  
  C9 = "        0";          // least significant carry is set to 0
  ALC = C9;                  // ... and put into the ALU 
  rf_ALC( );    
  
  // bitwise addition with carry 
  onADDbitstep = true; 
  addPart ='2';
  goAdd = false;
  t_ = clock.getElapsedTime( );

}

 function add_ALU_9_2( ) {
  
  b_res = right( R9, 8 );    // result right 8 bit
  N = b_res[0];              // left bit is sign bit
  
  Z =  b_res === "00000000" ? '1' : '0'; // set Zero flag
  
  if (  R9[0] === R9[1]  ) { // left two bit equal 
  
     V = '0';               // ok -> Result in the range -128 to 127
     
  } else  {                  // left two bit different
  
     V = '1';               // set oVerflow flag 
     
  }
  
  // C is set in the loop!
  SR = left( SR, 4 ) + N + Z + V + C  // set status register with flags
  rf_SR( );

  addPart ='';
  onAdd = false;
  t_ = clock.getElapsedTime( );
  
}

function complementBit( ) {

  b1 = AL1[ bit - 1 ];           // read out bit ...
  r = b1 === '0' ? '1' : '0';    //  r = 1 ... complement
  R9 = space( bit - 1 ) + r + right( R9 , 9 - bit );
  ALR = R9;
  rf_ALR( );
  
}

function bitAndOr( ) {
  
  b1 = AL1[ bit - 1 ];  // read out bit
  b2 = AL2[ bit - 1 ];
  
  if ( ocb === "0" ) r = b1 + b2 === "11" ? "1" : "0"; // AND
  if ( ocb === "1" ) r = b1 + b2 === "00" ? "0" : "1"; // OR
  
  R9 = space( bit - 1 ) + r + right( R9, 9 - bit );
  ALR = R9;
  
}

function bittest( ) {

    if (  mid( AL2, bit, 1 ) === "1" ) {    // check only if bit in shadow register is set
    
       if ( mid( AL1, bit, 1 ) === "1" ) {  // compare bit from register
       
           r = "0";                         // match: 0
           
       } else {
       
           r = "1";                         // deviation: 1
       }
       
    } else {
    
      r = "0";                              // not tested always: 0
      
    }
    
    R9 = space( bit - 1 ) + r + right( R9, 9 - bit );
    ALR = R9;
    rf_ALR;
    
}

function bitAddition( ) {
  
  b1 = mid( AL1, 9 - addBit, 1 );     // read bit , ( mid gives digit from position 1 )
  b2 = mid( AL2, 9 - addBit, 1 );
  b3 = mid( ALC, 9 - addBit, 1 );
  
  bit_add( );              // sddition of the bits
  
  if ( addBit < 8 ) {         // last Carry left no longer fits in C9
    
    C9 = space( 7 - addBit ) + bc + right( C9, addBit + 1 );   // Carry bit one more to the left ... 
    
  } 
  
  if ( addBit === 7 ) {       // last Carry from 8 bit width, left 
    
    C = bc;               // set Carry flag
    
  }
    
  R9 = space( 8 - addBit ) + r  + right( R9, addBit );         // ... than the result bit
  
  ALC = C9;
  rf_ALC( );
  ALR = R9;
  rf_ALR( );
  
}

function _MUL_Booth_ALU( ) { // Multiplication according to Booth in the ALU 9Bit/8Bit
  
  tmp = bin8_to_dec( R[0] ) * bin8_to_dec( R[1] ); // decimal result of the mutiplication
  
  // ALU
  btmp1 = R[0];        // read data registers
  btmp2 = R[1];
  AL1 = space(9);
  rf_AL1( );
  AL2 = space(9);
  rf_AL2( );
  ALC = space(9);
  rf_ALC( );
  ALR = space(9);
  rf_ALR( );
  _ALBA( visible ); _ALBS( visible );  // show temporary registers of the ALU;
  A_MUL.visible = true;
  S_MUL.visible = true;
  x_MUL.visible = true;
  Booth_MUL.visible = true;
  
  AL1 = btmp1;          // register D0 to AL1 ...
  rf_AL1( );
  
  // => ALU_step
   cmd = 'MUL1';
   goCmd = false;  
   t_ = clock.getElapsedTime( );
   
}

function _MUL_Booth_ALU1( ) {
  
  ALBA = btmp1;                   // D0 for addition to temporary register A
  rf_ALBA( );
  // ... form two's complement  
  //        ... form one's complement in the ALU
  bit = 9;
  AL1 = " " +  AL1;               // set right justified
  rf_AL1( );
  AL2 = "         ";              // unused
  rf_AL2( );
  ALC = "         ";              // unused
  rf_ALC( );
  R9  = "         ";              // 9 bit clear result ...
  ALR = R9;                       // ... and put into the ALU
  rf_ALR( );
  
  bit = 9;
  onCOMPLbitstep = true;
  cmd = 'MUL2';
  goCmd = false; 
  t_ = clock.getElapsedTime( );
  
}

function _MUL_Booth_ALU2( ) {
  
  b_res = right( ALR, 8 );
  
  //   end  One's complement

   cmd = 'MUL3';
   goCmd = false;  
   t_ = clock.getElapsedTime( );
   
}

function _MUL_Booth_ALU3( ) { 
  
  AL1 = "00000001"                // 1 add   ...
  rf_AL1( );
  AL2 = b_res;                    // ... to one's complement
  rf_AL2( );
  
  cmd = 'MUL4';
  add_ALU_9( );                  // addition in the 9 bit arithmetic unit in the ALU with flags
  
}  

function _MUL_Booth_ALU4( ) {
   
  // end two's complement 
  
  ALBS = b_res;                // -D0  for subtraction (two's complement) in S
  rf_ALBS( );
  
  cmd = 'MUL5';
  goCmd = false;  
  t_ = clock.getElapsedTime( );
   
}

function _MUL_Booth_ALU5( ) {
  
  _ARL( visible );             // temporary registers of the ALU 
  _ALx( visible );
  ALR = "000000000";           // 9 bit: initial value for continuous summation +/-, >> with D0 (sign extension)
  rf_ALR( );
  ARL = btmp2;                 // 8 bit: Register for solution,    D1 insert
  rf_ARL( );
  ALx = "0";                   // 1 bit:  initial value
  rf_ALx( );
  btmp2 = b_res;               // for subtraction +(-D0) restore
  
  mulBit = -1; // mulBit ++   before first partial step!
  onMULbitstep = true;
  goCmd = false;
  // entry in loop without pause    
  
}

    function mul_clearReg( ) {
        
        AL1 = space(9); rf_AL1( );         //    \
        AL2 = space(9); rf_AL2( );         //    -  ALU-register,  empty
        ALC = space(9); rf_ALC( );         //    /
        
          mulBitstepPart = 'setb1b2';
        goMULbitstepPart = false;
        t_ = clock.getElapsedTime( );       
       
    }
    
    function  mul_setb1b2( ) {
        
        b1 = right( ARL, 1 );
        b2 = ALx;
        
        if ( b1 === b2 ) { //  00 and 11
        
            mulBitstepPart = 'shift';   //   to mul_shift( )    without step
         
        } else {
        
            mulBitstepPart = 'addSection'; //    to mul_addSection( )   without step
        
        }
        
     }
    
    function  mul_addSection( ) {
        
        if ( b1 === "0" && b2 === "1" ) AL2 = btmp1; //  D0 for addition to AL2   
        if ( b1 === "1" && b2 === "0" ) AL2 = btmp2; // -D0 for addition to AL2
        rf_AL2( );
        AL1 = right( ALR, 8 );     // restore running total to AL1
        rf_AL1( );
        
        goMULbitstepPart = false;
        mulBitstepPart = 'extraStep'; //  to  mul_extraStep( ) 
        
        add_ALU_9( );              // addition in the 9 bit arithmetic unit in the ALU with flags
        
    }
    
    function mul_extraStep( ) {
        
        // do nothing, after that to   mul_shift( )
        
        mulBitstepPart = 'shift';
        goMULbitstepPart = false;
        t_ = clock.getElapsedTime( );
        
    }
    
    function mul_shift( ) {
        
        shift_ALRx( mulBit );           // shift >>    with sign extension
        
        goMULbitstepPart = false;
        onMULbitstepPart = true;
        // further bitstep
        
    //   end mul_Booth bitstep     further with: _MUL_Booth_ALU6( )  in animate ...
    }
 
function  _MUL_Booth_ALU6( ) {
  
  ALR = " " + right( ALR, 8 ); // remove   >>  character
  rf_ALR( );
  ALBA = space( 8 );           //   \
  ALBS = space( 8 );           //    - clear temporary ALU registers
  ARL  = space( 8 );           //   /
  ALx  =  " ";                 //
  
  rf_ALBA( ); rf_ALBS( ); rf_ARL( ); rf_ALx( ); // refresh
  
  _ALBA( hidden ); _ALBS( hidden ); _ARL( hidden ); _ALx( hidden ); // hide temporary ALU registers
  
  A_MUL.visible = false;
  S_MUL.visible = false;
  x_MUL.visible = false;
  Booth_MUL.visible = false;
  
 // ===> from here on identical to _MUL  
  
 if ( tmp > -129 && tmp < 128 ) {      // result in the range
  
    b_res = dec_to_bin8( tmp );
    flags_b_res_N_Z_0_0( );
    
  } else {
  
    b_res = right( tmp.bin( ), 8);      // corresponds to low byte ALM of ALR,ARL
    N = "0";
    Z = "0";
    V = "1";                            // set flag  oVerflow 
    C = tmp > 255 ? '1' : '0';          // Carry forward, assuming unsigned operands
    
    SR = left( SR, 4 ) + N + Z + V + C; // Set status register with flags
    
  } 

  R[0] = b_res;                         // Fill in the result in D0
  rf_R( 0 );
  ic_dec ++; 
  finalizeCommand( );
  
}

// --- auxiliary procedures assembler ------
 
function restore_instruction( ) { // restore command (input) with comment
    
    mn_.value = RAM[ coderow ][ 3 ].substr( 0, 3 );                 // set mnemonic
    op1_.value = RAM[ coderow ][ 3 ].substr( 4, 4 );                // set Op 1
    op2_.value = RAM[ coderow ][ 3 ].substr( 9, 4 );                // set Op 2    
    opcomm_.value = comment[ coderow ].substr( 1, 255 ).trim( );    // set command comment
    
}

function restore_const( ) { // restore constant (input) with comment
    
    coninp_.value =  RAM[ conrow ][ 3 ].substr( 0, 4 ).trim( );
    concomm_.value = comment[ conrow ].substr( 1, 255 ).trim( );    // set constant comment
    
}

function restore_from_RAM( ) {    // restore command or constant from RAM with comment

    if ( ramrow > -1 && ramrow < 128 ) {    // ramrow is -1 when "partial row" is clicked at the end of the gridbox!
        coderow = ramrow;
        restore_instruction( );    // set mnemonic Op1,2 and comment in input edits
    }
    
    if ( ramrow > 127 && ramrow < 256 ) {
        conrow = ramrow;
        restore_const( );            // set constant (input) with comment
    }
    
}

function rc( rg ) {    // register code assign
    
    if( rg === ".IA." ) return "";
    if( rg === ".+A." ) return "";
    if( rg.length === 0 ) return "";
    rg = rg[1] + rg[2];           // register without addressing . . resp. [ ]
    if( rg === "D0" ) return "00";
    if( rg === "D1" ) return "01";
    if( rg === "A0" ) return "10";
    if( rg === "A1" ) return "11";
    
}

function load_asm( ) { // load HC680 assembler file (*.txt)
    
    asmArr = [];
    const reader = new FileReader( );
    
    load.style.visibility = 'hidden'
    selectAsmFile.style.visibility = 'visible';
    
    asmLoad.addEventListener( 'change', e => {
        let file = asmLoad.files[0];
        const textType = /text.*/;  
        
        if ( file.type.match( textType ) ) {
            
            reader.readAsText( file );
            
            reader.onload = e => {
                
                asm_tmp.value = reader.result;
                
                asmArr = gettext( asm_tmp ).match(/[^\r\n]+/g); // separate by line ends, bring into array
                
                load_ram( 0  );        // load into RAM without shifting
                initial_r0_r128( );    // initialize edits and variables line 0 and 128
                
            }
            
        } else {
            
            alert( "incorrect file type" );
            
        }
        
        selectAsmFile.style.visibility = 'hidden';
        load.style.visibility = 'visible';
        
    } );
    
}

function isnot_hex2( h1 ) { // check for incorrect hexadecimal address
  
  const h2 = right( h1, 1 );
  const ord1 = h1.ord( );   // ord( ) uses left character of the two-character address  
  const ord2 = h2.ord( );
  
  if ( h1.length > 2 ) {    // check length of h1
    
    alert( "wrong address length - adress: " + h1  + "\n \nNote address 00 to FF or ff.","--- address error ---" );
    return 1;
    
  }
  
  let adrErr = false;
  adrErr = adrErr || ( ord1 < 48 ) || ( ( ord1 > 57 ) && ( ord1 < 65 ) ) || ( ( ord1 > 70 ) && ( ord1 < 97 ) );
  adrErr = adrErr || ( ord1 > 102 ) || ( ord2 < 48 ) || ( ( ord2 > 57 ) && ( ord2 < 65 ) );
  adrErr = adrErr || ( ( ord2 > 70 ) && ( ord2 < 97 ) ) || ( ord2 > 102 );
  
  if ( adrErr ) {
    
    alert( "wrong address: " + h1  + "\n \nNote address 00 to FF or ff.","--- address error ---" ); 
    return true;
    
  } else {
  
    return false;
    
  }
  
}

function rel_value( ) { // edit shift value for assembler in RAM
    
  ansi = gettext( shift_by ).trim().ord( );            // ANSI 1. character
     
  if (  ansi === 36 || ansi === 72 || ansi === 104  ) { //  $ ,H ,h  1st character positive hexadecimal number
    
    ramshift = mid( gettext( shift_by ), 2, 3 ).hdec( );  // convert into dec  
    
  } else if ( ansi === 45 ) {
    
    ansi = mid( gettext( shift_by ).trim( ), 2, 4 ).ord( );    // ANSI 2nd character if minus sign at the beginning
    
    if ( ansi === 36 || ansi === 72 || ansi === 104 ) {  // - and $ ,H ,h  2nd character negative hexadecimal number
      
      ramshift = -mid(gettext( shift_by ).trim( ), 3, 3 ).hdec( );  // convert into dec - negative
      
    } else { // negative decimal
      
      ramshift = gettext( shift_by ).val( );
      
    }
    
  } else {  // therefore positive decimal
  
    ramshift = gettext( shift_by ).val( );
   
  }
  
}

function store_asm( ) { // store HC680 assembler >>> to clipboard
    
    pfr = gettext( prgvon )  // program  from (hexadecimal)
    pto = gettext( prgbis )  // program  to   (hexadecimal)
    dfr = gettext( datvon )  // data     from (hexadecimal)
    dto = gettext( datbis )  // data     to   (hexadecimal)
    row  = -1;              // preassignment for error checking
    
    if ( pfr.length === 0 &&  pto.length === 0 && dfr.length === 0 &&  dto.length === 0  ) {
        
        row --;     // no area
        
    }
    
    if (  pfr.length > 0 &&  pto.length > 0 ) {
      
      if ( isnot_hex2( pfr ) || isnot_hex2( pto ) ) {
        
        row --;     //  Error: Inputs not correct hexadecimal one or two digits
        
      }
      
    }
    
    if ( dfr.length > 0 &&  dto.length > 0 ) {
      
      if ( isnot_hex2( dfr ) || isnot_hex2( dto ) ) {  // logical functions with error message ...
       
       row --;   //  Error: Inputs not correct hexadecimal one or two digits
       
      }
      
   }
   
    if ( row === -1 )  {
        
        store_ram( );   // save the RAM rows with addresses xx (xx hexadecimal ) 
        
        // asm_tmp textArea to clipboard
        asm_tmp.select( );
        document.execCommand( "Copy" );
        
    }
    
    if ( row < 0 ) {   // no storage is made
        
        alert( "No storage was made. \n\n --- error when storing ---" );
        
   }
    
}

function reloc_asm( ) { // shift assembler in RAM
  
  let msgprg = "";                 // text for error message      
  let msgdat = "";
  let msgver = "";
  pfr = gettext( prgvon );          // program  from (hexadecimal)
  pto = gettext( prgbis );          // program  to   (hexadecimal)
  dfr = gettext( datvon );          // Data     from (hexadecimal)
  dto = gettext( datbis );          // Data     to   (hexadecimal)
  
  if ( pfr.length > 0 && pto.length > 0 ) {             // shifting in the program area
    
    if ( isnot_hex2( pfr ) || isnot_hex2( pto ) ) {
      
      msgver = "";  // as error detection, abort (inputs not correct hexadecimal one or two digits)
      
    } else {
      
      msgprg = "\n command area  h" + pfr + " to  h" + pto;
      
    }
    
  }

  if ( dfr.length > 0 && dto.length > 0 ) {            // shifting in the data area
    
    if ( isnot_hex2( dfr ) || isnot_hex2( dto ) ) {   // logical functions with error message ...
      
      msgver = "";  // as error detection, abort (inputs not correct hexadecimal one or two digits)
      
    } else {
      
      msgdat = "\n       Data area  h" + dfr + " to  h" + dto;
      
    }
    
  }
  
  if ( ramshift !== 0 ) { // not: empty or 0
    
    msgver =  "\nshift decimal "+ ramshift.str( ) +" in RAM? ";
    
  } 
  
  if ( msgprg !== "" ) {         // shifting in the program area
    
    if ( pfr.hdec( ) + ramshift < 0 ||  pto.hdec( ) + ramshift > 127 ) { 
    
      alert( "Old or new program area incorrect.   \n   ---  Error when shifting!  ---" );
      
      msgver = "";                // as termination indicator
      msgprg = "b_fehler";
      
    }
    
  }
  
  if ( msgdat !== "" ) {         //shifting in the data area
    
    if ( dfr.hdec( ) + ramshift < 128 || dto.hdec( ) + ramshift > 255 ) {
      
      alert( "Old or new data range incorrect.   \n   ---  Error when shifting!  ---" );
      
      msgver = "";                // as termination indicator
      msgdat  = "b_fehler";
      
    }
    
  }
  
  if ( msgver === "" || ( msgver !== "" && msgprg === "" && msgdat === ""  ) ) {   // incorrect values
    
    if ( msgprg !== "b_fehler" && msgdat !== "b_fehler" ) {                     // no error message occurred yet
      
      alert("Error! \n\nPlease check the values of the shifting. \n --- Shifting in RAM ---" );
      
    }
    
  } else {
    
    if ( confirm( "Do you want to have " + msgprg + msgdat + msgver," --- Shifting in RAM ---" )  ) {
      
      // instead of asm_tmp.txt in the windows-version in the browser asm_tmp textArea as buffer to export to the clipboard
      store_ram( );                  // cache to asm_tmp textArea (with check from < to, otherwise error message)
      
      if ( row > -1 ) {              // saving successful, further steps possible
        
        clear_source_ram( );         // ... RAM rows, delete comments of the old addresses of the shift arean ... 
        load_ram( ramshift );        // ... load with shift into RAM
        initial_r0_r128( );          // establish initial state assembler
        
      }
      
    } // shift message ok
    
  } // message faulty values 
  
}

function clear_source_ram( ) { // set RAM source range of shift to zero
  
 // asmArr[ 0 ] title line - discard
 // asmArr[ 1 ] start address without matter
 // asmArr[ 2 ] intermediate line heading commands - discard
  
  for ( let i = 3; i < asmArr.length; i ++ ) {
    
    asm = asmArr[ i ].trim( );      // discard surrounding spaces
    row = left( asm, 2 ).hdec( );   // decimal RAM address
    
    // set contents to NOP, zero, empty
    
    if ( row < 128 ) {                   // commands:
    
      coderow = row;                     // decimal RAM address
      mn ="00000000";                    // reset!
      opcomm = "";                       // clear comment
      assembler_to_binary_code( );       // set command, operands and comment
      
    }
   
    if ( row > 127 ) {                   // data:
    
      conrow = row;                      // decimal RAM address
      coninp = "";                       // reset!
      conbin = "00000000";               // reset!- for shift
      concomm = "";                      // clear comment
      define_constant( );                // set constant and comment
      
    }
    
  } 
  
}

function load_ram( rel  ) {     // load RAM rows from file (addresses before commands/data)
    
                        // rel is parameter to shift when reading, then set old addresses to NOP, zero
    let ts;    //  No. substring, separation different number of spaces between addr., mnemonic, operands
    let a1, a2; // ansi code 
    
    asm = asmArr[0];            // Program name from title line 
    const commentPos = asm.indexOf( ';' ) + 1 ;
    
    //prgn = asm.substr( commentPos ).trim( );
    
    asm = asmArr[1];            // 2-digit hexadecimal address, start address
    sta = left( asm, 2 );
    
    // asmArr[2]    - intermediate line heading commands - discard
    
    for ( let i = 3; i < asmArr.length; i ++ ) {
        
        asm = asmArr[ i ].trim( );
        
        hex2 = left( asm, 2 );
        hex1 = right( hex2,1 );            //  right digit
        a2 = hex2.ord( );
        a1 = hex1.ord( );
        
        if ( rel === 0 ) { // check file entries when loading assembler
            
          if ( a2 < 48 || ( a2 > 57 && a2 < 65) || ( a2 > 70 && a2 < 97 ) || a2 > 102 || a1 < 48   ||   ( a1 > 57 && a1 < 65) || ( a1 > 70 && a1 < 97 ) || a1 > 102 )        {
                
                alert( "     ABORT - wrong address: "+ hex2  + "\n\n     Note address 00 to FF or ff. \n--- Error while loading the file! ---" );
                break;
                
             }
            
        }
        
        l_asm = asm.length;                    // Length of the assembler line  
        row = left( asm, 2 ).hdec( );        // decimal RAM address
        
        row = row + rel;                    // new adess (rel only if shifted , otherwise call with 0)
        
        if ( row < 128 ) {                    // Commands
            
            coderow = row;                    // decimal RAM address
            mn = "";                        // reset, otherwise old content remains! 
            op1 = "";
            op2 = "";
            ts = 2;                            // ts === 2 --> second substring is mnemonic of the command
            
            mn = substr( asm, ts, ' ' );
            
            if ( mn === '' ) {               // space instead of :
              
              ts ++;  
              mn = substr( asm, ts, ' ' );
              
            }
            
            if(  mn.length === 2 ) mn = mn + ' ';     // add space for OR, ##
            
            if ( l_asm > 11  ) {
                
                ts ++;
                op1 = substr( asm, ts, ' ' );        // operand after a space
                
                if ( op1 === '' ) {
                  
                  ts ++;                              // more spaces present as separation ...
                  op1 = substr( asm, ts, ' ' );
                  
                }
                
                if ( op1 === '' ) {
                  
                  ts ++;
                  op1 = substr( asm, ts, ' ' );
                  
                }
                
                if ( op1 === '' ) {
                  
                  ts ++;
                  op1 = substr( asm, ts, ' ' );
                  
                }
                
                if ( op1.length === 2  ) op1 = '.' + op1 + '.';  // complete points
                
            } else {
            
                op1 = '';
                
            } // Operand 1
            
            if ( op1.length > 0 ) {                // first operand present
                
                ts ++;
                op2 = substr( asm, ts, ' ' );      // second operand after a space
                
                if ( op2 === '' ) { 
                  
                  ts ++;                           // more spaces present as separation ...
                  op2 = substr( asm, ts, ' ' );
                  
                }
                
                if ( op2 === '' ) {
                  
                  ts ++;
                  op2 = substr( asm, ts, ' ' );
                  
                }
                
                if ( op2 === '' ) {
                  
                  ts ++;
                  op2 = substr( asm, ts, ' ' );
                  
                }
                
                if ( op2.length === 2  ) op2 = '.' + op2 + '.';  // complete points
                
            } else {
                
                op2 = '';
                
            } // Operand 2
            
            if ( l_asm > 19 ) {                        // comment available (with ; position 20, starting from position 21)
                
                opcomm = mid( asm , 21, l_asm - 20 );  // read in without ;  - will be added again internally!
                
            }
            
            assembler_to_binary_code( );            // set command, operands and comment
            
            rf_binRAM( coderow );                     // refresh content  3D RAM
            rf_assFlagsRAM( coderow ); 
            
        }
        
        if ( row > 127 ) {                    // data
            
            conrow = row;                       // decimal RAM address
            coninp = "";                        // reset, because otherwise old content remains at input#1!
            coninp = substr( asm, 2, " " );     // second substring is value of constant
            
            if ( coninp === "" ) coninp = substr( asm, 3, " " );   // if two   spaces as separation
            if ( coninp === "" ) coninp = substr( asm, 4, " " );   // if three spaces as separation 
            if ( coninp === "" ) coninp = substr( asm, 5, " " );   // if four  spaces as separation
            if ( coninp === "" ) coninp = substr( asm, 6, " " );   // if five  spaces as separation
            
            if ( l_asm > 19 ) {                       // comment available (starting from position 20 with ;)
                
                concomm = mid( asm, 21, l_asm - 20 ); // read in without semicolon, will be added again internally
                
            }
            
            define_constant( );                     // set constant and comment
            
            rf_binRAM( conrow );                     // refresh content  3D RAM
            rf_assFlagsRAM( conrow ); 
            
        }
        
    }
    
}

function initial_r0_r128( ) { // initialize address 0 and 128
  
  coderow = 0;                             // set back to default start adr. 00
  restore_instruction( );                  // set  mnemonic Op1,2 comment  in input edits
  mn      = gettext( mn_ );                // read out mnemonic again 
  op1     = gettext( op1_ );               // read out Operand 1 again 
  op2     = gettext( op2_ );               // read out Operand 2 again 
  opcomm  = gettext( opcomm_ );            // read out comment to command again 
  hide( op1_ );                            // hide operand entries
  hide( op2_ );
  
  conrow = 128;                            // set to start constants again
  restore_const( );                        // set constant and comment for it in input edits
  coninp  = gettext( coninp_ );            // read out constant again
  concomm = gettext( concomm_ );           // read out comment to constant again
  
}

function store_ram( ) { // store assembler into asm_tmp (for clipboard) and asmArr (for clear_source_ram) within the specified limits
   
    const cH = s => s === '' ? '00' : s; // for check hexadecimal
   
   if ( ( cH( pfr ).hdec( ) < cH( pto ).hdec( ) + 1 ) && ( cH( dfr ).hdec( ) < cH( dto ).hdec( ) + 1 ) ) {  //  check    start address < = end address
    
    let idx = 0;
    asmArr = [];
    
    asm_tmp.value = '';             // overwrite existing
    asm = "HC680 Assembler    ;" + prgn;
    aps = asm;
    asmArr[ idx ++ ] = asm;
    asm = right(gettext( startadr ), 2 ) + ": ST             ; Startadr."
    aps = aps + '\n' + asm;
    asmArr[ idx ++ ] = asm;
    asm = "Adr Mnm _Op_ _Op_  ;  - Comment -"
    aps = aps + '\n' + asm;
    asmArr[ idx ++ ] = asm;
    // --- program --- 
    if ( pfr.length > 0 && pto.length  > 0 ) {   // no specification - no storage of the program area
      
      row = pfr.hdec( );                        // store program from start address
      
      while ( row < pto.hdec( ) + 1 ) {       // until end address program
        
        asm =  RAM[ row ][ 1 ] + ": " + RAM[ row ][ 3 ].trim( );
        asm = asm + space( 19 - asm.length  ) + comment[ row ];
        aps = aps + '\n' + asm;
        asmArr[ idx ++ ] = asm;
        row ++;
        
      }
      
    }
    
   // --- data ---
   
    if ( dfr.length > 0 && dto.length  > 0 ) {   // no specification - no storage of the data area
      
      row = dfr.hdec( );                        // store from data address start
      
      while ( row < dto.hdec( ) + 1 ) {         // until end address data
        
        asm = RAM[ row ][ 1 ] + ": " + RAM[ row ][ 3 ].trim( ); 
        asm = asm + space( 7 ) + comment [row ]; 
        aps = aps + '\n' + asm;
        asmArr[ idx ++ ] = asm;
        row ++;
        
      }
      
    }
    
    asm_tmp.value = aps;
    
   } else {
   
    alert("program or data \n   'to' < 'from' \nstorage not possible  \n\n --- Error while storing! ---") 
    row = -1;   // as identifier "not stored"
   
   }      
   
} 

// ------------------------------------

function assembler_to_binary_code( ) { // assembler   -->   binary code
    
    switch( mn ) {
                            //     group bit  yy   xx    / yy, xx partly operands (register)
                            //      ---   -   --   --
        case "":                                               // display of the affected flags
                            oc =  "";                          fl = "    ";
              clr_hide12( );
        break;
        case "NOP":
                            oc =  "000"+"0"+"00"+"00";         fl = "    ";
              clr_hide12( );
        break;
        case "CMP":
                            oc =  "000"+"0"+"00"+"01";         fl = "NZVC";
              clr_hide12( );
        break;
        case "SWD":
                            oc =  "000"+"0"+"00"+"10";         fl = "    ";
              clr_hide12( );
        break;
        case "SWM": 
                            oc =  "000"+"0"+"00"+"11";         fl = "    ";
              clr_hide12( );
        break
        ;case "MUL":  
                            oc =  "000"+"0"+"01"+"00";         fl = "NZVC";
              clr_hide12( );
        break;
        case "DIV": 
                            oc =  "000"+"0"+"01"+"01";         fl = "NZVC";
              clr_hide12( );
        break;
        case "PSA": 
                            oc =  "000"+"0"+"01"+"10";         fl = "    ";
              clr_hide12( );
        break;
        case "POA": 
                            oc =  "000"+"0"+"01"+"11";         fl = "NZVC";
              clr_hide12( );
        break;
        case "JSR":  
                            oc =  "000"+"0"+"10"+"00";         fl = "    ";
              clr_hide12( );
        break;
        case "RET":                            // Attention: order code
                            oc =  "000"+"0"+"11"+"00";         fl = "NZVC";
              clr_hide12( );
        break;
        case "JIN": case "JIZ": case "JMP":
        show( op1_ ); show( op1Show );        
        switch( op1 ) {
            case ".+A.":
                if( mn === "JIN" ) oc =  "000"+"0"+"10"+"01";
                if( mn === "JIZ" ) oc =  "000"+"0"+"10"+"10";
                if( mn === "JMP" ) oc =  "000"+"0"+"10"+"11";
                                                                fl = "    ";
            break;
            case ".IA.":
                if( mn === "JIN" ) oc =  "000"+"0"+"11"+"01";
                if( mn === "JIZ" ) oc =  "000"+"0"+"11"+"10";
                if( mn === "JMP" ) oc =  "000"+"0"+"11"+"11";
                                                                fl = "    ";
            break;
            case ".D0.": case ".D1.": case ".A0.": case ".A1.":            // Attention: order code
                if( mn === "JIN" ) oc =  "000"+"1"+"01" + rc( op1 ); 
                if( mn === "JIZ" ) oc =  "000"+"1"+"10" + rc( op1 ); 
                if( mn === "JMP" ) oc =  "000"+"1"+"11" + rc( op1 ); 
                                                                fl = "    ";
            break;
            default:
            oc = "00000000";
            fl = "    ";
        } 
        op2 = "";
        hide( op2_ ); hide( op2Show );
        break;
        case "LDC":                            
        show( op1_ ); show( op1Show );
        switch( op1 ) {
            case ".D0.": case ".D1.": case ".A0.": case ".A1.":            // Attention: order code
                            oc =  "000"+"1"+"00" + rc(op1) ; fl = "NZ  ";
            break;
            default:
            oc = "00000000";
            fl = "    "; 
        }
        op2 = "" ;
        hide( op2_ ); hide( op2Show );
        break;
        case  "## ":
        show( op1_ ); show( op1Show );
        show( op2_ ); show( op2Show );   
        op1 = op1.trim( );
        op2 = op2.trim( );
        
        if (  op1.length === 4 &&  op2.length === 4  &&
            ( op1[0] === '0' || op1[0] === '1' ) &&
            ( op1[1] === '0' || op1[1] === '1' ) &&
            ( op1[2] === '0' || op1[2] === '1' ) &&
            ( op1[3] === '0' || op1[3] === '1' ) &&
            ( op2[0] === '0' || op2[0] === '1' ) &&
            ( op2[1] === '0' || op2[1] === '1' ) &&
            ( op2[2] === '0' || op2[2] === '1' ) &&
            ( op2[3] === '0' || op2[3] === '1' )
            ) {
            // --------------------------------------------------------------//  constants check
                            oc =  op1 + op2               ;  fl = "    "; 
            
        } else {
            oc = "00000000";  
            fl = "    ";
        }
        break;
        case "INP": case "OUT": case "PSH": case "POP": case "SSR": case "GSR": case "BTS": case "SWN":
        show( op1_ ); show( op1Show );
        switch( op1 ) {
            case ".D0.": case ".D1.": case ".A0.": case ".A1.":
            if ( mn === "INP" ) { oc = "001"+"0"+"00" + rc( op1 ); fl = "NZ  " };
            if ( mn === "OUT" ) { oc = "001"+"0"+"01" + rc( op1 ); fl = "    " };
            if ( mn === "PSH" ) { oc = "001"+"0"+"10" + rc( op1 ); fl = "NZ  " };
            if ( mn === "POP" ) { oc = "001"+"0"+"11" + rc( op1 ); fl = "NZ  " };
            if ( mn === "SSR" ) { oc = "001"+"1"+"00" + rc( op1 ); fl = "NZ  " };
            if ( mn === "GSR" ) { oc = "001"+"1"+"01" + rc( op1 ); fl = "NZ  " };
            if ( mn === "BTS" ) { oc = "001"+"1"+"10" + rc( op1 ); fl = "NZ  " };
            if ( mn === "SWN" ) { oc = "001"+"1"+"11" + rc( op1 ); fl = "NZ  " };
            break;
            default:
            oc = "00000000";  
            fl = "    ";  
        }
        op2 = "";
        hide( op2_ ); hide( op2Show );
        break;
        case "SHL": case "SHR": case "ROL": case "ROR": case "CLR": case "INC": case "DEC": case "NOT":
        show( op1_ ); show( op1Show );
        switch( op1 ) {
            case ".D0.": case ".D1.": case ".A0.": case ".A1.":
            if ( mn === "SHL" ) { oc = "010"+"0"+"00" + rc( op1 ); fl = "NZ C" };
            if ( mn === "SHR" ) { oc = "010"+"0"+"01" + rc( op1 ); fl = " Z C" };
            if ( mn === "ROL" ) { oc = "010"+"0"+"10" + rc( op1 ); fl = "NZ C" };
            if ( mn === "ROR" ) { oc = "010"+"0"+"11" + rc( op1 ); fl = "NZ C" };
            if ( mn === "CLR" ) { oc = "010"+"1"+"00" + rc( op1 ); fl = " Z  " };
            if ( mn === "INC" ) { oc = "010"+"1"+"01" + rc( op1 ); fl = "NZVC" };
            if ( mn === "DEC" ) { oc = "010"+"1"+"10" + rc( op1 ); fl = "NZVC" };
            if ( mn === "NOT" ) { oc = "010"+"1"+"11" + rc( op1 ); fl = "NZ  " };
            break;
            default:
            oc = "00000000";
            fl = "    ";
        }
        op2 = "" ;
        hide( op2_ ); hide( op2Show );   
        break;
        case "AND": case "OR ":
        show( op1_ ); show( op1Show );
        show( op2_ ); show( op2Show );
        switch( op1 ) {              
            case ".D0.": case ".D1.": case ".A0.": case ".A1.":
            switch( op2 ) {
                case ".D0.": case ".D1.": case ".A0.": case ".A1.":
                if ( op1 === op2 ) {                        // exclude equality, code for MOV with SR, SP
                    oc = "00000000";  
                    fl = "    ";
                } else {
                    if( mn === "AND" ) oc = "011"+"0" + rc( op1 ) + rc( op2 );          // op1 ‚â† op2
                    if( mn === "OR " ) oc = "011"+"1" + rc( op1 ) + rc( op2 );          // op1 ‚â† op2
                                                                    fl = "NZ  ";
                }
                break;
                default:
                oc = "00000000";
                fl = "    ";
            }  
            break;
            default:
            oc = "00000000";
            fl = "    ";
        } 
        break;
        case  "ADD": case  "SUB":
        show( op1_ ); show( op1Show );
        show( op2_ ); show( op2Show );
        switch( op1 ) {
            case ".D0.": case ".D1.": case ".A0.": case ".A1.":
            switch( op2 ) {
                case ".D0.": case ".D1.": case ".A0.": case ".A1.":   
                if ( op1 === op2 ) {                        // exclude equality, code for MOV with SR, SP
                    oc = "00000000";  
                    fl = "    ";
                } else {                             // Attention: order code:
                    if( mn === "ADD" ) oc = "100"+"0" + rc( op1 ) + rc( op2 ); // 1.        op1 ‚â† op2
                    if( mn === "SUB" ) oc = "101"+"0" + rc( op1 ) + rc( op2 ); // 3.        op1 ‚â† op2
                                                                    fl = "NZVC";   
                }
                break;
                case "[D0]": case "[D1]": case "[A0]": case "[A1]":                // 4th bit addressing type Op.2
                    if( mn === "ADD" ) oc = "100"+"1" + rc( op1 ) + rc( op2 );   // 2.
                    if( mn === "SUB" ) oc = "101"+"1" + rc( op1 ) + rc( op2 );   // 4.
                                                                    fl = "NZVC"; 
                break;
                default:
                oc = "00000000";
                fl = "    ";
            } 
            break;
            default:
            oc = "00000000"; 
            fl = "    ";
        } 
        break;
        case  "MOV":
        show( op1_ ); show( op1Show );
        show( op2_ ); show( op2Show );
        switch( op1 ) {
            case "[D0]": case "[D1]": case "[A0]": case "[A1]":
            switch( op2 ) { 
                case ".D0.": case ".D1.": case ".A0.": case ".A1.":
                            oc = "110"+"0" + rc( op1 ) + rc( op2 ); 
                                                                fl = "NZ  ";
                break;
                default:
                oc = "00000000"; 
                fl = "    ";
            }         
            break;
            case ".D0.": case ".D1.": case ".A0.": case ".A1.":
            switch( op2 ) {
                case "[D0]": case "[D1]": case "[A0]": case "[A1]":
                            oc = "110"+"1" + rc( op1 ) + rc( op2 );
                                                                fl = "NZ  ";
                break;
                case ".D0.": case ".D1.": case ".A0.": case ".A1.":
                if ( op1 === op2 ) {                 //  exclude equality, code for MOV SR <- CC
                    oc = "00000000";  
                    fl = "    ";
                } else {
                            oc = "111"+"0" + rc( op1 ) + rc( op2 );              // op1 ‚â† op2
                                                                fl = "NZ  ";
                }
                break;                
        // !!! from !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                //Attention: order code:
                case ".SR.":
                            oc= "011"+"0" + rc( op1 ) + rc( op1 );     // Code like AND with double op1 !
                                                                fl = "NZ  ";
                break;
                case ".SP.":
                            oc= "011"+"1" + rc( op1 ) + rc( op1 );     // Code like OR with double op1 !
                                                                fl = "NZ  ";
                break;
        // !!! to !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                case ".IA.":                               
                            oc = "111"+"1"+"00" + rc( op1 );  fl = "NZ  ";   // op1 is register
                break;
                default:
                oc = "00000000"; 
                fl = "    ";
            }  
            break;            
        //!!! from !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            case ".SR.":
            switch( op2 ) {
                case ".D0.": case ".D1.": case ".A0.": case ".A1.":
                            oc= "100"+"0" + rc( op2 ) + rc( op2 );     // Code like ADD with double op2 !
                                                                fl = "NZ  ";
                break;
                case ".00.": case ".01.": case ".10.": case ".11.":                        // set IO bits in SR
                            oc = "111"+"0" + op2[1] + op2[2] + op2[1] + op2[2];    // Code instead of MOV Rg=Rg !
                                                                fl = "    ";            // no flags at IO
                break;
                default:
                oc = "00000000"; 
                fl = "    ";
            }  
            break;
            case ".SP.":  
            switch( op2 ) {
                case ".D0.": case ".D1.": case ".A0.": case ".A1.":
                            oc= "101"+"0" + rc( op2 ) + rc( op2 );     // Code like SUB with double op2 !
                                                                fl = "NZ  ";
                break;
                default:
                oc = "00000000"; 
                fl = "    ";
            } 
        //!!! to !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
            break;            
            case ".IA.":                                // IA 1st operand
            switch( op2 ) { 
                case ".D0.": case ".D1.": case ".A0.": case ".A1.":      
                            oc = "111"+"1"+"01" + rc( op2 );   fl = "NZ  ";   // op2 is register
                break;
                default:
                oc = "00000000";  
                fl = "    ";
            }
            break;
            default:
            oc = "00000000"; 
            fl = "    ";
        }      
        break;
        case "LOD":
        show( op1_ ); show( op1Show );
        switch( op1 ) {
            case ".D0.": case ".D1.": case ".A0.": case ".A1.":
                            oc = "111"+"1"+"10" + rc( op1 );   fl = "NZ  ";   // op1 is register  
            break;
            default:
            oc = "00000000"; 
            fl = "    ";
        } 
        op2 = "";
        hide( op2_ ); hide( op2Show );
        break;
        case "STO":
                            oc = "111"+"1"+"11"+"00";         fl = " Z  ";
              clr_hide12( );
        break;
        case "RCL":
                            oc = "111"+"1"+"11"+"01";         fl = " ZV ";
              clr_hide12( );
        break;
        case "CPY":
                            oc = "111"+"1"+"11"+"10";         fl = " ZV ";
              clr_hide12( );
        break;
        case "STP":
                            oc = "111"+"1"+"11"+"11";         fl = "vvvv";
              clr_hide12( );                                      // Flags from the pre-command are preserved!
        break;
        default: // mnemonics
        oc = "00000000";
        fl = "    ";
    
    }
    
    RAM[ coderow ][ 2 ] = oc;                            // insert op code into RAM
    RAM[ coderow ][ 3 ] = mn + " " + op1 + " " + op2;    // insert command/value into RAM
    
    if( oc === "00000000" && mn !== "## " ) {
        
        RAM[ coderow ][ 3 ] = 'NOP';            // set standard
        rf_binRAM( coderow );                   // refresh content  3D RAM  - for shift
        rf_assFlagsRAM( coderow );
        
    }
    
    if( oc === "00000000" && mn === "## " ) {
        
        RAM[ coderow ][ 3 ] = '##  0000 0000';    // set zero
        rf_binRAM( coderow );                   // refresh content  3D RAM  - for shift
        rf_assFlagsRAM( coderow );
        
    }
    
    settext( cadr, dec_to_hex2( coderow ) );        // insert code address hexadecimal
    settext( oc_, oc );                                // insert Op Code
    settext( fl_, fl );                                // insert flags
    comment[ coderow ]  = ";" + opcomm              // Store comment in comment array
    
}

function define_constant( ) {  // assembler --> data definition
    
    settext( conadr, dec_to_hex2( conrow ) );
    
    // coninp = coninp_.value; //  ==> in animate( )
    
    ansi = coninp.ord( );
    
    if ( ansi > 47 && ansi < 58 || ( ansi === 45 && coninp.length > 1 ) ) {        // decimal digit or minus sign at the beginning
        
        conval = coninp.val( );        
        conbin = dec_to_bin8( conval );        // convert to binary number (negative: two's complement)  
        
        if ( conval  > -129 && conval < 128 ) {
            
            conalt = dec_to_bin8( conval ).bdec( ).str( );    // alternative representation of the input character/number
            settext( conalt_, conalt );
            settext( conans, conval.chr( ) );                // display character
            
        } else {   // --- numeric input: < -128 or > 127 -> OVERFLOW -> set to zero ---
            
            coninp = '0';
            conbin = '00000000';
            coninp_.value = coninp;
            settext( conalt_, '' );
            settext( conans, '' );
            
        }
        
    } else if ( ( ansi === 36 || ansi === 72 || ansi === 104 ) && coninp.length === 3 ) {    //  $ or H or h at the beginning: Hexadecimal number
        
        conbin = hex2_to_bin8( coninp[ 1 ] + coninp[ 2 ] );            // hexadecimal number to binary number  
        conval = conbin.bdec( );                                    // corrected input value (letter above F, f to 0)
        conalt = d255_to_bin8( conval ).bdec( ).str( );
        settext( conalt_, conalt );                                    // alternative representation of the input character/number
        settext( conans, conval.chr( ) );                            // display character
        
    } else {
        
        if (  coninp.length === 1 ){
            
            conbin = d255_to_bin8( ansi );                            // ANSI code of the character binary
            settext( conalt_, bin8_to_dec( conbin ).str( ) );        // value of the character
            settext( conans, ansi.str( ) );                            // ANSI code of the character decimal
             
        } else {    //  more than one character
            
            coninp = '0';
            conbin = '00000000';
            settext( conalt_, '' );
            settext( conans, '' );
            
        }
        
    }
    
    settext( conbin_, conbin );                                    // display binary
    settext( conhex, bin8_to_hex2( conbin ) );                    // display hexadecimal
    RAM[ conrow ][ 2 ] = conbin;                                 // store in binary form in RAM
    RAM[ conrow ][ 3 ] = coninp + sp_h( coninp.length ) + gettext( conhex ); // display value in RAM
    
    if ( conbin === '00000000' ) {
        
        rf_binRAM( conrow );                 // refresh content  3D RAM  - for shift
        rf_assFlagsRAM( conrow );
        
    }
    
    comment[ conrow ] = ";" + concomm;                            // store constant comment in comment array
    
}

// --- auxiliary procedures program run ---

function ram_adr_cykl( ) { // Intercept RAM area overflow, address cyclically in RAM

  if( row > 255 ) row = row - 256;  
  if( row <   0 ) row = row + 256;
  
}

function set_IC( ) {                // set Instruction Counter  (cyclic)
    
    // catch jump error/RAM range overflow:
    
    if( ic_dec > 255 ) ic_dec = ic_dec - 256;  // program execution cyclically in RAM
    if( ic_dec <   0 ) ic_dec = ic_dec + 256;  // program execution cyclically in RAM
    
    IC = d255_to_bin8( ic_dec );               // set instruction counter
    
    rf_IC( );                                 // refresh 3D IC
    
}

function show_set_IC( ) { //  show:   IC manual input 

  show( drawSet_IC );
  show( set_hexIC );
  show( setIC );
  show( drawICHex );
  
}

function hide_set_IC( ) { // hide: IC manual input  
  
  hide( drawSet_IC );
  hide( set_hexIC );
  hide( setIC );
  hide( drawICHex );
  
}

function set_D1( bytewert ) { // make the entry in D1 visible for store/copy commands (clock)
    
    R[1] = bytewert;                                               // put down in D1 
    rf_R(1);
    
    if ( fullspeed  === 0 )    set_clock( );
    
}

function push_b_res( ) {                       // put result byte on stack
    
    temp = bin8_to_dec( b_res );
    RAM[ starow ][2] = b_res;                                 // binary
    rf_binRAM( starow );
    
    RAM[ starow ][3] = temp + sp_h( temp.str( ).length ) + bin8_to_hex2( b_res );   // decimal hexadecimal
    rf_assFlagsRAM( starow );
    
}

function shift_ALRx( mulBit ) { // ALU multiplication according to Booth: ALR_ARL_ALx >> shift by 1 bit
    
        // settext( booth, mulBit + '¬ª Booth' ); // ...
    
    ALx = right( ARL, 1 );
    rf_ALx( );
    ARL = right( ALR, 1 ) + left( ARL,7 );
    rf_ARL( );
    ALR = '¬ª' + mid( ALR, 2, 1 ) + mid( ALR, 2, 7 );   // >> shift by 1 bit
    rf_ALR( );
    
}


// ----- Micro Graphic Adapter (MGA) -----

function mga_display( ) { //  Micro-Graphic-Adapter: display from RAM
  
  for ( let i = 1; i < 9; i ++ ) {
    
    mga[ i ] = RAM[ 247 + i ][2];
    
    for ( let j = 1; j < 9;  j ++ ) {
      
      // fill maxipixel with white/black: byte 1 .. 8, pixel 1 .. 8
      
      if ( mid( mga[ i ], j, 1 ) === "0" ) {
        
        iMeshMGA.setColorAt( ( i - 1 ) * 8 + j - 1, colorWhite );
        
      } else {
        
        iMeshMGA.setColorAt( ( i - 1 ) * 8 + j - 1, colorBlack );
        
      }
      
    }
    
  }
  
  iMeshMGA.instanceColor.needsUpdate = true;
  
}

function click_mga( instanceId ) {                    // click in the MGA display
    
    let btmp1 = '';
    let btmp2 = '';
    let tmp = 0;
    
    // write pixel address and status into RAM byte 247 = hF7 (NOTE! -1 -> store as values 0 to 7)
    
    const ip = Math.floor( instanceId / 8 ) + 1; //  1 .. 8
    const jp = instanceId % 8 + 1;
    
    mgarow = RAM[ 247 + ip ][2];      //   get MGA row from RAM ...  
    pix = mid( mgarow, jp, 1 );       // ... therein pixel in column jp (1 to 8)
    
    btmp1 = pix + dec_to_bin3( ip - 1 ) + mk + dec_to_bin3( jp - 1 ); //  generate MGA address/pixel row ...
    RAM[ 247 ][2] = btmp1;                                             // ... write into RAM (addr hF7) in binary form
    rf_binRAM( 247 );
    
    tmp = bin8_to_dec( btmp1 );
    btmp2 = tmp.str( );
    
    RAM[ 247 ][3] = btmp2 + sp_h( btmp2.length ) + bin8_to_hex2( btmp1 );     // write value decimal, hexadecimal
    rf_assFlagsRAM( 247 );
    
}

function refresh_mga( ) {                 // Refresh MGA display after change
  
  let btmp1 = '';
  let btmp2 = '';
  let tmp = 0;
  
  if  ( mgapix !== left( RAM[ 247 ][2], 4 ) + 'm' + right( RAM[ 247 ][2], 3 ) ) {
    
   // pixel address row in RAM byte 247 = hF7 has changed (without mouse!)
    mgapix = RAM[ 247 ][2];                  // new take over
    ip     = mid( mgapix, 2, 3 ).bdec( ) + 1;    // row  (No. 1 to 8)
    jp     = mid( mgapix, 6, 3 ).bdec( ) + 1;    // column (No. 1 to 8)
    pix    = left( mgapix, 1, 1 ); 
    mgarow = RAM[ 247 + ip ][2];                 // get MGA row from RAM
    mgarow = left( mgarow, jp - 1 ) + pix + right( mgarow, 8 - jp ); // generate new MGA row  ... 
    RAM[ 247 + ip ][2] =  mgarow;                                    // ... write into RAM binary
    rf_binRAM( 247 + ip );
    tmp = bin8_to_dec( mgarow );
    btmp1 = tmp.str( );
    RAM[ 247 + ip ][3] = btmp1 + sp_h( btmp1.length ) + bin8_to_hex2( mgarow ) // write value decimal, hexadecimal
    
  }
  
  for ( let i = 1; i <= 8; i ++ ) {
                          
    if ( mga[ i ] !== RAM[ 247 + i ][2] ) {  // when a display row is changed
      
      mga_display( );   // Micro-Graphic-Adapter: create and display the entire display from RAM ...
      break;            // ... then abort
      
    }
    
  }

}

// ---------------------------

function run_binary_code( ) {           // program run of the machine program (8 bit binary code)
    
    // --- initialization program run ---
    
    progAss = false;        
    progRuns = true;
    
    coderow = 0                        // set to beginning
    restore_instruction( );            // put Mnemonic, Op1,2 and comment in input edits
    conrow  = 128                      // set to beginning
    restore_const( );                  // Set constant (input) with comment
    
    //debugfile = gettext( debugfn_ );         
    
    hide_assembler_controls( ); 
    hide( clrio );                                // button IO protocol (delete, hide)
                    //hide( shio );               // checkbox IO protocol - hide ???
    //hide( shcache );                            // checkbox CACHE ( hide )
    hide( xram );                                 // delete-button  RAM (hide)
    hide( xflag );
    
    // show(CACHE)
    show( inpKey_ )                                 // show keyboard input
    
    drawRunStatus.style.color = dred;                // dunkelrote Schrift
    settext( drawRunStatus, 'halt' );
    startbin.style.background = gray;                // execute knob gray
    
    halt         = 0;                                // hold program by operator: 1
    stop        = 0;                                // after STP command: 1
    breakit        = 0;                                // operator abort with X STOP: 1
    break123    = 0;                                // after one of the three breakpoints: 1
    onestep        = 0;                                // for the time being no step further with single step 
    
    for ( let i = 0; i < 4; i ++ ) {
        
        R[i] = "00000000";                            // initialize D and A register with 0
        rf_R( i );
        S[i] = "00000000";                            // initialize SD and SA registers with 0
        rf_S( i );
    }
    
    IR = "00000000";                                // No Operation in IR
    rf_IR( );
    
    hide_set_IC( );                                        // setze IC  mit Text verbergen
    
    // --- IC is set in advance (in the event loop) ---
    
    ic_dec = IC.bdec( );                                // determine decimal start address (binary code) in RAM from IC
    SP = "11110101";                                    // set stack pointer: Addr. 245 = hF5 ...
    rf_SP( );                                           // refresh SP
    starow = 245;                                       // ... and decimal in background variable of the SP    
    RAM[245][4] = "<-SP";                               // ... and marking in the RAM
    
    SR = "00000000";                                    // Status register both nibble to 0
    rf_SR( );                                           // refresh
    
    flags_0_0_0_0( ); // alle Einzelflags Null        // N-Flag (negative),
    //                                                // Z-Flag (zero)
    //                                                // V-Flag (overflow) 
    //                                                // C-Flag (carry)
    
} // end run_binary_code

function decode_binary( ) {    //  decode binary machine instruction
    
    cmdExec = true;
    
    ic_dec = IC.bdec( );                        // determine decimal address of the command in RAM from IC
    ic_dec_fl = ic_dec;                         // notice address for entry of the flags set by the command  
    set_hexIC.value = bin8_to_hex2( IC );       // current IC hexadecimal in edit control
    ramrow = ic_dec;
    rf_assFlagsRAM( ramrow, lGray );            // mark current command row in RAM
    IO_SR = SR[0] + SR[1];                      // type of data IO, left two bits in status registers
    N = SR[4];                                  // read out flags from the status register
    Z = SR[5];  
    V = SR[6]; 
    C = SR[7]; 
    
    oc = RAM[ ic_dec ][2];                      // read  out 8 bit instruction (operation code/machine instruction with operands) ...
    IR = oc;                                    // write opcode/machine instruction/instruction into the Instruction Register
    rf_IR( );
    
    //Operationscode gliedern
    ocg   = oc[0] + oc[1] + oc[2];              // opcode bit 1|2|3 (code group)
    ocb   = oc[3];                              // opcode bit 4    (addressing type/ command variants)
    ocyy  = oc[4] + oc[5];                      // opcode bit 5|6  (partly target register)
    ocxx  = oc[6] + oc[7];                      // opcode bit 7|8  (partly source register)
    ry    = ocyy.bdec( );                       // yy decimal      (partly index of register array)  
    rx    = ocxx.bdec( );                       // xx decimal      (partly index of register array)
    
    // ---  analyze opcode --- decode/execute command  ---    
    
    switch ( ocg )    {            // 3-digit groups 
      
      case   "000":
        
       switch ( ocb ) {    // bit
          
           case  "0":    // = ocb             //  Code right 4 bit fixed - without operand/register specification
           
           ocyyxx = ocyy + " " + ocxx;                // space for grouping - better overview
           
           switch ( ocyyxx ) {               //                ocg b yy xx  <-- grouping operation code/ 8 bit machine instruction
                                             // mn           ' --- - -- --     _XXX  command execution   machine command in command procedure
             case "00 00":
               _NOP( );     break;           // NOP          ' 000 0 00 00     No OPeration     
             case "00 01":
               _CMP( );     break;           // CMP          ' 000 0 00 01     CoMPare D0, D1 (D0-D1)
             case "00 10":
               _SWD( );     break;           // SWD          ' 000 0 00 10     SWap D0, D1
             case "00 11":
               _SWM( );     break;           // SWM          ' 000 0 00 11     SWap Memory Adr(D0), Adr(D1)
               
             case "01 00":
               if( fullspeed === 0 ) {        // MUL          ' 000 0 01 00     MULtiplication D0 <- D0*D1
               _MUL_Booth_ALU( );
               } else {
               _MUL( );
               } 
                            break;
             case "01 01":
               _DIV( );     break;           // DIV          ' 000 0 01 01     DIVision D0 <- D0\D1    ganzzahlig
             case "01 10":
               _PSA( );     break;           // PSA          ' 000 0 01 10     PuSh All Stack <- A,D,SR Reg.
             case "01 11":
               _POA( );     break;           // POA          ' 000 0 01 11     POp All SR,D,A  Reg. <- Stack
             case "10 00":
               _JSR( );     break;           // JSR          ' 000 0 10 00     Jump SubRoutine Stack<-IC+1, A0=0: IC<-IC+A1 else IC<-A0+A1+ST
             
                                      //  ATTENTION!        Observe order of the opcode!  
             case "11 00":                   // RET          ' 000 0 11 00       RETturn subroutine IC <-Stack
               _RET( );     break;
             case "10 01":
             case "11 01":           
               _JIN( );     break;           // JIN +A       ' 000 0 10 01     N=1: IC <- IC + A1       Jump If Negative
                                             // JIN IA       ' 000 0 11 01     N=1: IC <- A0 + A1 + ST  Jump If Negative
             case "10 10":
             case "11 10":            
               _JIZ( );     break;           // JIZ +A       ' 000 0 10 10     Z=1: IC <- IC + A1         Jump If Zero
                                             // JIZ IA       ' 000 0 11 10     Z=1: IC <- A0 + A1   + ST  Jump If Zero
             case "10 11":
             case "11 11":
               _JMP( );     break;           // JMP +A       ' 000 0 10 11          IC <- IC + A1          JuMP
                                             // JMP IA       ' 000 0 11 11          IC <- A0 + A1    + ST  JuMP
           }  // ocyyxx
           break;
           
           case "1":   // = ocb                             code right 2 bit operand register xx 
           
           if ( ocyy === "00" ) { 
             
             _LDC( );       break;           // LDC RG       ' 000 1 00 xx     LoaD Constant Register   Reg xx <- next Byte ##
             
           } else { // ocyy  
              
             _JIN_JIZ_JUMP_Reg( ); break;    // JIN RG       ' 000 1 01 xx     N=1: IC <- Reg xx      Jump If Negative
                                             // JIZ RG       ' 000 1 10 xx     Z=1: IC <- Reg xx      Jump If Zero
                                             // JMP RG       ' 000 1 11 xx          IC <- Reg xx      JuMP
            }
           
       } // ocb
       break;
       
      case "001":
       
       switch ( ocb ) {
         
         case  "0":
           
           switch ( ocyy ) {
             
             case "00":    
               _INP( );     break;           // INP RG       ' 001 0 00 xx     Reg xx      <- INPut
              case "01":
                _OUT( );    break;           // OUT RG       ' 001 0 01 xx     OUTput      <- Reg xx
              case "10": 
                _PSH( );    break;           // PSH RG       ' 001 0 10 xx     PuSH  Stack <- Reg xx
              case "11":
                _POP( );    break;           // POP RG       ' 001 0 11 xx     POP  Reg xx <- Stack
              
           } // ocyy
           break;
           
         case  "1":
          
          switch ( ocyy ) {
             
             case "00": 
                _SSR( );    break;           // SSR RG      ' 001 1 00 xx    Set Shadow Register  Reg xx -> Sxx  (SDx, SAx)
             case "01":   
                _GSR( );    break;           // GSR RG      ' 001 1 01 xx    Get Shadow Register  Reg xx <- Sxx  (SDx, SAx)
             case "10":
                _BTS( );    break;           // BTS RG      ' 001 1 10 xx    BitTest Reg xx with Shadowregister
             case "11":
                _SWN( );    break;           // SWN RG      ' 001 1 11 xx    SWap Nibble  Reg xx
           
          } // ocyy
        
       } // ocb
       break;
       
      case  "010":
       
       switch ( ocb ) {
          
          case "0":
            
            switch ( ocyy ) {
              case "00":
                _SHL( );    break;           // SHL RG       ' 010 0 00 xx     SHift Left   Reg xx
              case "01":
                _SHR( );    break;           // SHR RG       ' 010 0 01 xx     SHift Right  Reg xx
              case "10":
                _ROL( );    break;           // ROL RG       ' 010 0 10 xx     ROtate Left  Reg xx
              case "11":
                _ROR( );    break;           // ROR RG       ' 010 0 11 xx     ROtate Right Reg xx
              
            } // ocyy
          break;
          
          case  "1":
            switch ( ocyy ) {
            
              case "00":
                _CLR( );    break;           // CLR RG       ' 010 1 00 xx     CLear Register Reg xx <- 0
              case "01":
              case "10":
                _INC_DEC( ); break;          // INC RG       ' 010 1 01 xx     INCrement Reg xx  
                                             // DEC RG       ' 010 1 10 xx     DECrement Reg xx   
              case "11":
                _NOT( );    break;           // NOT RG       ' 010 1 11 xx     Reg xx <- NOT Reg xx (bitwise)
                
            } // ocyy 
            
        } // ocb
       break;
       
      case  "011":
       
       if ( ocyy === ocxx ) {
          
            _MOV_SRSP( );   break;           // MOV RG  SR   ' 011 0 yy yy     MOVe      Reg yy <-  SR    *1) xx=yy
                                             // MOV RG  SP   ' 011 1 yy yy     MOVe      Reg yy <-  SP    *2) xx=yy
          } else {
            
            _AND_OR( );     break;           // AND RG  RG   ' 011 0 yy xx     Reg yy <- Reg yy AND Reg xx,  xx<>yy
                                             // OR  RG  RG   ' 011 1 yy xx     Reg yy <- Reg yy OR  Reg xx,  xx<>yy
          }
       break;
       
      case  "100":
       
       if ( ocyy === ocxx ) {
          
            _MOV_SRSP( );   break;           // MOV SR  RG   ' 100 0 xx xx     MOVe      SR <- Reg xx     *3) xx=yy
          
          } else {
          
            _ADD( );        break;           // ADD RG  RG   ' 100 0 yy xx     Reg yy <- Reg yy + Reg xx,    xx<>yy
                                             // ADD RG  [RG] ' 100 1 yy xx     Reg yy <- Reg yy + Adr(Reg xx)
          }
       break;
       
      case  "101":
       
       if ( ocyy === ocxx ) {
           
            _MOV_SRSP( );   break;           // MOV SP  RG   ' 101 0 xx xx     MOVe      SP <- Reg xx     *4) xx=yy 
           
          } else {
           
            _SUB( );        break;           // SUB RG  RG   ' 101 0 yy xx     Reg yy <- Reg yy - Reg xx,    xx<>yy
                                             // SUB RG  [RG] ' 101 1 yy xx     Reg yy <- Reg yy - Adr(Reg xx)
        } 
       break;
       
      case  "110":
            _MOV_RAM( );    break;           // MOV [RG] RG  ' 110 0 yy xx     MOVe Adr(Reg yy) <- Reg xx, 
                                             // MOV RG  [RG] ' 110 1 yy xx     MOVe     Reg yy  <- Adr(Reg xx)
      break;
      case  "111":
        
        if ( ocb === '0' ) {
           
           if ( ocyy === ocxx ) {
            
             _MOV_SRCC( );  break;           // MOV SR  CC   ' 111 0 CC CC     MOVe      SR <- CC..       *5) xx=yy 2Bit IO  
               
           } else {
            
             _MOV_REG( );   break;           // MOV RG  RG   ' 111 0 yy xx     MOVe     Reg yy  <- Reg xx,    xx<>yy
           
           }
            
         } // ocb === '0'
         
        if ( ocb === '1' ) {
                      
          switch( ocyy ) {
            
            case  "00":
            case  "01":
              _MOV_IA( );   break;           // MOV RG  IA   ' 111 1 00 xx     MOVe     Reg xx   <- Adr(A0+A1+ST)
                                             // MOV IA  RG   ' 111 1 01 xx     MOVe Adr(A0+A1+ST)<- Reg xx
            case  "10":
              _LOD( );      break;           // LOD RG       ' 111 1 10 xx     LOad Data Reg xx  <- Adr(h80+A1+ST)
            
            case  "11":                 // Code right 2 bit fixed: 4 single commands (without register specification)
            
            switch ( ocxx ) {
            
              case "00":
                _STO( );    break;           // STO (IO)     ' 111 1 11 00     STOre   file <- Adr(h80+A1+ST) D0 Byte, via D1 (Art: IO) 
              case "01":       
                _RCL( );    break;           // RCL (IO)     ' 111 1 11 01     ReCalL  Adr(h80+A1+ST) <- file   via D1 (Art: IO)  /D0 Byte readed
              case "10":                      
                _CPY( );    break;           // CPY          ' 111 1 11 10     CoPY Adr(A1)<-Adr(A0)    D0 Byte via D1
              case "11":                         
                _STP( );    break;           // STP          ' 111 1 11 11     StoP   stop program
                  
            } // ocxx
            
          } // ocyy
        
        } // ocb === 1
        break;
        default:    //ocg             ' error/ no command
        
    }
    
    // finalizeCommand( ) at the end of the last command parts
    
}

// { *** execution HC680 binary code - machine commands ***

function finalizeCommand( ) { // at the end of the last command parts
  
  set_IC( );
  
  flags_latest( ic_dec_fl );        // show last set flags after command execution behind assembler
  // register_tooltip               // Update tooltips with decimal and hexadecimal contents of registers
  
  cmdExec = false;
  nextCmd =  false;
  goCmd = false;
  t_ = clock.getElapsedTime( );
  
  set_clock( );  // CPU clock
  
}

            // execution
                        // Mnem Op1 Op2  machine command   effect/meaning
                        //               ocg b yy xx
                        //               --- - -- --
                        
                        // NOP         ' 000 0 00 00   No OPeration
function _NOP( ) {
  
  flags_0_0_0_0( );
  ic_dec ++;        // only one command forward
  finalizeCommand( );
  
}
                        // CMP         ' 000 0 00 01   CoMPare D0, D1 (D0-D1)
function _CMP( ) {
  
  AL1 = R[1];                                       // put D1 in ALU
  
  // form one's complement of AL1
  bit = 9;
  AL1 = " " +  AL1;               // set right justified
  rf_AL1( );
  AL2 = "         ";              // unused
  rf_AL2( );
  ALC = "         ";              // unused
  rf_ALC( );
  R9  = "         ";              // 9 bit clear result ...
  ALR = R9;                       // ... and put into the ALU
  rf_ALR( );
  
  bit = 9;
  onCOMPLbitstep = true;
  cmd = 'CMP1';
  goCmd = false; 
  t_ = clock.getElapsedTime( );
  
}

function _CMP1( ) {
  
  b_res = right( ALR, 8 );  
 // end ones complement  
  cmd = 'CMP2';
  goCmd = false;
  t_ = clock.getElapsedTime( );
  
}

function _CMP2( ) {
  
  AL1 = "00000001";                              // 1 for addition in 1st operand
  AL2 =  b_res;                                  // Set result in 2nd operand
  cmd = 'CMP3';
  add_ALU_9( );                                  // Form two's complement by addition
  
}

function _CMP3( ) {
  
  AL1 = R[0];                                    // D0
  AL2 = b_res;                                   //    -D1  for comparison (lower value in the ALU is subtracted)
  cmd = 'CMP4';  
  add_ALU_9( );                                  // Execute comparison D0+(-D1) in the ALU (with flags)
  
}

function _CMP4( ) {
  
  ic_dec ++;   //  Result of subtraction is discarded - flags only
  finalizeCommand( );
  
}

                        // SWD         ' 000 0 00 10   SWap D0, D1
function _SWD( ) {
  
  b_res = R[0];
  R[0] = R[1];
  rf_R(0);
  R[1] = b_res;
  rf_R(1);
  flags_0_0_0_0( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // SWM         ' 000 0 00 11   SWap Memory Adr(D0), Adr(D1)
function _SWM( ) {
  
  row  = R[0].bdec( ); 
  btemp1 = RAM[ row ][2];
  
  temp = R[1].bdec( );  
  btemp2 = RAM[ temp ][2];
   
  RAM[ row ][2] = btemp2;      // binary enter
  RAM[ row ][3] = bin8_to_dec( btemp2 ) + sp_h( ( bin8_to_dec( btemp2 ).str( ) ).length ) + bin8_to_hex2( btemp2 ); // dec. hex insert 
  
  RAM[ temp ][2] = btemp1;      // bin√§r  eintragen    
  RAM[ temp ][3] = bin8_to_dec( btemp1 ) + sp_h( ( bin8_to_dec( btemp1 ).str( ) ).length ) + bin8_to_hex2( btemp1 ); // dec. hex insert 
  
  // refresh content  3D RAM
  rf_binRAM( row );
  rf_assFlagsRAM( row );
  rf_binRAM( temp );
  rf_assFlagsRAM( temp );
  
  flags_0_0_0_0( );
  
  ic_dec ++;
  finalizeCommand( );
  
}
 
                        // MUL         ' 000 0 01 00   MULtiplication D0 <- D0*D1
function _MUL( ) {
  
  tmp = bin8_to_dec( R[0] ) * bin8_to_dec( R[1] ); // decimal result of the mutiplication
  
  if ( tmp > -129 && tmp < 128 ) {      // result in the area
    
    b_res = dec_to_bin8( tmp );
    flags_b_res_N_Z_0_0( );
    
  } else {
  
    b_res = right( tmp.bin( ), 8);      // corresponds to low byte ALM of ALR,ARL
    N = "0";
    Z = "0";
    V = "1";                            // oVerflow - set flag
    C = tmp > 255 ? '1' : '0';          // carry, if one assumes unsigned operands
    
    SR = left( SR, 4 ) + N + Z + V + C; // Set status register with flags
    
  } 

  R[0] = b_res;                         // enter result into D0 
  rf_R( 0 );
  ic_dec ++; 
  finalizeCommand( );
  
}
                        // DIV         ' 000 0 01 01   DIVision D0 <- D0\D1   Rest SD0
function _DIV( ) {
  
  if (  R[1].bdec( ) === 0 ) {   // Catch division by 0
  
    // D0, SD0   remain unchanged 
    N = "0";
    Z = "0";
    V = "1";                            // set oVerflow flag
    C = "0";                           
    
    SR = left( SR, 4 ) + N + Z + V + C; //  set status register with flags 
    alert( "Command was not executed.,  \n  The V-flag is set.  \n   --- Division by 0 --- " );
    
  } else {
  
      // fast calculation (but adjust -128)
    
      if (  R[0].bdec( ) === -128 || R[1].bdec( ) === -128 ) { // OVERFLOW +128 for two's complement in ALU! 
        
        // D0, SD0 remain unchanged
        N ="0";
        Z ="0";
        V ="1";                        // set oVerflow flag   
        C ="0";
        
        SR = left( SR, 4 ) + N + Z + V + C; // set status register with flags  
        
      } else {
        
        // decimal remainder -> insert into shadow register SD0   
        S[0] = dec_to_bin8( bin8_to_dec( R[0] )% bin8_to_dec( R[1] ) );
        rf_S( 0 );
        // decimal quotient -> insert into b_res$ for flags and into D0     
        b_res = dec_to_bin8( Math.trunc( bin8_to_dec( R[0] ) / bin8_to_dec( R[1] ) ) );
        
        R[0] = b_res;
        rf_R( 0 );
        flags_b_res_N_Z_0_0( );
        
      }
    
  }
  
  ic_dec ++;
  finalizeCommand( );
  
}
                        // PSA         ' 000 0 01 10   PuSh All Stack <- A,D,SR Reg.
function _PSA( ) {
  
  // push all four address and data registers and SR on the stack  
  RAM[ starow ][4] = "    ";     // delete old pointer for position stack pointer 
  rf_assFlagsRAM( starow );
  // refresh rf_ ... in push_b_res( );
  b_res = R[3];    
  push_b_res( );                 // A1
  starow --;
  b_res = R[2];    
  push_b_res( );                 // A0
  starow --; 
  b_res = R[1];   
  push_b_res( );                 // D1
  starow --; 
  b_res = R[0];   
  push_b_res( );                 // D0
  starow --; 
  b_res = SR;  
  push_b_res( );                 // SR
  starow --; 
  
  SP = d255_to_bin8( starow );   // enter current address into SP
  rf_SP( );
  
  RAM[ starow ][4] = "<-SP";     // set indicator for position stack pointer 
  rf_assFlagsRAM( starow );
  
  flags_0_0_0_0( );              // set all flags to zero
  ic_dec ++;
  finalizeCommand( );
  
}
                        // POA         ' 000 0 01 11   POp All SR,D,A Reg. <- Stack
function _POA( ) {
  
  //  get all four data and address registers and SR from the stack
  if ( starow < 251 ) {           // SR and 4 registers ...
    
    RAM[ starow ][4] = "    ";    //    delete old pointer for position stack pointer
    rf_assFlagsRAM( starow );
    starow ++;                    // ... stack pointer each 1 direction RAM end 
    SP = d255_to_bin8( starow );  // set SP to top entry in stack memory
    rf_SP( );
    
    SR = RAM[ starow ][2];        // SR
    rf_SR( );
    starow ++;
    R[0] = RAM[ starow ][2];      // D0
    rf_R( 0 );
    starow ++;
    R[1] = RAM[ starow ][2];      // D1
    rf_R( 1 );
    starow ++;
    R[2] = RAM[ starow ][2];      // A0
    rf_R( 2 );
    starow ++;
    R[3] = RAM[ starow ][2];      // A1
    rf_R( 3 );
    
    SP = d255_to_bin8( starow );  // enter current address in SP
    rf_SP( );
    RAM[ starow ][4] = "<-SP";    // set indicator for position stack pointer
    rf_assFlagsRAM( starow );
    
  } else {
    
    alert("error:        RAM end reached! \n  --- stack-error ---" );
    stop = 1;
    
  }
  
  // separate flags from stack into SR for display 
  N = SR[4];
  Z = SR[5];
  V = SR[6];
  C = SR[7];
  ic_dec ++;
  finalizeCommand( );
  
}
                        // JSR         ' 000 0 10 00   Jump SubRoutine Stack<-IC+1, A0=0: IC<-IC+A1 else IC<-A0+A1+ST
function _JSR( ) {
  
  temp = ic_dec  + 1;                  // return address  IC+1                      
  b_res = d255_to_bin8( temp );
  RAM[ starow ][2] = b_res;            // return address  IC+1 to stack,  binary 
  rf_binRAM( starow );
  RAM[ starow ][3] = temp.str() + sp_h( temp.str( ).length ) + bin8_to_hex2( b_res );  // decimal  hexadecimal
  RAM[ starow ][4] = "    ";           // delete old indicator for position stack pointer 
  rf_assFlagsRAM( starow );
  starow --;                           // y 1 smaller address in the stack ...
  SP = d255_to_bin8( starow );         // ... insert in the stack pointer
  rf_SP( );
  RAM[ starow ][4] = "<-SP";           // set indicator for position stack pointer
  rf_assFlagsRAM( starow );
  flags_0_0_0_0( );                    // set all flags to zero 
  
  if ( R[2] === "00000000" ) {                                       // A1 signed
  
    ic_dec = ic_dec + bin8_to_dec( R[3] );  // if A0 = 0: IC <- IC + A1    jump to subroutine
    
  } else {
    
    ic_dec = R[2].bdec( ) + bin8_to_dec( R[3] ) + sta_dec; // IC <- A0 + A1 + ST  jump to subroutine
    
  }
  
  finalizeCommand( );
  
}
                        // RET         ' 000 0 11 00   RETturn subroutine      IC <- Stack
function _RET( ) {
  
  if ( starow < 255  ) {               // not yet at the end of memory
    
    RAM[ starow ][4] = "    ";         // delete old indicator for position stack pointer
    rf_assFlagsRAM( starow );
    starow ++;                         // ... stack pointer 1 direction each End RAM  
    SP = d255_to_bin8( starow );       // SP on top entry
    rf_SP( );
    RAM[ starow ][4] = "<-SP";         // set indicator for position stack pointer
    rf_assFlagsRAM( starow );
    ic_dec = RAM[ starow ][2].bdec( ); // decimal return address from stack ... 
    
  } else {
  
    alert ("error:       RAM end reached! \n  --- stack-error ---" );
    stop = 1;
    //ic_dec --;
    
  }
  
  flags_0_0_0_0( );                         // set all flags to zero
  finalizeCommand( );
  
}
                        // JIN +A      ' 000 0 10 01   N=1: IC <- IC + A1       Jump If Negative
                        // JIN IA      ' 000 0 11 01   N=1: IC <- A0 + A1 + ST  Jump If Negative
function _JIN( ) {
  
  if ( N === "1" ) {                        // if N-Flag = 1                                      ' A1 signed
    
    if ( ocyy === "10" ) ic_dec = ic_dec + bin8_to_dec( R[3] );                         // IC <- IC + A1 
    if ( ocyy === "11" ) ic_dec = R[2].bdec( ) + bin8_to_dec( R[3] ) + sta_dec;         // IC <- A0 + A1 + ST
    
  } else {
    
    ic_dec ++;                              //if N-Flag = 0
    
  }
   
  flags_0_0_0_0( );                         // set all flags to zero 
  finalizeCommand( );
 
}
                        // JIZ +A      ' 000 0 10 10   Z=1: IC <- IC + A1       Jump If Zero
                        // JIZ IA      ' 000 0 11 10   Z=1: IC <- A0 + A1 + ST  Jump If Zero
function _JIZ( ) {
    
    if ( Z === "1" ) {                      //  if Z-Flag = 1                                     ' A1 signed
      
      if ( ocyy === "10" ) ic_dec = ic_dec + bin8_to_dec( R[3] );                         // IC <- IC + A1 
      if ( ocyy === "11" ) ic_dec = R[2].bdec( ) + bin8_to_dec( R[3] ) + sta_dec;          // IC <- A0 + A1 + ST
    
  } else {
  
    ic_dec ++;                             // if Z-Flag = 0
    
  }
    
  flags_0_0_0_0( );                         // set all flags to zero
  finalizeCommand( );
 
}
                        // JMP +A      ' 000 0 10 11          IC <- IC + A1        JuMP
                        // JMP IA      ' 000 0 11 11          IC <- A0 + A1 + ST   JuMP             ' A1 signed
function _JMP( ) {
  
  if( ocyy === "10" ) ic_dec = ic_dec + bin8_to_dec( R[3] );                            // IC <- IC + A1 
  if( ocyy === "11" ) ic_dec = R[2].bdec( ) + bin8_to_dec( R[3] ) + sta_dec;             // IC <- A0 + A1  + ST
  flags_0_0_0_0( );                            // set all flags to zero
  finalizeCommand( );
  
}
                        // LDC RG      ' 000 1 00 xx   LoaD Constant  Reg xx <- next Byte ##
function _LDC( ) {
  
  ic_dec ++;                      // row with constant byte ## CCCC CCCC  ... further ...
  b_res =  RAM[ ic_dec ][2];
  R[ rx ] = b_res;
  rf_R( rx );
  flags_b_res_N_Z_0_0( );  
  ic_dec ++;                      // ... with command line after next
  finalizeCommand( );
  
}
                        // JIN RG      ' 000 1 01 xx   N=1: IC <- Reg xx   Jump If Negative
                        // JIZ RG      ' 000 1 10 xx   Z=1: IC <- Reg xx   Jump If Zero
                        // JMP RG      ' 000 1 11 xx        IC <- Reg xx   JuMP
function _JIN_JIZ_JUMP_Reg( ) {
  
  if ( ( ocyy === "01" && N === "1" ) || ( ocyy === "10" && Z === "1" ) || ( ocyy === "11" ) ) { // JUMPs register
  
    ic_dec = R[ rx ].bdec( )                 // IC <- Reg xx
    
  } else {                                  // also A1 = R[3] value unsigned
  
    ic_dec ++;
    
  }
  
  flags_0_0_0_0( );                         // set all flags to zero    
  finalizeCommand( );
  
}
                        // INP RG (IO) ' 001 0 00 xx   Reg xx           <- INPut
function _INP( ) {
  
  // --- input system (user input during program run)
  input_system( );      // make_input( ); finalize_input( );     controlled in animate( ) 
  
}
                        // OUT RG (IO) ' 001 0 01 xx   OUTput           <- Reg xx
function _OUT( ) {
  
  boutp = R[ rx ];
  
  // --- output system (during program run)
  output_system( );
  
  flags_0_0_0_0( );     // set all flags to zero
  ic_dec ++;
  finalizeCommand( );
  
}
                        // PSH RG      ' 001 0 10 xx   PuSH  Stack      <- Reg xx
function _PSH( ) {
  
  starow = SP.bdec( );
  RAM[ starow ][4] = "    ";                // delete old indicator for position stack pointer
  rf_assFlagsRAM( starow );
  b_res =  R[ rx ];
  push_b_res( );
  starow --;                                // by 1 smaller address  ...
  SP = d255_to_bin8( starow );              //   ... write into SP
  rf_SP( );
  RAM[ starow ][4] = "<-SP";                // set indicator for position stack pointer
  rf_assFlagsRAM( starow );
  flags_b_res_N_Z_0_0( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // POP RG      ' 001 0 11 xx   POP  Reg xx      <- Stack
function _POP( ) {
  
  if ( starow < 255 ) {
    
    RAM[ starow ][4] = "    ";           // delete old indicator for position stack pointer
    rf_assFlagsRAM( starow );
    starow ++;                              // stack pointer 1 further in direction of end RAM ...
    SP = d255_to_bin8( starow );            // ... write into SP
    rf_SP( );    
    RAM[ starow ][4] = "<-SP";              // set indicator for position stack pointer
    rf_assFlagsRAM( starow );
    b_res = RAM[ starow ][2]; 
    R[ rx ] = b_res;
    rf_R( rx );
    flags_b_res_N_Z_0_0( );
    ic_dec ++;
    
  } else {
    
    alert("error:      RAM end reached! \n  --- stack-error ---" );
    stop = 1;
    
  }
  
  finalizeCommand( );
  
}
                        // SSR RG      ' 001 1 00 xx   Set Shadow Register  Reg xx -> Sxx  (SDx, SAx)
function _SSR( ) {
  
  b_res = R[ rx ];
  S[ rx ] = b_res;
  rf_S( rx );
  flags_b_res_N_Z_0_0( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // GSR RG      ' 001 1 01 xx   Get Shadow Register  Reg xx <- Sxx  (SDx, SAx)
function _GSR( ) {
  
  b_res = S[ rx ];
  R[ rx ] = b_res;
  rf_R( rx );
  flags_b_res_N_Z_0_0( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // BTS RG      ' 001 1 10 xx   BitTest Reg xx with Shadowregister
function _BTS( ) {
  
  AL1 = " " +  R[ rx ];                // set right-justified in AL1
  rf_AL1( );
  AL2 = " " +  S[ rx ];                // set right-justified in AL2
  rf_AL2( );
  ALC = "         ";                   // unused
  rf_ALC( );
  R9  = "         ";                   // 9 bit - clear result ...                             
  ALR = R9;                            // ... and put into the ALU 
  rf_ALR( );
  
  bit = 9;
  
  onBTSbitstep = true;  // bit steps are realised in function  animate( )
  
 }

function _BTS1( ) {
  
  b_res = right( ALR, 8 );                  // result is discarded, only flags
  flags_b_res_N_Z_0_0( );                   // match - set zero flag, negative flag if default negative but register positive
  ic_dec ++;
  finalizeCommand( );
  
}
                        // SWN RG      ' 001 1 11 xx   SWap Nibble  Reg xx
function _SWN( ) {
  
  b_res = right( R[ rx ], 4 ) + left( R[ rx ], 4 );
  R[ rx ] = b_res; 
  rf_R( rx );
  flags_b_res_N_Z_0_0( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // SHL RG      ' 010 0 00 xx   SHift Left   Reg xx
function _SHL( ) {
  
  N = mid( R[ rx ], 2, 1 );                         // Negative flag (after shifting)
  Z = right(R[ rx ], 7 ).bdec( ) === 0 ? "1" : "0"; // Zero flag
  V = "0"                                           // oVerflow flag
  C = left( R[ rx ], 1 );                           // Carry flag
  AL1 = "         ";                                // unused
  rf_AL1( );
  AL2 = "         ";                                // unbenutzt
  rf_AL2( );
  ALC = "         ";                                // unbenutzt
  rf_ALC( );
  ALR = "0" + R[ rx ];                              // put into ALU
  rf_ALR( );
  
  cmd = 'SHL1';
  goCmd = false;
  t_ = clock.getElapsedTime( );
  
}

function _SHL1( ) {
  
  ALR = C + mid( ALR, 3, 7 ) + "0";                // shift left
  rf_ALR( );
  
  R[ rx ] = right( ALR, 8 );
  rf_R( rx );
  SR = left( SR, 4 ) + N + Z + V + C;              // set status register with flags
  rf_SR( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // SHR RG      ' 010 0 01 xx   SHift Right  Reg xx
function _SHR( ) {
  
  N = "0";                                          // Negative flag
  Z = left( R[ rx ], 7 ).bdec( ) === 0 ? "1" : "0"; // set Zero flag 
  V = "0"
  C = right( R[ rx ], 1 )                           // Carry flag
  AL1 = "         ";                                // unused
  rf_AL1( );
  AL2 = "         ";                                // unused
  rf_AL2( );
  ALC = "         ";                                // unused
  rf_ALC( );
  ALR = "0" + R[ rx ];                              // put into ALU
  rf_ALR( );
  cmd = 'SHR1';
  goCmd = false;
  t_ = clock.getElapsedTime( );
  
}

function _SHR1( ) {
  
  ALR = C + "0" + mid( ALR, 2, 7 );                // shift right
  rf_ALR( );
  R[ rx ] = right( ALR, 8 );
  rf_R( rx );
  SR = left( SR, 4 ) + N + Z + V + C;              // set status register with flags
  rf_SR( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // ROL RG      ' 010 0 10 xx   ROtate Left  Reg xx
function _ROL( ) {
  
  N = mid( R[ rx ], 2, 1 );                 // Negative flag (after rotation)
  Z = R[ rx ] === "00000000" ? "1" : "0";
  V = "0"
  C = left( R[ rx ], 1 )                    // Carry flag 
  AL1 = "         ";                        // unused
  rf_AL1( );
  AL2 = "         ";                        // unused
  rf_AL2( );
  ALC = "         ";                        // unused
  rf_ALC( );
  ALR = "0" + R[ rx ];                      // put into ALU
  rf_ALR( );
  cmd = 'ROL1';
  goCmd = false;
  t_ = clock.getElapsedTime( );
  
}

function _ROL1( ) {
  
  ALR = C + mid( ALR, 3, 7 ) + C;           // rotate left
  rf_ALR( );
  R[ rx ] = right( ALR, 8 );
  rf_R( rx );
  SR = left( SR, 4 ) + N + Z + V + C;       // set status register with flags
  rf_SR( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // ROR RG      ' 010 0 11 xx   ROtate Right Reg xx
function _ROR( ) {
  
  N = right( R[ rx ], 1 );                  // Negative flag (after rotation)
  Z = R[ rx ] === "00000000" ? "1" : "0";                
  V = "0";
  C = N;                                    // Carry flag equals Negative-flag    
  AL1 = "         ";                        // unused
  rf_AL1( );
  AL2 = "         ";                        // unused
  rf_AL2( );
  ALC = "         ";                        // unused
  rf_ALC( );
  ALR = "0" + R[ rx ];                      // put into ALU 
  rf_ALR( );
  cmd = 'ROR1';
  goCmd = false;
  t_ = clock.getElapsedTime( ); 
  
}

function _ROR1( ) {  
  
  ALR = C + C + mid( ALR, 2, 7 );           // rotate right
  rf_ALR( );
  R[ rx ] =  right( ALR, 8 );
  rf_R( rx );
  SR = left( SR, 4 ) + N + Z + V + C;       // set status register with flags
  rf_SR( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // CLR RG      ' 010 1 00 xx   CLear Register Reg xx <- 0
function _CLR( ) {
  
  b_res = "00000000"; 
  R[ rx ] = b_res;                          // clear register
  rf_R( rx );  
  flags_b_res_N_Z_0_0( );   
  ic_dec ++;
  finalizeCommand( );
  
}
                        // INC RG      ' 010 1 01 xx   INCrement Reg xx
                        // DEC RG      ' 010 1 10 xx   DECrement Reg xx
function _INC_DEC( ) {
  
  AL1 = R[ rx ];
  rf_AL1( );
  if ( ocyy === "01" ) AL2 = "00000001";          // +1 (INC) 
  if ( ocyy === "10" ) AL2 = "11111111";          // -1 (DEC)
  rf_AL2( );
  cmd = 'INC_DEC1';
  add_ALU_9( );                                   // addition in the ALU (with flags)
  
}

function _INC_DEC1( ) {
  
  R[ rx ] = right( ALR, 8 );
  rf_R( rx );
  ic_dec ++;
  finalizeCommand( ); 
  
}
                        // NOT RG      ' 010 1 11 xx   Reg xx <- NOT Reg xx (bitweise)
function _NOT( ) {
  
  AL1 = R[ rx ];                                   // set into  ALU
  rf_AL1( );
  
  // form one's complement in the ALU
  
  AL1 = " " +  AL1;               // set right justified
  rf_AL1( );
  AL2 = "         ";              // unused
  rf_AL2( );
  ALC = "         ";              // unused
  rf_ALC( );
  R9  = "         ";              // 9 bit clear result ...
  ALR = R9;                       // ... and put into the ALU
  rf_ALR( );
  
  bit = 9;
  onCOMPLbitstep = true;
  cmd = 'NOT1';
  goCmd = false; 
  t_ = clock.getElapsedTime( );
  
}

function _NOT1( ) {
  
  b_res = right( ALR, 8 );
    
  cmd = 'NOT2';
  goCmd = false;
  t_ = clock.getElapsedTime( );  
  
}

function _NOT2( ) {
  
  R[ rx ] = right( b_res, 8 );                     // fill in result
  rf_R( rx );
  flags_b_res_N_Z_0_0( );  
  ic_dec ++;
  finalizeCommand( )
  
}
                        // MOV RG  SR  ' 011 0 yy yy   MOVe   Reg yy <-  SR      *1) xx=yy (Observe sequence code!)
                        // MOV RG  SP  ' 011 1 yy yy   MOVe   Reg yy <-  SP      *2) xx=yy
                        // MOV SR  RG  ' 100 0 xx xx   MOVe       SR <- Reg xx   *3) xx=yy
                        // MOV SP  RG  ' 101 0 xx xx   MOVe       SP <- Reg xx   *4) xx=yy
function _MOV_SRSP( ) {
  
  if ( ocg === "011" ) {
    
    if ( ocb === "0" ) b_res = SR;     // <- SR
    if ( ocb === "1" ) b_res = SP;     // <- SP
    
    R[ ry ] =  b_res;
    
  }
  
  if ( ocg === "100" ) {
  
    b_res = R[ rx ]; 
    SR = b_res;                        // SR <-
    
  }
  
  if ( ocg === "101" ) {
  
    b_res = R[ rx ];  
    SP = b_res;                        // SP <-
    
  }
  
  flags_b_res_N_Z_0_0( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // AND RG  RG  ' 011 0 yy xx   Reg yy <- Reg yy AND Reg xx, xx<>yy
                        // OR  RG  RG  ' 011 1 yy xx   Reg yy <- Reg yy OR  Reg xx, xx<>yy
function _AND_OR( ) {
  
  bit = 9;
  AL1 = " " + R[ rx ];                 // set right 8Bit of the 9Bit arithmetic unit
  rf_AL1( );
  AL2 = " " + R[ ry ];
  rf_AL2( );
  ALC = "         ";                   // unused
  rf_ALC( );
  R9 = "         ";                    // 9 bit clear result ...
  ALR = R9;                            // ... and put into the ALU
  rf_ALR( );
  
  onANDORbitstep = true;
  
}

function _AND_OR1( ) {  
  
  b_res = right( ALR, 8 );
  R[ ry ] = b_res;
  flags_b_res_N_Z_0_0( ); 
  ic_dec ++;
  finalizeCommand( );;
  
}
                        // ADD RG  RG  ' 100 0 yy xx   Reg yy <- Reg yy + Reg xx,   xx<>yy 
                        // ADD RG [RG] ' 100 1 yy xx   Reg yy <- Reg yy + Adr(Reg xx)
function _ADD( ) {
  
  if ( ocb === "0" ) AL1 = R[ rx ];                        // ADD RG  RG
                              // also A1 = R[3] value unsigned
  if ( ocb === "1" ) AL1 = RAM[ R[ rx ].bdec( ) ][2];      // ADD Reg [Reg]
  rf_AL1( );
  
  AL2 = R[ ry ];
  rf_AL2( );
  cmd = 'ADD1';
  add_ALU_9( );                                   // addition in the ALU (with flags)
  
}

function _ADD1( ) {
  
  R[ ry ] = right( ALR, 8 );
  rf_R( ry );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // SUB RG  RG  ' 101 0 yy xx   Reg yy <- Reg yy - Reg xx,   xx<>yy
                        // SUB RG  [RG]  ' 101 1 yy xx   Reg yy <- Reg yy - Adr(Reg xx)
function _SUB( ) {
  
  if ( ocb === "0" ) AL1 = R[ rx ];                        // SUB RG  RG      
                             // also A1 = R[3] value unsigned
  if ( ocb === "1" ) AL1 = RAM[ R[ rx ].bdec( ) ][2];      // SUB Reg [Reg] 
  rf_AL1( );
  
  // form one's complement
  bit = 9;
  AL1 = " " +  AL1;               // set right justified
  rf_AL1( );
  AL2 = "         ";              // unused
  rf_AL2( );
  ALC = "         ";              // unused
  rf_ALC( );
  R9  = "         ";              // 9 bit clear result ...
  ALR = R9;                       // ... and put into the ALU
  rf_ALR( );
  
  bit = 9;
  onCOMPLbitstep = true;
  cmd = 'SUB1';
  goCmd = false; 
  t_ = clock.getElapsedTime( );
  
}

function _SUB1( ) {
  
  b_res = right( ALR, 8 );
  
  cmd = 'SUB2';
  goCmd = false;
  t_ = clock.getElapsedTime( );
  
}

function _SUB2( ) {
  
  AL1 = "00000001";                            // 1 for addition in 1st operand
  rf_AL1( );
  AL2 = b_res;                                 // set result in 2nd operand
  rf_AL2( );
  cmd = 'SUB3';
  add_ALU_9( );                                // form two's complement by addition:
  
}

function _SUB3( ) {
  
  AL1 = R[ ry ];                               // y
  rf_AL1( );
  AL2 = b_res;                                 //    -x   (bottom value in the ALU is subtracted)
  cmd = 'SUB4';
  add_ALU_9( );                                // addition y + (-x) in the ALU (with flags)
  
}

function _SUB4( ) {
  
  R[ ry ] = right( ALR, 8 );
  rf_R( ry );
  ic_dec ++;
  finalizeCommand( )
  
}
                        // MOV [RG] RG ' 110 0 yy xx   MOVe Adr(Reg yy)   <- Reg xx 
                        // MOV RG [RG] ' 110 1 yy xx   MOVe     Reg yy    <- Adr(Reg xx)
function _MOV_RAM( ) {
  
  if ( ocb === "0" ) {                         // MOV [Reg] <- Reg
  
    row = R[ ry ].bdec( );    //  also A1 = R[3] value unsigned
    rf_R( rx );
    RAM[ row ][2] = b_res;         // binary enter 
    rf_binRAM( row );
    RAM[ row ][3] = bin8_to_dec( b_res ).str( ) + sp_h( bin8_to_dec( b_res ).str( ).length ) + bin8_to_hex2( b_res ); // dec. hex insert 
    rf_assFlagsRAM( row );
    
  }
  
 if ( ocb === "1" ) {                          // MOV  Reg  <- [Reg] 
    
    row = R[ rx ].bdec( );    // also A1 = R[3] value unsigned
    b_res = RAM[ row ][2];
    R[ ry ] = b_res;
    rf_R( ry );
    
  }
  
  flags_b_res_N_Z_0_0( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // MOV SR  CC  ' 111 0 CC CC   MOVe       SR <- CC..    *5) xx=yy 2 bit IO
function _MOV_SRCC( ) {
  
  SR = ocxx + right( SR, 6 );           // <- CC.. .... set left two bit (IO)
  flags_0_0_0_0( );                     // set all flags to zero
  ic_dec ++;
  finalizeCommand( );
  
}
                        // MOV RG  RG  ' 111 0 yy xx   MOVe     Reg yy    <- Reg xx, xx<>yy
function _MOV_REG( ) {
  
  b_res = R[ rx ];  
  R[ ry ] = b_res;
  rf_R( ry );
  flags_b_res_N_Z_0_0( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // MOV RG  IA  ' 111 1 00 xx   MOVe     Reg xx    <- Adr(A0+A1+ST)
                        // MOV IA  RG  ' 111 1 01 xx   MOVe Adr(A0+A1+ST) <- Reg xx  
function _MOV_IA( ) {
  
  if ( ocyy  === "00" ) {                        // Reg <- Adr.(A0 + A1 + ST)
  
    row = R[2].bdec( ) + bin8_to_dec( R[3] ) + sta_dec; // A1 signed
    ram_adr_cykl( );                             // intercept RAM area overflow, address cyclically in RAM
    b_res = RAM[ row ][2]; 
    R[ rx ] = b_res;              // target register here (as with input) is Reg xx 
    rf_R( rx );
    
  }
  
  if ( ocyy  === "01" ) {                         // Adr.(A0 + A1 + ST)  <- Reg
    
    row = R[2].bdec( ) + bin8_to_dec( R[3] ) + sta_dec; // A1  signed
    ram_adr_cykl( );                             // intercept RAM area overflow, address cyclically in RAM
    b_res =  R[ rx ];                            // here: source register Reg xx
    RAM[ row ][2] = b_res;                       // binary enter
    rf_binRAM( row );
    RAM[ row ][3] = bin8_to_dec( b_res ).str( ) + sp_h( bin8_to_dec( b_res ).str( ).length ) + bin8_to_hex2( b_res ); // dec. hex. enter
    rf_assFlagsRAM( row );
    
  }
  
  flags_b_res_N_Z_0_0( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // LOD RG      ' 111 1 10 xx   LOad Data Reg xx   <- Adr(h80+A1+ST)
function _LOD( ) {
  
  // from byte 128 intended for data
  row = 128 + bin8_to_dec( R[3] ) + sta_dec; //  A1 signed
  ram_adr_cykl( );                               // intercept RAM area overflow, address cyclically in RAM
  b_res = RAM[ row ][2];
  R[ rx ] = b_res;
  rf_R( rx );
  flags_b_res_N_Z_0_0( );
  ic_dec ++;
  finalizeCommand( );
  
}
                        // STO (IO)    ' 111 1 11 00   STOre   Datei <- Adr(h80+A1+ST) D0 Byte  via D1  (Art: IO)
function _STO( ) {
  
  hcxTextArea.value = '';
  
  // from byte 128 intended for data
                // A1 signed
  row = 128 + bin8_to_dec( R[3] ) + sta_dec;  // from Adr.(h80 + A1 + ST) store D0 byte externally 
  ram_adr_cykl( );                            // intercept RAM area overflow, address cyclically in RAM
  
  //IO_SR$                                    // type data IO, left two bits in SR
  temp = 0;                                   // counting data
             //   D0 unsigned             
  const ccnt = R[0].bdec( );  // Anzahl der zu kopierenden Byte in D0 (vorzeichenlos)
  
  while ( temp < ccnt ) { // Number of bytes to be copied in D0 (unsigned)
  
    btemp1 = RAM[ row ][2];                  // 8 bit binary for D1 entry
    set_D1( btemp1 )                         // place in D1 and make visible
    
    switch ( IO_SR ) {    // Type of storage:
    
      case "00":
        btemp1 = btemp1.bdec( ).chr( );     //  character
        break;
      case "01":
        btemp1 = bin8_to_dec( btemp1 );     //  decimal
        break;
      case "10": 
        btemp1 = bin8_to_hex2( btemp1 );    //  hexadecimal: xx
        break
      case "11":
       // btemp1 = btemp1;                  //  8 bit binary (take over)
        
    }
    
    hcxTextArea.value += temp < ccnt - 1 ? btemp1 + '\n' : btemp1;
    
    row ++; 
    if ( row === 256 ) {        //  RAM end ...   ' messagebox("RAM-end!","Error while storing the file \nless data written    ",0)
      break;                    // ... abort, less data are written
    }
    
    temp ++;                              // counter for number of stored values
    t ++;                                 // clock  - continue counting
    
  } // output to textarea
  
  row = 0;                                // reset
  
  toClipboard.style.color = dgreen;
  
  R[0] = d255_to_bin8( temp )             // place the number (unsigned) of the actually written data in D0
  rf_R (0 );
  N = "0";
  Z = temp === 0 ? '1': '0';              // set Z flag if no data was written 
  V = "0";
  C = "0";
  SR = left( SR, 4 ) + N + Z + V + C;     // Set flags in SR
  rf_SR( );
  
  ic_dec ++ 
  finalizeCommand( );
  
}
                        // RCL (IO)    ' 111 1 11 01   ReCalL  Adr(h80+A1+ST) <- file   via D1 (type: IO)  /D0 byte read
function _RCL( ) {
  
  goRCL1 = false;
  
  const reader = new FileReader( );
  const file = hcxLoad.files[0];
  
  const type = '.hcx';
  
  if ( file !== undefined  && right( file.name, 4 ) === type ) {
    
    reader.addEventListener( 'loadend',
    
    function( ) {
        
        hcxTextArea.value = reader.result;
        hcxArr = gettext( hcxTextArea ).match(/[^\r\n]+/g); // separate by line ends, bring into array
                
        // from 128 intended for data,   A1 signed  
        row =  128 + bin8_to_dec( R[3] ) + sta_dec; // read in from h80 + A1 + ST  
        ram_adr_cykl( );                            // intercept RAM area overflow, address cyclically in RAM
        //IO_SR$                                    // type data IO, left two bits in SR
        temp = 0;                                   // counting data
        
        for ( let i = 0; i < hcxArr.length; i ++ ) { // read in from hcxArr
            
            btemp1 = hcxArr[ i ].trim( );
            //-------------                  // type of data to be read in:
            switch ( IO_SR ) {
            
            case "00":                            // --- keyboard character --- 
            
                conval = btemp1.ord( );                                                    // ANSI 0..255 code value of first character  
                btemp2 = d255_to_bin8( conval );                                           // binary convert 
                set_D1( btemp2 );                                                          // put down in D1 and make visible
                RAM[ row ][2] = btemp2;                                                    // binary enter
                rf_binRAM( row );
                RAM[ row ][3] = btemp1 + sp_h( btemp1.length ) + bin8_to_hex2( btemp2 );   // write in    character, hex
                rf_assFlagsRAM( row );
                break;
                
            case "01":                             // --- number ---
                
                conval = btemp1.val( );                                                    // get value from string
                
                if ( conval > 127 || conval < -128 ) {                                     // not illustratable --> 0
                
                conval = 0;   
                btemp1 = "0";
                V = "1";                                                                   // set oVerflow flag
                
                }
                
                btemp2 = dec_to_bin8( conval );                                            // binary convert 
                set_D1 ( btemp2 );                                                         // put down in D1 and make visible
                RAM[ row ][2] = btemp2;                                                    // binary enter
                rf_binRAM( row );
                RAM[ row ][3] = btemp1 + sp_h( btemp1.length ) + bin8_to_hex2( btemp2 );   // write in    number, hex
                rf_assFlagsRAM( row );
                break;
                
            case "10":                            // --- hexadecimal xx ---
                
                conval = btemp1.hdec( );                                                   // decimal without sign: 0..255
                
                if ( conval > 255 ) {                                                      // not illustratable  --> 00
                
                conval = 0;                        
                btemp1 = "00";
                V = "1";                                                                   // set oVerflow flag
                
                }
                
                btemp2 = d255_to_bin8( conval );                                           // binary convert
                set_D1( btemp2 );                                                          // put down in D1 and make visible
                RAM[ row ][2] = btemp2;                                                    // binary enter
                rf_binRAM( row );
                RAM[ row ][3] = bin8_to_dec( btemp2 ).str( ) + sp_h( bin8_to_dec( btemp2 ).str( ).length ) + btemp1;  // write in    dec, hex
                rf_assFlagsRAM( row );
                break;
                
            case "11":                            // --- 8 bit binary ---
                
                if (  btemp1.length > 8 ) {
                    
                    btemp1 = right( btemp1, 8 );                                             // cut left to 8
                    V = "1";                                                                 // set oVerflow flag
                    
                }
                
                if (  btemp1.length < 8 ) {
                    
                    btemp1 = mkstr( "0", 8 - btemp1.length ) + btemp1;                     // fill left to 8 with 0
                    
                }
                
                bit = 0;
                
                do {                                                              // check for 0 resp. 1
                    
                    bit ++;
                    
                    if ( mid( btemp1, bit, 1 ) !== "0" && mid( btemp1 , bit, 1 )!== "1" ) {     // invalid binary digit ...
                    
                        btemp1 = "00000000";                                                      // ... zero byte
                        bit = 8;
                        V$ = "1";                                                                 // set oVerflow Flag
                        
                    }
                    
                } while ( bit < 8 );
                
                set_D1( btemp1 )                                                              // put down in D1 and make visible
                RAM[ row ][2] = btemp1;                                                       // binary enter
                rf_binRAM( row );
                RAM[ row ][3] = bin8_to_dec( btemp1 ).str( ) + sp_h( bin8_to_dec( btemp1 ).str( ).length ) + bin8_to_hex2( btemp1 )  // write in   dec, hex
                rf_assFlagsRAM( row );
                break;
                
            } // type data IO_SR
            
            row ++;
            
            if ( row === 256 ) {
                
                V = "1";                               // set oVerflow flag ... 
                break;                                 //         ... too much data for RAM size, abort 
                
            }
            
            temp ++;                                // count imported data 
            t ++;                                   // continue clock count
            
        }  // read in
        
        row = 0;                                 // set to start again
        
        R[0] = d255_to_bin8( temp );             // store number (unsigned) of read-in data in D0
        rf_R( 0 );
        
        N = "0";
        Z = temp === 0 ? 1 : 0;                  // set Z flag if no data was read
        // V   is set to 0 in advance and in the loop
        C = "0";
        SR = left( SR, 4 ) + N + Z + V + C;       // set flags in SR
        rf_SR( );
        
        cmd ='RCL1';
        goRCL1 = true;
        
    });
    
    reader.readAsText( file );
  
  } else {
    
    alert( 'incorrect file type or no selection, use *.hcx' );
    cmd ='RCL1';
    goRCL1 = true;
    
  }

}

function _RCL1( ) {
    
    goRCL1 = false;
    ic_dec ++ 
    finalizeCommand( );
    
}

                        // CPY         ' 111 1 11 10   CoPY Adr(A1)<-Adr(A0)     D0 byte via D1
function _CPY( ) {
  
  V = "0";                                 // oVerflow flag,  reset in advance
  let i = 0;                               // count data
  while ( i < R[0].bdec( ) ) {             // number of bytes to be copied in D0 (unsigned)
    
    temp = i + R[2].bdec( );               // determine source row
    
    if ( temp === 256 ) {                  //  RAM end reached ...  'messagebox("RAM end reached!","--- error during copying! ---",0)
      break;                               // ... less data are copied, abort 
    }
    
    btemp1 = RAM[ temp ][2];               // read binary from source row
    set_D1( btemp1 )                       // store in D1 and make visible
    row = i + R[3].bdec( );                // determine target row
    
    if ( row === 256 ) { 
      V = "1"                              // oVerflow    ' messagebox("RAM end reached - overflow!","--- error during copying! ---",0)
      break;                               // too many bytes for RAM size, abort 
    } 
    
    RAM[ row ][2] = btemp1;                // binary enter
    rf_binRAM( row );  
    
    RAM[ row ][3] = bin8_to_dec( btemp1 ) + sp_h( bin8_to_dec( btemp1 ).str( ).length ) + bin8_to_hex2( btemp1 ); // write in    dec, hex
    rf_assFlagsRAM( row );
     
    i ++;
    t ++;                                  // clock continue counting 
    
  }
  
  R[0] = d255_to_bin8( i );               // store number (unsigned) of copied bytes in D0
  rf_R( 0 );
  N = "0";
  Z = i === 0 ? 1 : 0;                    //  set Z flag if no data was copied
  // V  is processed beforehand and possibly in the loop at break (target row)
  C = "0";
  SR = left( SR, 4 ) + N + Z + V + C;     // set flags in SR 
  rf_SR( );
  ic_dec ++ 
  finalizeCommand( ); 
 
}
                        // STP         ' 111 1 11 11   StoP
function _STP( ) {
  
  ic_dec ++ 
  finalizeCommand( );
  // -->  modify flags not  - continuation of the program also conceivable with subsequent jump command
  stop = 1;
  // halt = 1;
  
}

</script>

</html>
